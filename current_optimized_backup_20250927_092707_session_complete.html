<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net; img-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net;">
    <title>SSVD1x - CSV Matrix Analysis - v2.0 Fixed SVD</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        .chart-container {
            background: linear-gradient(90deg, #f8fafc 0%, #f1f5f9 100%);
        }
    </style>
</head>

<body class="min-h-screen bg-gray-50">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef, createContext, useContext } = React;

        // ===================================================================
        // CORE ALGORITHMS COPIED FROM SSVD1 (PHASE 1)
        // ===================================================================

        // -------------------------------------------------------------------
        // 1. CORE MATRIX OPERATIONS
        // -------------------------------------------------------------------

        const matrixMultiply = function matrixMultiply(A, B) {
            if (!A.length || !B.length || A[0].length !== B.length) {
                throw new Error('Invalid matrix dimensions for multiplication');
            }
            const result = Array(A.length).fill().map(() => Array(B[0].length).fill(0));
            for (let i = 0; i < A.length; i++) {
                for (let j = 0; j < B[0].length; j++) {
                    for (let k = 0; k < B.length; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        };

        const transpose = function transpose(matrix) {
            if (!matrix.length || !matrix[0].length) return [];
            return matrix[0].map((_, i) => matrix.map(row => row[i]));
        };

        const norm = function norm(vector) {
            return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        };

        // -------------------------------------------------------------------
        // 2. STATISTICAL UTILITIES
        // -------------------------------------------------------------------

        const generateGaussianNoise = function generateGaussianNoise(variance) {
            const u1 = Math.random(), u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * Math.sqrt(variance);
        };

        const calculateMean = function calculateMean(array) {
            return array.reduce((sum, val) => sum + val, 0) / array.length;
        };

        const calculateVariance = function calculateVariance(array, mean = null) {
            const m = mean !== null ? mean : calculateMean(array);
            return array.reduce((sum, val) => sum + Math.pow(val - m, 2), 0) / array.length;
        };

        // -------------------------------------------------------------------
        // 3. MATRIX ROW PERMUTATION
        // -------------------------------------------------------------------

        const permuteMatrixRows = function permuteMatrixRows(matrix, fixedPattern = null) {
            if (fixedPattern) {
                // Use provided permutation pattern
                return fixedPattern.map(idx => matrix[idx]);
            }
            // Original random permutation of columns within each row
            const permuted = matrix.map(row => [...row]);
            for (let i = 0; i < permuted.length; i++) {
                for (let j = permuted[i].length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [permuted[i][j], permuted[i][k]] = [permuted[i][k], permuted[i][j]];
                }
            }
            return permuted;
        };

        // -------------------------------------------------------------------
        // 4. SOFT THRESHOLDING
        // -------------------------------------------------------------------

        const softThreshold = function softThreshold(x, alpha) {
            return Math.sign(x) * Math.max(Math.abs(x) - alpha, 0);
        };

        const calculateSparsity = function calculateSparsity(vector) {
            const nonZeros = vector.filter(x => Math.abs(x) > 1e-8).length;
            return vector.length > 0 ? (vector.length - nonZeros) / vector.length : 0;
        };

        // -------------------------------------------------------------------
        // 5. SVD IMPLEMENTATION (POWER ITERATION)
        // -------------------------------------------------------------------
        
        // SVD_v2.1_VALIDATED: Power iteration implementation with convergence criteria
        const simpleSVD = function simpleSVD(X) {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            const P = X.length;
            const N = X[0].length;

            // Use power iteration to find dominant singular vectors
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = norm(v);
            v = v.map(x => x / vNorm);
            let u = Array(P).fill(0);
            let prevSingularValue = 0;

            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 50; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += X[i][j] * v[j];
                    }
                }

                // Normalize u and get singular value
                const uNormValue = norm(u);
                if (uNormValue === 0) break;
                u = u.map(x => x / uNormValue);

                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += X[i][j] * u[i];
                    }
                }

                // Normalize v and get singular value
                vNorm = norm(v);
                if (vNorm === 0) break;
                v = v.map(x => x / vNorm);

                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-8) {
                    break;
                }
                prevSingularValue = vNorm;
            }

            // Final singular value computation
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * X[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };

        const svd1Sync = simpleSVD;
        const svd1 = async function(X) {
            await new Promise(resolve => setTimeout(resolve, 0));
            return simpleSVD(X);
        };
        
        // COMPUTE_ALL_SV_v2.0_NUMERICALLY_STABLE: Direct SVD decomposition for all singular values
        const computeAllSingularValues = (X) => {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            
            const P = X.length;
            const N = X[0].length;
            const numSingularValues = Math.min(P, N);
            
            console.log('Computing all singular values via direct SVD decomposition...');
            console.log(`Matrix dimensions: ${P} x ${N}, computing ${numSingularValues} singular values`);
            
            const singularValues = [];
            
            // Create working copy of matrix
            let workingMatrix = X.map(row => [...row]);
            
            // Use deflation to extract all singular values one by one
            for (let k = 0; k < numSingularValues; k++) {
                // Use power iteration to find dominant singular value
                const svdResult = performSingleSVD(workingMatrix);
                
                if (svdResult.s < 1e-12) {
                    console.log(`Singular value ${k+1} is effectively zero (${svdResult.s.toExponential(3)}), stopping deflation`);
                    // Fill remaining with zeros
                    for (let j = k; j < numSingularValues; j++) {
                        singularValues.push(0);
                    }
                    break;
                }
                
                singularValues.push(svdResult.s);
                
                // Deflate: subtract rank-1 approximation Ïƒ * u * v^T
                if (k < numSingularValues - 1) {
                    const currentP = workingMatrix.length;
                    const currentN = workingMatrix[0].length;
                    
                    for (let i = 0; i < currentP; i++) {
                        for (let j = 0; j < currentN; j++) {
                            workingMatrix[i][j] -= svdResult.s * svdResult.u[i] * svdResult.v[j];
                        }
                    }
                }
                
                if (k % 10 === 0 || k < 5) {
                    console.log(`Singular value ${k+1}: ${svdResult.s.toFixed(6)}`);
                }
            }
            
            // Sort in descending order
            singularValues.sort((a, b) => b - a);
            
            console.log(`Computed ${singularValues.length} singular values`);
            console.log('Largest 10 singular values:', singularValues.slice(0, 10).map(s => s.toFixed(6)));
            console.log('Singular value range:', singularValues[0]?.toFixed(6), 'to', singularValues[singularValues.length-1]?.toFixed(6));
            
            return singularValues;
        };
        
        // Perform single SVD to get dominant singular triplet (u, Ïƒ, v)
        const performSingleSVD = (matrix) => {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Initialize random right singular vector
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
            v = v.map(x => x / vNorm);
            
            let u = Array(P).fill(0);
            let prevSingularValue = 0;
            
            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 100; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += matrix[i][j] * v[j];
                    }
                }
                
                // Normalize u and get singular value estimate
                const uNorm = Math.sqrt(u.reduce((sum, x) => sum + x * x, 0));
                if (uNorm < 1e-15) break;
                u = u.map(x => x / uNorm);
                
                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += matrix[i][j] * u[i];
                    }
                }
                
                // Normalize v and get singular value
                vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
                if (vNorm < 1e-15) break;
                v = v.map(x => x / vNorm);
                
                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-10) {
                    break;
                }
                prevSingularValue = vNorm;
            }
            
            // Final singular value computation: Ïƒ = u^T * X * v
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * matrix[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };
        
        // Improved eigenvalue computation using iterative methods for symmetric matrices
        const computeEigenvalues = (A) => {
            const n = A.length;
            console.log('Computing eigenvalues using improved method for', n, 'x', n, 'matrix');
            
            const trace = A.reduce((sum, row, i) => sum + row[i], 0);
            console.log('Matrix trace:', trace.toFixed(2));
            
            // Use deflation method with power iteration for better accuracy
            const eigenvalues = [];
            let workingMatrix = A.map(row => [...row]);
            
            for (let k = 0; k < n; k++) {
                const eigenvalue = powerIterationEigenvalue(workingMatrix);
                
                if (eigenvalue < 1e-10) {
                    // Fill remaining with small positive values
                    const remaining = n - eigenvalues.length;
                    for (let i = 0; i < remaining; i++) {
                        eigenvalues.push(Math.max(1e-12, eigenvalue * Math.random()));
                    }
                    break;
                }
                
                eigenvalues.push(eigenvalue);
                
                // Deflate matrix by removing the contribution of this eigenvalue
                // Find corresponding eigenvector and deflate
                const eigenvector = powerIterationEigenvector(workingMatrix);
                
                // Deflate: A := A - Î» * v * v^T
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        workingMatrix[i][j] -= eigenvalue * eigenvector[i] * eigenvector[j];
                    }
                }
                
                if (k % 10 === 0) {
                    console.log(`Computed eigenvalue ${k+1}: ${eigenvalue.toFixed(2)}`);
                }
            }
            
            console.log('Computed', eigenvalues.length, 'eigenvalues, largest =', eigenvalues[0]?.toFixed(2));
            console.log('Eigenvalue range:', Math.min(...eigenvalues).toFixed(2), 'to', Math.max(...eigenvalues).toFixed(2));
            
            return eigenvalues.sort((a, b) => b - a);
        };
        
        // Power iteration for largest eigenvalue of symmetric matrix
        const powerIterationEigenvalue = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            let lambda = 0;
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Compute eigenvalue estimate v^T * A * v
                const newLambda = v.reduce((sum, vi, i) => sum + vi * Av[i], 0);
                
                // Check convergence
                if (Math.abs(newLambda - lambda) < 1e-12) {
                    lambda = newLambda;
                    break;
                }
                lambda = newLambda;
                
                // Update v for next iteration
                v = Av;
            }
            
            return lambda;
        };
        
        // Power iteration for eigenvector corresponding to largest eigenvalue
        const powerIterationEigenvector = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Update v for next iteration
                v = Av;
            }
            
            // Final normalization
            const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
            if (norm > 1e-15) {
                v = v.map(x => x / norm);
            }
            
            return v;
        };
        
        // Wrapper function to compute eigenvalues (ÏƒÂ²) from singular values (Ïƒ) 
        const fullSVD = (matrix) => {
            // Step 1: Compute all singular values via direct SVD
            const singularValues = computeAllSingularValues(matrix);
            
            // Step 2: Square them to get eigenvalues (ÏƒÂ²)
            const eigenvalues = singularValues.map(sigma => sigma * sigma);
            
            console.log('Converted singular values to eigenvalues:');
            console.log('Singular values (Ïƒ):', singularValues.slice(0, 5).map(s => s.toFixed(2)));
            console.log('Eigenvalues (ÏƒÂ²):', eigenvalues.slice(0, 5).map(e => e.toFixed(2)));
            
            return eigenvalues;
        };

        // -------------------------------------------------------------------
        // 6. CALCULATE ALPHA MAX
        // -------------------------------------------------------------------
        
        // ALPHAMAX_v1.2_VALIDATED: Sparsity parameter upper bound calculation
        const calculateAlphaMax = function(matrix, alphaMaxMultiplier = 0.75) {
            if (!matrix || !matrix.length) {
                return 1.0;
            }
            
            try {
                const { u, s } = svd1Sync(matrix);
                const maxAbsU1 = Math.max(...u.map(val => Math.abs(val)));
                const result = alphaMaxMultiplier * maxAbsU1 * s;
                return result;
            } catch (error) {
                console.error('AlphaMax calculation failed:', error);
                return 1.0;
            }
        };

        // -------------------------------------------------------------------
        // 7. SSVD-R1 ALGORITHM
        // -------------------------------------------------------------------
        
        // SSVD-R1_v2.3_VALIDATED: Correct SSVD1 implementation following exact MATLAB sequence: u=X*v, threshold, normalize
        const SSVDR1Algorithm = async function({ matrix, alpha, maxIter = 1000, tolerance = 0.001, onProgress = null, initialSVD = null }) {
            console.log(`SSVDR1Algorithm v2.3 called with: alpha=${alpha}, maxIter=${maxIter}, tolerance=${tolerance}, matrixSize=${matrix?.length}x${matrix?.[0]?.length}`);
            if (!matrix || !matrix.length || !matrix[0].length) {
                throw new Error('Invalid matrix provided');
            }

            const P = matrix.length;
            const N = matrix[0].length;

            // Special case: alpha = 0, return standard SVD result
            if (Math.abs(alpha) < 1e-10) {
                console.log(`Alpha ${alpha} treated as 0, returning standard SVD`);
                const svdResult = initialSVD || await svd1(matrix);
                const { u, s, v } = svdResult;
                const nonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
                const sparsity = (P - nonZeros) / P;

                return {
                    u, s, v,
                    iterations: 0,
                    converged: true,
                    errors: [0],
                    sparsityHistory: [sparsity],
                    singularValues: [s]
                };
            }

            // Step 1: Get initial SVD (u0, s0, v0) - this is the expensive part, done ONCE
            if (initialSVD) {
                console.log('âœ… Using cached SVD - skipping SVD computation');
            } else {
                console.log('âš ï¸ No cached SVD - computing SVD from scratch');
            }
            const svdResult = initialSVD || await svd1(matrix);
            const { u: u0, s: s0, v: v0 } = svdResult;

            // Initialize with SVD results
            let u = [...u0];
            let s = s0;
            let v = [...v0];  // v will be updated during iterations per MATLAB reference
            let uPrev = [...u0];

            let iterCount = 0;
            let error = 1;
            const errors = [];
            const sparsityHistory = [];
            const singularValues = [s0];

            // CORRECT SSVD1: Iterate only on u vector with soft thresholding
            const iterStartTime = performance.now();
            while (error > tolerance && iterCount < maxIter) {
                iterCount++;

                // Store previous u for convergence check
                uPrev = [...u];

                // STEP 1: Update u from X*v (MATLAB line 75: u = X*v)
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += matrix[i][j] * v[j];
                    }
                }

                // STEP 2: Apply soft thresholding to u (MATLAB line 76: u = sign(u).*max(abs(u)-alpha,0))
                u = u.map(x => Math.sign(x) * Math.max(Math.abs(x) - alpha, 0));

                // STEP 3: Normalize u if non-zero (MATLAB line 78: u = u/norm(u,2))
                let uNorm = norm(u);
                if (uNorm > 0) {
                    u = u.map(x => x / uNorm);
                } else {
                    // If u becomes all zeros, we've converged to zero solution
                    console.log(`Converged to zero solution at iteration ${iterCount}`);
                    u = Array(P).fill(0);
                    s = 0;
                    break;
                }

                // STEP 4: Update v from X^T*u (MATLAB line 69: v = X'*u0)
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += matrix[i][j] * u[i];
                    }
                }

                // STEP 5: Normalize v (MATLAB line 72: v = v./norm(v,2))
                let vNorm = norm(v);
                if (vNorm > 0) {
                    v = v.map(x => x / vNorm);
                } else {
                    // If v becomes all zeros, we've converged to zero solution
                    console.log(`v became zero at iteration ${iterCount}`);
                    break;
                }

                // Check convergence based on change in u vector (NOT matrix operations!)
                error = 0;
                for (let i = 0; i < u.length; i++) {
                    const diff = u[i] - uPrev[i];
                    error += diff * diff;
                }
                error = Math.sqrt(error);
                errors.push(error);

                // Track sparsity
                const nonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
                const sparsity = (P - nonZeros) / P;
                sparsityHistory.push(sparsity);

                // Compute singular value for this sparse u (optional, for monitoring)
                // s = u^T * X * v (only computation involving matrix, done rarely)
                if (iterCount % 10 === 0 || error < tolerance) {
                    s = Math.abs(u.reduce((sum, uVal, i) =>
                        sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0));
                    singularValues.push(s);
                }

                // Early termination for numerical stability
                if (isNaN(error) || !isFinite(error)) {
                    console.warn('Numerical instability detected');
                    break;
                }

                // Yield control back to browser periodically
                if (iterCount % 100 === 0) {
                    if (onProgress) {
                        onProgress(iterCount, maxIter, error);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            const iterEndTime = performance.now();
            console.log(`SSVD1 v2.3 completed: ${iterCount} iterations in ${((iterEndTime - iterStartTime) / 1000).toFixed(2)}s (correct MATLAB sequence)`);

            // Final singular value computation (only if u is non-zero)
            const finalS = s > 0 ? Math.abs(u.reduce((sum, uVal, i) =>
                sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0)) : 0;

            // Count final non-zeros for reporting
            const finalNonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
            const finalSparsity = (P - finalNonZeros) / P;

            return {
                u,
                s: finalS,
                v,
                iterations: iterCount,
                converged: error <= tolerance,
                errors,
                sparsityHistory,
                singularValues,
                convergenceInfo: {
                    finalError: error,
                    tolerance: tolerance,
                    sparsity: finalSparsity,
                    nonZeros: finalNonZeros
                }
            };
        };

        // -------------------------------------------------------------------
        // 8. FDR ANALYSIS
        // -------------------------------------------------------------------
        
        // Fixed permutation pattern generation for reproducible testing
        const generateFixedPermutations = function(Nperm, matrixRows) {
            const patterns = [];
            for (let i = 0; i < Nperm; i++) {
                const indices = Array.from({length: matrixRows}, (_, i) => i);
                // Fisher-Yates shuffle with fixed sequence
                for (let j = indices.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [indices[j], indices[k]] = [indices[k], indices[j]];
                }
                patterns.push(indices);
            }
            return patterns;
        };
        
        // Store/retrieve patterns for A/B testing
        const savePermutationPatterns = function(patterns) {
            localStorage.setItem('ssvd1x_fixed_permutations', JSON.stringify(patterns));
        };
        
        const loadPermutationPatterns = function() {
            const stored = localStorage.getItem('ssvd1x_fixed_permutations');
            return stored ? JSON.parse(stored) : null;
        };
        
        // FDR_ANALYSIS_v2.0_VALIDATED: Empirical False Discovery Rate with permutation testing
        const runFDRAnalysis = async function({ matrix, alpha0, alphaMax, Nalpha, Nperm, nsupp, onProgress, initialSVD = null, isCancelled = () => false, useFixedPermutations = false }) {
            const P = matrix.length;
            const pi0 = (P - nsupp) / P;
            
            // Load or generate fixed permutation patterns if requested
            let fixedPatterns = null;
            if (useFixedPermutations) {
                fixedPatterns = loadPermutationPatterns();
                if (!fixedPatterns || fixedPatterns.length < Nperm) {
                    console.log('Generating fixed permutation patterns...');
                    fixedPatterns = generateFixedPermutations(Nperm, P);
                    savePermutationPatterns(fixedPatterns);
                    console.log(`Generated and saved ${Nperm} fixed permutation patterns`);
                } else {
                    console.log(`Using ${Nperm} fixed permutation patterns from storage`);
                }
            }
            
            const alphaValues = [];
            for (let i = 0; i < Nalpha; i++) {
                const alpha = alpha0 + (alphaMax - alpha0) * i / (Nalpha - 1);
                alphaValues.push(alpha);
            }

            const results = [];
            let totalProgress = 0;
            const totalRuns = Nalpha * (1 + Nperm);

            for (let alphaIdx = 0; alphaIdx < alphaValues.length; alphaIdx++) {
                // Check for cancellation before processing each alpha
                if (isCancelled()) {
                    console.log('FDR analysis cancelled by user');
                    return {
                        alphaValues: alphaValues.slice(0, alphaIdx),
                        fdrValues: results.map(r => r.eFDR),
                        detectionCounts: results.map(r => r.detectionCount),
                        gradients: results.map(r => r.gradient),
                        results,
                        pi0,
                        totalRuns,
                        cancelled: true
                    };
                }
                
                const alpha = alphaValues[alphaIdx];
                
                try {
                    console.log(`Starting original SSVD for alpha ${alphaIdx + 1}/${Nalpha}: ${alpha.toFixed(6)}`);
                    
                    // Run SSVD on original matrix with optimized parameters
                    const alphaRatio = alpha / alphaMax;
                    
                    // For ORIGINAL matrix: Give small alphas the iterations they need
                    const adaptiveMaxIterOrig = 
                        alphaRatio < 0.05 ? 2000 :     // Very small: many iterations
                        alphaRatio < 0.2 ? 1000 :       // Small: standard
                        alphaRatio < 0.5 ? 500 :        // Medium: fewer
                        alphaRatio < 0.75 ? 200 :       // Large: fast
                        100;                            // Near alphaMax: very fast
                    
                    const adaptiveToleranceOrig = 
                        alphaRatio < 0.2 ? 0.0001 :     // Tight for small alphas
                        alphaRatio < 0.5 ? 0.001 :      
                        0.01;                           // Looser for large alphas
                    
                    const originalResult = await SSVDR1Algorithm({
                        matrix, 
                        alpha,
                        maxIter: adaptiveMaxIterOrig,   // Use adaptive
                        tolerance: adaptiveToleranceOrig,  // Use adaptive
                        initialSVD   // Pass the cached SVD for original matrix
                    });
                    const originalDetections = originalResult.u.filter(val => Math.abs(val) > 1e-8).length;
                    
                    console.log(`Original SSVD completed for alpha ${alpha.toFixed(6)}: ${originalDetections} detections, ${originalResult.iterations} iterations`);
                    
                    // Early termination: If solution becomes all zeros, all higher alphas will also be zero
                    if (originalDetections === 0 && alphaIdx > 0) {
                        console.log(`Early termination: Zero detections at alpha ${alpha.toFixed(6)}. Skipping remaining alphas.`);
                        // Fill remaining results with zeros
                        for (let i = alphaIdx; i < alphaValues.length; i++) {
                            results.push({
                                alpha: alphaValues[i],
                                detectionCount: 0,
                                eFDR: 0,
                                gradient: 0,
                                permutationDetections: 0
                            });
                        }
                        break; // Exit the alpha loop
                    }
                    
                    totalProgress++;
                    if (onProgress) {
                        onProgress(totalProgress, totalRuns, 
                            `Alpha ${alphaIdx + 1}/${Nalpha} (Î±=${alpha.toFixed(4)}): Original run`);
                    }

                // Permutation tests with batching
                let totalPermDetections = 0;
                
                // Detect optimal batch size based on hardware
                const batchSize = Math.min(navigator.hardwareConcurrency || 4, 8);
                console.log(`Processing ${Nperm} permutations in batches of ${batchSize}`);
                
                // Process permutations in batches
                for (let batchStart = 0; batchStart < Nperm; batchStart += batchSize) {
                    // Check for cancellation before each batch
                    if (isCancelled()) {
                        console.log('FDR analysis cancelled during permutations');
                        break;
                    }
                    
                    const batchEnd = Math.min(batchStart + batchSize, Nperm);
                    const currentBatchSize = batchEnd - batchStart;
                    const batchNumber = Math.floor(batchStart / batchSize) + 1;
                    const totalBatches = Math.ceil(Nperm / batchSize);
                    
                    console.log(`Starting batch ${batchNumber}/${totalBatches} (perms ${batchStart + 1}-${batchEnd}) for alpha ${alphaIdx + 1}/${Nalpha}`);
                    
                    // Create promises for all permutations in this batch
                    const batchPromises = [];
                    for (let perm = batchStart; perm < batchEnd; perm++) {
                        batchPromises.push(
                            (async () => {
                                try {
                                    const permutedMatrix = useFixedPermutations && fixedPatterns ? 
                                        permuteMatrixRows(matrix, fixedPatterns[perm]) :
                                        permuteMatrixRows(matrix);
                                    // Data-driven adaptive parameters based on alphaMax ratio (OPTIMIZED for permutations)
                                    const alphaRatio = alpha / alphaMax;
                                    
                                    // For PERMUTATIONS: Prioritize speed, invert iteration logic
                                    const adaptiveMaxIter = 
                                        alphaRatio < 0.05 ? 400 :      // Very small: cap iterations (was 1000!)
                                        alphaRatio < 0.2 ? 350 :        // Small: less time
                                        alphaRatio < 0.5 ? 250 :        // Medium: faster
                                        alphaRatio < 0.75 ? 150 :       // Large: very fast
                                        50;                             // Near alphaMax: minimal
                                    
                                    const adaptiveTolerance = 
                                        alphaRatio < 0.2 ? 0.01 :       // Loose for small alphas (was 0.0001!)
                                        alphaRatio < 0.5 ? 0.005 :      
                                        0.001;                          // Tighter only for large alphas
                                    
                                    // Use reduced parameters for permutations (only need approximate null distribution)
                                    const permResult = await SSVDR1Algorithm({
                                        matrix: permutedMatrix,
                                        alpha,
                                        maxIter: adaptiveMaxIter,  // Adaptive based on alpha
                                        tolerance: adaptiveTolerance  // Adaptive based on alpha
                                    });
                                    const permDetections = permResult.u.filter(val => Math.abs(val) > 1e-8).length;
                                    return permDetections;
                                } catch (error) {
                                    console.error(`Permutation ${perm + 1} in batch ${batchNumber} failed:`, error);
                                    return 0; // Return 0 detections on error
                                }
                            })()
                        );
                    }
                    
                    // Wait for all permutations in batch to complete
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Sum up detections from this batch
                    const batchDetections = batchResults.reduce((sum, val) => sum + val, 0);
                    totalPermDetections += batchDetections;
                    
                    console.log(`Batch ${batchNumber}/${totalBatches} completed: ${batchDetections} total detections from ${currentBatchSize} permutations`);
                    
                    // Update progress for the batch
                    totalProgress += currentBatchSize;
                    if (onProgress) {
                        onProgress(totalProgress, totalRuns, 
                            `Alpha ${alphaIdx + 1}/${Nalpha} (Î±=${alpha.toFixed(4)}): Permutation batch ${batchNumber}/${totalBatches}`);
                    }
                }

                    const avgPermDetections = totalPermDetections / Nperm;
                    const expectedFalsePos = pi0 * avgPermDetections;
                    const fdr = originalDetections > 0 ? expectedFalsePos / originalDetections : 0;
                    const eFDR = Math.min(fdr * 100, 100);
                    
                    // Calculate gradient (change in detections)
                    let gradient = 0;
                    if (alphaIdx > 0) {
                        gradient = results[alphaIdx - 1].detectionCount - originalDetections;
                    }

                    results.push({
                        alpha,
                        detectionCount: originalDetections,
                        avgPermDetections,
                        eFDR,
                        gradient
                    });
                    
                    console.log(`Alpha ${alphaIdx + 1}/${Nalpha} complete: eFDR = ${eFDR.toFixed(2)}%`);
                    
                } catch (error) {
                    console.error(`Alpha ${alphaIdx + 1} failed:`, error);
                    // Add a failed result to keep indexing consistent
                    results.push({
                        alpha,
                        detectionCount: 0,
                        avgPermDetections: 0,
                        eFDR: 100,  // Assume worst case
                        gradient: 0
                    });
                }
            }

            return {
                alphaValues,
                fdrValues: results.map(r => r.eFDR),
                detectionCounts: results.map(r => r.detectionCount),
                gradients: results.map(r => r.gradient),
                results,
                pi0,
                totalRuns
            };
        };

        // ===================================================================
        // WEB WORKER FDR ANALYSIS - PERFORMANCE OPTIMIZED
        // ===================================================================

        // Web Worker wrapper for FDR analysis to prevent browser tab throttling
        let fdrWorker = null;
        let workerMessageId = 0;
        const workerPromises = new Map();

        const initializeFDRWorker = () => {
            if (fdrWorker) {
                fdrWorker.terminate();
            }

            fdrWorker = new Worker('fdr-worker.js');

            fdrWorker.onmessage = (e) => {
                const { type, id, data } = e.data;
                const promise = workerPromises.get(id);

                switch (type) {
                    case 'progress':
                        if (promise && promise.onProgress) {
                            promise.onProgress(data.current, data.total, data.message);
                        }
                        break;

                    case 'storeProgress':
                        // Store enhanced progress data from worker
                        saveFDRProgress(data);
                        break;

                    case 'result':
                        if (promise) {
                            promise.resolve(data);
                            workerPromises.delete(id);
                        }
                        break;

                    case 'error':
                        if (promise) {
                            promise.reject(new Error(data.message));
                            workerPromises.delete(id);
                        }
                        break;

                    case 'cancelled':
                        if (promise) {
                            promise.resolve({ cancelled: true });
                            workerPromises.delete(id);
                        }
                        break;

                    case 'ready':
                        console.log('FDR Worker ready for analysis');
                        break;
                }
            };

            fdrWorker.onerror = (error) => {
                console.error('FDR Worker error:', error);
                // Fallback to main thread analysis if worker fails
                workerPromises.forEach(promise => {
                    promise.reject(new Error('Worker failed: ' + error.message));
                });
                workerPromises.clear();
            };

            return fdrWorker;
        };

        // Web Worker-based FDR analysis function
        const runFDRAnalysisWorker = async function(params) {
            return new Promise((resolve, reject) => {
                // Initialize worker if needed
                if (!fdrWorker) {
                    initializeFDRWorker();
                }

                const messageId = ++workerMessageId;

                // Store promise handlers
                workerPromises.set(messageId, {
                    resolve,
                    reject,
                    onProgress: params.onProgress
                });

                // Send analysis request to worker
                fdrWorker.postMessage({
                    type: 'runFDRAnalysis',
                    id: messageId,
                    data: {
                        matrix: params.matrix,
                        alpha0: params.alpha0,
                        alphaMax: params.alphaMax,
                        Nalpha: params.Nalpha,
                        Nperm: params.Nperm,
                        nsupp: params.nsupp,
                        initialSVD: params.initialSVD,
                        useFixedPermutations: params.useFixedPermutations
                    }
                });

                // Handle cancellation
                if (params.isCancelled) {
                    const checkCancellation = () => {
                        if (params.isCancelled()) {
                            fdrWorker.postMessage({
                                type: 'cancel',
                                id: messageId
                            });
                        } else {
                            setTimeout(checkCancellation, 1000); // Check every second
                        }
                    };
                    checkCancellation();
                }
            });
        };

        // Enhanced FDR analysis with fallback
        const runFDRAnalysisEnhanced = async function(params) {
            // Try Web Worker first for better performance
            try {
                console.log('Starting FDR analysis with Web Worker for optimal performance...');
                return await runFDRAnalysisWorker(params);
            } catch (error) {
                console.warn('Web Worker FDR analysis failed, falling back to main thread:', error);

                // Fallback to original main thread implementation
                return await runFDRAnalysis(params);
            }
        };

        // Enhanced progress persistence system
        const saveFDRProgress = (progressData) => {
            try {
                localStorage.setItem('ssvd1x_fdr_progress', JSON.stringify({
                    ...progressData,
                    timestamp: Date.now()
                }));
            } catch (error) {
                console.warn('Failed to save FDR progress:', error);
            }
        };

        // System resource monitoring
        const getSystemResources = () => {
            const resources = {
                timestamp: Date.now(),
                memory: {},
                performance: {},
                browser: {}
            };

            // Memory information (if available)
            if (performance.memory) {
                resources.memory = {
                    used: Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)),
                    total: Math.round(performance.memory.totalJSHeapSize / (1024 * 1024)),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / (1024 * 1024))
                };
            }

            // Performance timing
            if (performance.now) {
                resources.performance = {
                    currentTime: Math.round(performance.now()),
                    timeOrigin: performance.timeOrigin
                };
            }

            // Browser information
            resources.browser = {
                hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
                userAgent: navigator.userAgent.includes('Chrome') ? 'Chrome' :
                          navigator.userAgent.includes('Firefox') ? 'Firefox' :
                          navigator.userAgent.includes('Safari') ? 'Safari' : 'Other',
                online: navigator.onLine
            };

            return resources;
        };

        // Background progress sync system
        let progressSyncInterval = null;
        const startProgressSync = () => {
            if (progressSyncInterval) return;

            progressSyncInterval = setInterval(() => {
                // Check for updated progress from worker storage
                const storedProgress = loadFDRProgress();
                if (storedProgress && storedProgress.timestamp > Date.now() - 10000) {
                    // Update UI with fresh progress if recent (within 10 seconds)
                    if (window.setProgress && typeof window.setProgress === 'function') {
                        window.setProgress(storedProgress);
                    }
                }
            }, 2000); // Check every 2 seconds
        };

        const stopProgressSync = () => {
            if (progressSyncInterval) {
                clearInterval(progressSyncInterval);
                progressSyncInterval = null;
            }
        };

        // Tab visibility change handler for progress sync
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // Tab became visible - immediately sync progress
                const storedProgress = loadFDRProgress();
                if (storedProgress && window.setProgress) {
                    window.setProgress(storedProgress);
                }
            }
        });

        const loadFDRProgress = () => {
            try {
                const stored = localStorage.getItem('ssvd1x_fdr_progress');
                if (stored) {
                    const progress = JSON.parse(stored);
                    // Check if progress is recent (within 24 hours)
                    if (Date.now() - progress.timestamp < 24 * 60 * 60 * 1000) {
                        return progress;
                    }
                }
            } catch (error) {
                console.warn('Failed to load FDR progress:', error);
            }
            return null;
        };

        const clearFDRProgress = (reportFinalTime = false) => {
            try {
                if (reportFinalTime) {
                    // Capture final elapsed time before clearing
                    const stored = localStorage.getItem('ssvd1x_fdr_progress');
                    if (stored) {
                        const progress = JSON.parse(stored);
                        if (progress.elapsedTimeFormatted) {
                            console.log(`ðŸŽ‰ eFDR Analysis completed in: ${progress.elapsedTimeFormatted}`);

                            // Show completion notification with elapsed time
                            const completionMessage = `eFDR Analysis Complete!\n\nTotal Runtime: ${progress.elapsedTimeFormatted}\nAnalysis Type: ${progress.analysisData?.alphaValues || 'N/A'} alphas Ã— ${progress.analysisData?.permutations || 'N/A'} permutations\nMatrix Size: ${progress.analysisData?.matrixSize || 'N/A'}`;

                            // Use a timeout to show after results are displayed
                            setTimeout(() => {
                                alert(completionMessage);
                            }, 1000);
                        }
                    }
                }
                localStorage.removeItem('ssvd1x_fdr_progress');
            } catch (error) {
                console.warn('Failed to clear FDR progress:', error);
            }
        };

        // Keep-alive system to prevent throttling
        let keepAliveInterval = null;
        let audioContext = null;

        const startKeepAlive = () => {
            if (keepAliveInterval) return;

            // Audio context keep-alive (silent)
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Silent
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                oscillator.start();

                console.log('Audio context keep-alive started');
            } catch (error) {
                console.warn('Audio context keep-alive failed:', error);
            }

            // Periodic small operations to keep tab active
            keepAliveInterval = setInterval(() => {
                // Minimal operation to maintain activity
                performance.now();
            }, 30000); // Every 30 seconds

            console.log('Keep-alive system activated for long-running analysis');
        };

        const stopKeepAlive = () => {
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
                keepAliveInterval = null;
            }

            if (audioContext) {
                try {
                    audioContext.close();
                    audioContext = null;
                } catch (error) {
                    console.warn('Error closing audio context:', error);
                }
            }

            console.log('Keep-alive system deactivated');
        };

        // ===================================================================
        // PHASE 3: DATA REVIEW - STATISTICS AND VISUALIZATIONS
        // ===================================================================

        // Calculate comprehensive matrix statistics
        const calculateMatrixStatistics = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Memory-efficient overall statistics
            let min = Infinity, max = -Infinity, sum = 0, count = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    if (val < min) min = val;
                    if (val > max) max = val;
                    sum += val;
                    count++;
                }
            }
            const mean = sum / count;
            
            // Calculate variance in second pass
            let sumSquaredDiff = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    sumSquaredDiff += Math.pow(val - mean, 2);
                }
            }
            const variance = sumSquaredDiff / count;
            const stdDev = Math.sqrt(variance);
            
            // Row statistics (across samples for each feature)
            const rowMeans = matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N);
            const rowStdDevs = matrix.map((row, i) => {
                const rowMean = rowMeans[i];
                const variance = row.reduce((sum, val) => sum + Math.pow(val - rowMean, 2), 0) / N;
                return Math.sqrt(variance);
            });
            
            // Column statistics (across features for each sample)
            const columnMeans = Array(N).fill(0).map((_, j) => 
                matrix.reduce((sum, row) => sum + row[j], 0) / P
            );
            const columnStdDevs = columnMeans.map((colMean, j) => {
                const variance = matrix.reduce((sum, row) => sum + Math.pow(row[j] - colMean, 2), 0) / P;
                return Math.sqrt(variance);
            });
            
            return {
                P, N, min, max, mean, stdDev,
                rowMeans, rowStdDevs,
                columnMeans, columnStdDevs
            };
        };

        // Calculate eigenvalue spectrum (ÏƒÂ²) from SVD
        const calculateEigenvalueSpectrum = function(matrix) {
            console.log('ðŸ”¥ COMPUTING EIGENVALUE SPECTRUM (ÏƒÂ²) v3.0 ðŸ”¥');
            console.log('Matrix dimensions for SVD:', matrix.length, 'x', matrix[0].length);
            // Use fullSVD to get eigenvalues (ÏƒÂ²)
            const eigenvalues = fullSVD(matrix);
            console.log('ðŸ”¥ EIGENVALUES COMPUTED:', eigenvalues.length, 'values, range:', 
                        eigenvalues.length > 0 ? `${eigenvalues[0].toFixed(2)} to ${eigenvalues[eigenvalues.length-1].toFixed(2)}` : 'empty');
            return eigenvalues; // Return array of eigenvalues (ÏƒÂ²)
        };

        // ===================================================================
        // DATA PREPROCESSING FUNCTIONS
        // ===================================================================

        // Calculate Frobenius norm of a matrix
        const calculateFrobeniusNorm = function(matrix) {
            let sumSquares = 0;
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    sumSquares += matrix[i][j] * matrix[i][j];
                }
            }
            return Math.sqrt(sumSquares);
        };

        // Apply preprocessing: Frobenius normalization followed by row centering
        const preprocessMatrix = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Step 1: Calculate Frobenius norm
            const frobeniusNorm = calculateFrobeniusNorm(matrix);
            console.log(`Frobenius norm of original matrix: ${frobeniusNorm.toFixed(6)}`);
            
            // Step 2: Normalize by Frobenius norm
            const normalizedMatrix = matrix.map(row => 
                row.map(val => val / frobeniusNorm)
            );
            
            // Step 3: Calculate row means of normalized matrix
            const rowMeans = normalizedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            
            // Step 4: Center each row by subtracting row mean
            const preprocessedMatrix = normalizedMatrix.map((row, i) => 
                row.map(val => val - rowMeans[i])
            );
            
            // Verify preprocessing
            const newFrobeniusNorm = calculateFrobeniusNorm(preprocessedMatrix);
            const newRowMeans = preprocessedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            const maxRowMean = Math.max(...newRowMeans.map(Math.abs));
            
            console.log(`Frobenius norm after preprocessing: ${newFrobeniusNorm.toFixed(6)}`);
            console.log(`Max absolute row mean after centering: ${maxRowMean.toExponential(3)}`);
            
            return {
                preprocessedMatrix,
                frobeniusNormOriginal: frobeniusNorm,
                frobeniusNormProcessed: newFrobeniusNorm,
                rowMeansOriginal: matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N),
                rowMeansProcessed: newRowMeans
            };
        };

        // ===================================================================
        // REACT COMPONENTS (PHASE 2: ENHANCED CSV UPLOAD)
        // ===================================================================

        // CSV Upload Component with drag-and-drop and preview
        const CSVUploader = ({ onDataLoaded }) => {
            const [isDragging, setIsDragging] = useState(false);
            const [preview, setPreview] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingMessage, setProcessingMessage] = useState('');

            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            };

            const handleFile = (file) => {
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    alert('Please select a CSV file');
                    return;
                }

                setIsProcessing(true);
                setProcessingMessage('Starting CSV parsing...');
                
                // Use streaming for large files
                const rawData = [];
                let rowCount = 0;
                let hasHeaders = null;
                let firstRowProcessed = false;
                const fileSize = file.size;
                let bytesProcessed = 0;
                
                Papa.parse(file, {
                    worker: false, // Could enable for better performance
                    step: (row, parser) => {
                        // Process each row as it's parsed
                        if (row.data && row.data.length > 0) {
                            rawData.push(row.data);
                            rowCount++;
                            
                            // Update progress periodically
                            if (rowCount % 1000 === 0) {
                                const progress = Math.round((row.meta.cursor / fileSize) * 100);
                                setProcessingMessage(`Processing row ${rowCount.toLocaleString()} (${progress}% complete)...`);
                            }
                            
                            // For very large files, could add a row limit
                            // if (rowCount > 50000) {
                            //     parser.abort();
                            //     console.warn('Row limit reached, processing first 50,000 rows only');
                            // }
                        }
                    },
                    complete: (results) => {
                        try {
                            setProcessingMessage('Validating matrix data...');
                            
                            // Filter out empty rows
                            const filteredData = rawData.filter(row => 
                                row.some(cell => cell && cell.toString().trim() !== '')
                            );

                            if (filteredData.length === 0) {
                                throw new Error('File appears to be empty');
                            }

                            console.log(`Parsed ${filteredData.length} rows from CSV file`);

                            // Store metadata for display
                            let rowHeaders = [];
                            let columnHeaders = [];
                            let dataStartRow = 0;
                            let dataStartCol = 0;

                            // Check for column headers (first row contains non-numeric values)
                            const firstRow = filteredData[0];
                            const hasColumnHeaders = firstRow.slice(1).some(cell => {
                                const num = parseFloat(cell);
                                return isNaN(num) && cell.toString().trim() !== '';
                            });

                            // Check for row headers (first column contains non-numeric values)
                            const hasRowHeaders = filteredData.slice(1).some(row => {
                                if (row.length > 0) {
                                    const num = parseFloat(row[0]);
                                    return isNaN(num) && row[0].toString().trim() !== '';
                                }
                                return false;
                            });

                            // Detect if corner cell exists (typical for datasets with both row and column headers)
                            const hasCornerLabel = hasColumnHeaders && hasRowHeaders;

                            if (hasColumnHeaders) {
                                columnHeaders = firstRow.slice(hasRowHeaders ? 1 : 0);
                                dataStartRow = 1;
                                console.log(`Column headers detected: ${columnHeaders.slice(0, 5).join(', ')}${columnHeaders.length > 5 ? '...' : ''}`);
                            }

                            if (hasRowHeaders) {
                                rowHeaders = filteredData.slice(dataStartRow).map(row => row[0]);
                                dataStartCol = 1;
                                console.log(`Row headers detected: ${rowHeaders.slice(0, 5).join(', ')}${rowHeaders.length > 5 ? '...' : ''}`);
                            }

                            // Extract numeric data matrix
                            const dataRows = filteredData.slice(dataStartRow);
                            
                            if (dataRows.length === 0) {
                                throw new Error('No data rows found after removing headers');
                            }

                            // Convert to numeric matrix, collecting errors instead of throwing
                            const parseErrors = [];
                            const MAX_ERRORS_TO_COLLECT = 10; // Limit error collection
                            
                            const matrix = dataRows.map((row, rowIndex) => {
                                const dataRow = row.slice(dataStartCol);
                                return dataRow.map((cell, colIndex) => {
                                    const num = parseFloat(cell);
                                    if (isNaN(num)) {
                                        if (parseErrors.length < MAX_ERRORS_TO_COLLECT) {
                                            const actualRow = rowIndex + dataStartRow + 1;
                                            const actualCol = colIndex + dataStartCol + 1;
                                            let location = `row ${actualRow}, column ${actualCol}`;
                                            if (rowHeaders.length > rowIndex) {
                                                location = `gene/feature "${rowHeaders[rowIndex]}"`;
                                            }
                                            if (columnHeaders.length > colIndex) {
                                                location += `, sample "${columnHeaders[colIndex]}"`;
                                            }
                                            parseErrors.push(`${location}: "${cell}"`);
                                        }
                                        return 0; // Replace non-numeric with 0 or could use NaN
                                    }
                                    return num;
                                });
                            });
                            
                            // Report errors once if any were found
                            if (parseErrors.length > 0) {
                                const errorMessage = `Found ${parseErrors.length} non-numeric values. First few:\n${parseErrors.slice(0, 5).join('\n')}`;
                                console.warn('Parse warnings:', errorMessage);
                                // Only show alert for critical issues, not warnings
                                if (parseErrors.length > 100) {
                                    alert(`Warning: ${parseErrors.length} non-numeric values found and replaced with 0. Check console for details.`);
                                }
                            }

                            // Display format detection message
                            let formatMessage = 'Processing data';
                            if (hasColumnHeaders && hasRowHeaders) {
                                formatMessage = `Gene expression format detected: ${rowHeaders.length} genes Ã— ${columnHeaders.length} samples`;
                            } else if (hasColumnHeaders) {
                                formatMessage = `Column headers detected: ${columnHeaders.length} columns`;
                            } else if (hasRowHeaders) {
                                formatMessage = `Row headers detected: ${rowHeaders.length} rows`;
                            } else {
                                formatMessage = 'Pure numeric matrix detected';
                            }
                            setProcessingMessage(formatMessage);

                            if (matrix.length === 0 || matrix[0].length === 0) {
                                throw new Error('No valid data found in CSV');
                            }

                            // Validate rectangular matrix
                            const N = matrix[0].length;
                            const isRectangular = matrix.every((row, index) => {
                                if (row.length !== N) {
                                    throw new Error(`Row ${index + 1} has ${row.length} columns, expected ${N}`);
                                }
                                return true;
                            });

                            const P = matrix.length;

                            // Validate matrix size
                            if (P < 2 || N < 2) {
                                throw new Error(`Matrix too small: ${P}Ã—${N}. Minimum size is 2Ã—2`);
                            }

                            // Removed large matrix warning - process all sizes without confirmation

                            // Create preview (first 5Ã—5)
                            const previewSize = Math.min(5, Math.min(P, N));
                            const matrixPreview = matrix.slice(0, previewSize).map(row => row.slice(0, previewSize));

                            setPreview({
                                data: matrixPreview,
                                totalDimensions: { P, N },
                                showMore: P > previewSize || N > previewSize
                            });

                            const matrixInfo = {
                                P, N,
                                filename: file.name,
                                fileSize: file.size,
                                rowHeaders: rowHeaders.length > 0 ? rowHeaders : null,
                                columnHeaders: columnHeaders.length > 0 ? columnHeaders : null,
                                hasHeaders: hasColumnHeaders || hasRowHeaders
                            };

                            setIsProcessing(false);
                            onDataLoaded(matrix, matrixInfo);

                        } catch (error) {
                            console.error('CSV processing error:', error);
                            alert(`Error processing CSV: ${error.message}`);
                            setIsProcessing(false);
                        }
                    },
                    error: (error) => {
                        alert(`CSV parsing failed: ${error.message}`);
                        setIsProcessing(false);
                    },
                    header: false,
                    skipEmptyLines: true,
                    delimiter: ',',
                    dynamicTyping: false
                });
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">Upload CSV Matrix</h2>
                    
                    <div
                        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                            isDragging ? 'border-indigo-500 bg-indigo-50' : 'border-gray-300'
                        }`}
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                    >
                        {isProcessing ? (
                            <div className="flex flex-col items-center space-y-3">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                                <span className="text-gray-700">{processingMessage}</span>
                            </div>
                        ) : (
                            <>
                                <input
                                    type="file"
                                    accept=".csv"
                                    onChange={handleFileChange}
                                    className="hidden"
                                    id="csvUpload"
                                />
                                <div className="space-y-3">
                                    <div className="text-4xl text-gray-400 mb-4">ðŸ“Š</div>
                                    <label
                                        htmlFor="csvUpload"
                                        className="cursor-pointer inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 transition-colors"
                                    >
                                        Choose CSV File
                                    </label>
                                    <p className="text-gray-600">
                                        or drag and drop your CSV file here
                                    </p>
                                    <div className="text-sm text-gray-500 mt-2">
                                        <div className="font-medium">Supported formats:</div>
                                        <ul className="mt-1 text-xs space-y-1">
                                            <li>â€¢ Numeric CSV matrix (PÃ—N)</li>
                                            <li>â€¢ Gene expression format (row & column headers)</li>
                                            <li>â€¢ Headers automatically detected and extracted</li>
                                            <li>â€¢ Comma-separated values</li>
                                            <li>â€¢ Minimum size: 2Ã—2 data matrix</li>
                                        </ul>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>

                    {/* Matrix Preview */}
                    {preview && (
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-medium mb-3">Matrix Preview ({preview.totalDimensions.P} Ã— {preview.totalDimensions.N})</h3>
                            <div className="overflow-x-auto">
                                <table className="min-w-full text-sm">
                                    <tbody>
                                        {preview.data.map((row, i) => (
                                            <tr key={i}>
                                                {row.map((cell, j) => (
                                                    <td key={j} className="px-2 py-1 border border-gray-300 text-right font-mono">
                                                        {cell.toFixed(3)}
                                                    </td>
                                                ))}
                                                {preview.showMore && <td className="px-2 py-1 text-gray-400">...</td>}
                                            </tr>
                                        ))}
                                        {preview.showMore && (
                                            <tr>
                                                <td colSpan={preview.data[0].length + 1} className="px-2 py-1 text-center text-gray-400">â‹®</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // FDR Analysis Panel Component
        const FDRAnalysisPanel = ({ matrix, matrixInfo, onResultsReady }) => {
            // Guard against null matrixInfo
            if (!matrixInfo || !matrixInfo.P) {
                return <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="text-center text-gray-500">Loading matrix information...</div>
                </div>;
            }
            
            const [parameters, setParameters] = useState({
                Nalpha: 20,
                nsupp: Math.min(50, Math.floor(matrixInfo.P / 2)),
                Nperm: 100
            });
            const [isRunning, setIsRunning] = useState(false);
            const [progress, setProgress] = useState({ current: 0, total: 0, message: '' });
            const [isCancelled, setIsCancelled] = useState(false);

            const handleParameterChange = (param, value) => {
                setParameters(prev => ({
                    ...prev,
                    [param]: parseInt(value)
                }));
            };

            const runAnalysis = async () => {
                setIsRunning(true);
                setProgress({ current: 0, total: 0, message: 'Initializing FDR analysis...' });

                try {
                    // Start keep-alive system and progress sync for long-running analysis
                    startKeepAlive();
                    startProgressSync();

                    // Expose setProgress globally for background sync
                    window.setProgress = setProgress;

                    const results = await runFDRAnalysisEnhanced({
                        matrix,
                        alpha0: 0,
                        alphaMax: matrixInfo.alphaMax,
                        Nalpha: parameters.Nalpha,
                        Nperm: parameters.Nperm,
                        nsupp: parameters.nsupp,
                        initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                        isCancelled: () => isCancelled,  // Pass cancellation check
                        onProgress: (current, total, message) => {
                            setProgress({ current, total, message });
                            // Save progress periodically
                            if (current % 10 === 0) {
                                saveFDRProgress({ current, total, message, parameters });
                            }
                        }
                    });

                    if (results.cancelled) {
                        setProgress({ current: 0, total: 0, message: 'Analysis cancelled by user' });
                        console.log('FDR analysis was cancelled');
                    } else {
                        // Capture elapsed time before clearing progress
                        const progressData = loadFDRProgress();
                        const elapsedTime = progressData?.elapsedTimeFormatted || null;

                        // Add elapsed time to results
                        results.elapsedTime = elapsedTime;

                        onResultsReady(results);
                        clearFDRProgress(true); // Clear saved progress and report final time
                    }
                } catch (error) {
                    console.error('FDR Analysis failed:', error);
                    alert(`FDR Analysis failed: ${error.message}`);
                } finally {
                    setIsRunning(false);
                    setIsCancelled(false);
                    stopKeepAlive(); // Stop keep-alive system
                    stopProgressSync(); // Stop progress sync system
                    window.setProgress = null; // Clean up global reference
                }
            };

            const cancelAnalysis = () => {
                setIsCancelled(true);
                setProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            const estimatedTime = Math.ceil((parameters.Nalpha * (1 + parameters.Nperm)) / 10); // rough estimate in seconds

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">FDR Analysis Parameters</h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                        {/* Nalpha Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Number of Alpha Values (Nalpha)
                            </label>
                            <input
                                type="range"
                                min="10"
                                max="100"
                                value={parameters.Nalpha}
                                onChange={(e) => handleParameterChange('Nalpha', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>10</span>
                                <span className="font-medium">{parameters.Nalpha}</span>
                                <span>100</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of alpha values to test between 0 and {matrixInfo.alphaMax.toFixed(4)}
                            </p>
                        </div>

                        {/* nsupp Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Expected Signal Features (nsupp)
                            </label>
                            <input
                                type="range"
                                min="1"
                                max={matrixInfo.P}
                                value={parameters.nsupp}
                                onChange={(e) => handleParameterChange('nsupp', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>1</span>
                                <span className="font-medium">{parameters.nsupp}</span>
                                <span>{matrixInfo.P}</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Expected number of true signal features (Ï€â‚€ = {((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}% null)
                            </p>
                        </div>

                        {/* Nperm Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Permutation Tests (Nperm)
                            </label>
                            <input
                                type="range"
                                min="50"
                                max="1000"
                                value={parameters.Nperm}
                                onChange={(e) => handleParameterChange('Nperm', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>50</span>
                                <span className="font-medium">{parameters.Nperm}</span>
                                <span>1000</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of permutation tests per alpha value
                            </p>
                        </div>
                    </div>

                    {/* Analysis Summary */}
                    <div className="bg-gray-50 p-4 rounded-lg mb-4">
                        <h3 className="font-medium mb-2">Analysis Summary</h3>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Total runs:</span>
                                <span className="font-medium ml-2">{parameters.Nalpha * (1 + parameters.Nperm)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Est. time:</span>
                                <span className="font-medium ml-2">{Math.floor(estimatedTime / 60)}:{(estimatedTime % 60).toString().padStart(2, '0')}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Alpha range:</span>
                                <span className="font-medium ml-2">0 â†’ {matrixInfo.alphaMax.toFixed(4)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Ï€â‚€:</span>
                                <span className="font-medium ml-2">{((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>

                    {/* Enhanced Progress Display with System Monitoring */}
                    {isRunning && (
                        <div className="bg-blue-50 p-4 rounded-lg mb-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-medium text-blue-800">
                                    {progress.message}
                                </span>
                                <span className="text-sm text-blue-600">
                                    {progress.current} / {progress.total}
                                </span>
                            </div>
                            <div className="w-full bg-blue-200 rounded-full h-2">
                                <div
                                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${progress.total > 0 ? (progress.current / progress.total) * 100 : 0}%` }}
                                ></div>
                            </div>
                            <div className="flex justify-between items-center mt-2">
                                <div className="text-xs text-blue-600">
                                    {progress.total > 0 ? `${((progress.current / progress.total) * 100).toFixed(1)}% complete` : 'Initializing...'}
                                </div>
                                {(() => {
                                    const stored = loadFDRProgress();
                                    return stored && stored.estimatedTimeRemaining ? (
                                        <div className="text-xs text-blue-600">
                                            ETA: {stored.estimatedTimeRemaining}
                                        </div>
                                    ) : null;
                                })()}
                            </div>

                            {/* System Resource Monitoring */}
                            {(() => {
                                const resources = getSystemResources();
                                return (
                                    <div className="mt-3 pt-3 border-t border-blue-200">
                                        <div className="grid grid-cols-2 gap-4 text-xs">
                                            <div>
                                                <div className="font-medium text-blue-700 mb-1">System Resources</div>
                                                {resources.memory.used && (
                                                    <div className="flex justify-between text-blue-600">
                                                        <span>Memory:</span>
                                                        <span>{resources.memory.used}MB / {resources.memory.limit}MB</span>
                                                    </div>
                                                )}
                                                <div className="flex justify-between text-blue-600">
                                                    <span>CPU Cores:</span>
                                                    <span>{resources.browser.hardwareConcurrency}</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Browser:</span>
                                                    <span>{resources.browser.userAgent}</span>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="font-medium text-blue-700 mb-1">Performance</div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Web Worker:</span>
                                                    <span className="text-green-600">âœ“ Active</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Tab Throttling:</span>
                                                    <span className="text-green-600">âœ“ Protected</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Progress Sync:</span>
                                                    <span className="text-green-600">âœ“ Background</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div className="mt-2 text-xs text-blue-500 text-center">
                                            ðŸ’¡ Analysis continues at full speed even when tab is in background
                                        </div>
                                    </div>
                                );
                            })()}
                        </div>
                    )}

                    {/* Resume Analysis Notification */}
                    {(() => {
                        const savedProgress = loadFDRProgress();
                        return savedProgress && !isRunning ? (
                            <div className="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                <div className="flex items-center space-x-3">
                                    <div className="flex-shrink-0">
                                        <svg className="h-5 w-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                        </svg>
                                    </div>
                                    <div className="flex-1">
                                        <h3 className="text-sm font-medium text-yellow-800">
                                            Interrupted Analysis Detected
                                        </h3>
                                        <div className="mt-1 text-sm text-yellow-700">
                                            <p>Progress: {savedProgress.current}/{savedProgress.total} - {savedProgress.message}</p>
                                            <p className="text-xs mt-1">Saved: {new Date(savedProgress.timestamp).toLocaleString()}</p>
                                        </div>
                                    </div>
                                    <div className="flex space-x-2">
                                        <button
                                            onClick={() => {
                                                // Clear saved progress and continue with new analysis
                                                clearFDRProgress();
                                                window.location.reload(); // Refresh to update UI
                                            }}
                                            className="px-3 py-1 text-xs bg-yellow-200 text-yellow-800 rounded hover:bg-yellow-300 transition-colors"
                                        >
                                            Start Fresh
                                        </button>
                                        <button
                                            onClick={() => {
                                                // For now, just start fresh as resume logic is complex
                                                // In a full implementation, this would restore parameters
                                                alert('Resume functionality: Clear the progress and run with the same parameters as shown above.');
                                                clearFDRProgress();
                                            }}
                                            className="px-3 py-1 text-xs bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors"
                                        >
                                            Resume Analysis
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ) : null;
                    })()}

                    {/* Run/Cancel Analysis Buttons */}
                    <div className="flex justify-end space-x-4">
                        {!isRunning ? (
                            <button
                                onClick={runAnalysis}
                                className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                            >
                                Run FDR Analysis
                            </button>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center space-x-4">
                                    <div className="flex items-center space-x-2 text-indigo-600">
                                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600"></div>
                                        <span>Running Analysis...</span>
                                    </div>
                                    <button
                                        onClick={cancelAnalysis}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>

                                {/* Performance Status Indicator */}
                                <div className="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center space-x-2">
                                            <svg className="h-4 w-4 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                                            </svg>
                                            <span className="text-sm font-medium text-blue-700">Web Worker Performance Mode</span>
                                        </div>
                                        <div className="text-xs text-blue-600">
                                            Tab throttling protected âœ“
                                        </div>
                                    </div>
                                    <div className="mt-2 text-xs text-blue-600">
                                        Analysis continues uninterrupted even if you switch tabs or the computer sleeps.
                                        Keep this tab open for best performance monitoring.
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // FDR Results Display Component
        // Interactive FDR Chart Component
        const FDRChart = ({ data, selectedRowIndex, onRowSelect }) => {
            // Chart dimensions and margins
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Data ranges
            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const fdrRange = [Math.min(...data.fdrValues), Math.max(...data.fdrValues)];
            
            // Fixed view ranges (no zoom)
            const currentAlphaMin = alphaRange[0];
            const currentAlphaMax = alphaRange[1];
            const currentValueMin = 0;
            const currentValueMax = Math.max(100, Math.ceil(fdrRange[1] * 1.1));

            // Scale functions
            const xScale = (alpha) => margin.left + ((alpha - currentAlphaMin) / (currentAlphaMax - currentAlphaMin)) * chartWidth;
            const yScale = (fdr) => margin.top + ((currentValueMax - fdr) / (currentValueMax - currentValueMin)) * chartHeight;

            const handlePointClick = (index) => {
                console.log('ðŸŽ¯ FDR Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                onRowSelect(index);
            };

            // Generate axis ticks
            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(currentAlphaMin, currentAlphaMax);
            const yTicks = generateTicks(currentValueMin, currentValueMax);

            return (
                <div className="relative flex items-center justify-center">
                    
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        {/* Grid and Clipping */}
                        <defs>
                            <pattern id="fdrGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="fdrChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#fdrGrid)"/>
                        
                        {/* Axes */}
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {/* Y-axis ticks and labels */}
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(1)}
                                </text>
                            </g>
                        ))}
                        
                        {/* X-axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#fdrChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.fdrValues[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#EF4444" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.fdrValues[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#EF4444"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Click to select`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        {/* Axis labels */}
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            FDR (%)
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Detections Chart Component  
        const DetectionsChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const detectionRange = [0, Math.max(...data.detectionCounts)];

            const xScale = (alpha) => margin.left + ((alpha - alphaRange[0]) / (alphaRange[1] - alphaRange[0])) * chartWidth;
            const yScale = (detections) => margin.top + ((detectionRange[1] - detections) / (detectionRange[1] - detectionRange[0])) * chartHeight;

            const handlePointClick = (index) => {
                console.log('ðŸ“Š Detections Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                // Always select and run SSVD on click
                onRowSelect(index);
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(alphaRange[0], alphaRange[1]);
            const yTicks = generateTicks(detectionRange[0], detectionRange[1]).map(t => Math.round(t));

            return (
                <div className="relative flex items-center justify-center">
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        <defs>
                            <pattern id="detectGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="detectChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#detectGrid)"/>
                        
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick}
                                </text>
                            </g>
                        ))}
                        
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#detectChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.detectionCounts[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#3B82F6" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.detectionCounts[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#3B82F6"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Click to select`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Number of Detections
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Gradient Chart Component
        const GradientChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const gradientRange = [Math.min(...data.gradients), Math.max(...data.gradients)];
            
            const xScale = (alpha) => margin.left + ((alpha - alphaRange[0]) / (alphaRange[1] - alphaRange[0])) * chartWidth;
            const yScale = (gradient) => margin.top + ((gradientRange[1] - gradient) / (gradientRange[1] - gradientRange[0])) * chartHeight;

            const handlePointClick = (index) => {
                console.log('ðŸ“ˆ Gradient Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                onRowSelect(index);
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(alphaRange[0], alphaRange[1]);
            const yTicks = generateTicks(gradientRange[0], gradientRange[1]);

            return (
                <div className="w-full h-full flex items-center justify-center">
                    <svg width={width} height={height} className="border border-gray-300 bg-white">
                        {/* Grid lines */}
                        {xTicks.map((tick, i) => (
                            <line key={`v-${i}`} x1={xScale(tick)} y1={margin.top} x2={xScale(tick)} y2={height - margin.bottom} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        {yTicks.map((tick, i) => (
                            <line key={`h-${i}`} x1={margin.left} y1={yScale(tick)} x2={width - margin.right} y2={yScale(tick)} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        
                        {/* Zero line */}
                        <line x1={margin.left} y1={yScale(0)} x2={width - margin.right} y2={yScale(0)} stroke="#666" strokeWidth="2" strokeDasharray="5,5"/>
                        
                        {/* Data line */}
                        <path 
                            d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.gradients[i])}`).join(' L ')}`}
                            fill="none" 
                            stroke="#2563eb" 
                            strokeWidth="2"
                        />
                        
                        {/* Data points */}
                        {data.alphaValues.map((alpha, index) => {
                            const isSelected = selectedRowIndex === index;
                            return (
                                <circle
                                    key={index}
                                    cx={xScale(alpha)}
                                    cy={yScale(data.gradients[index])}
                                    r={isSelected ? "6" : "4"}
                                    fill={isSelected ? "#FFA500" : "#2563eb"}
                                    stroke={isSelected ? "#FF8C00" : "#1d4ed8"}
                                    strokeWidth="2"
                                    className="cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Gradient: ${data.gradients[index].toFixed(1)}
Click to select`}
                                    </title>
                                </circle>
                            );
                        })}
                        
                        {/* Axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(0)}
                                </text>
                            </g>
                        ))}
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Detection Gradient
                        </text>
                    </svg>
                </div>
            );
        };

        const FDRResultsDisplay = ({ results, onAlphaSelected, selectedAlpha, onRunSingleAlpha }) => {
            const [selectedIndex, setSelectedIndex] = useState(null);
            const tableRef = useRef(null);
            const rowRefs = useRef([]);

            const handleRowClick = (index) => {
                console.log('ðŸŽ¯ handleRowClick called with index:', index);
                console.log('Alpha value:', results.alphaValues[index]);
                console.log('onRunSingleAlpha exists?', !!onRunSingleAlpha);
                
                setSelectedIndex(index);
                onAlphaSelected(results.alphaValues[index]);
                
                // Run SSVD algorithm for selected alpha
                if (onRunSingleAlpha) {
                    console.log('âœ… Calling onRunSingleAlpha with alpha:', results.alphaValues[index]);
                    onRunSingleAlpha(results.alphaValues[index]);
                } else {
                    console.log('âŒ onRunSingleAlpha is not defined!');
                }
                
                // Scroll to selected row if needed
                if (rowRefs.current[index]) {
                    rowRefs.current[index].scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            };

            // Find optimal alpha (minimum eFDR with reasonable detections)
            const optimalIndex = results.fdrValues.reduce((minIndex, fdr, index) => {
                if (results.detectionCounts[index] > 0 && fdr < results.fdrValues[minIndex]) {
                    return index;
                }
                return minIndex;
            }, 0);

            const formatNumber = (num, decimals = 2) => {
                if (typeof num !== 'number' || isNaN(num)) return 'N/A';
                return num.toFixed(decimals);
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-semibold">FDR Analysis Results</h2>
                        <div className="text-sm text-gray-500">
                            Click a row to select alpha value
                        </div>
                    </div>

                    {/* Summary Statistics */}
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div className="bg-blue-50 p-3 rounded-lg">
                            <div className="text-sm text-blue-600 font-medium">Alpha Values</div>
                            <div className="text-lg font-bold text-blue-900">{results.alphaValues.length}</div>
                        </div>
                        <div className="bg-purple-50 p-3 rounded-lg">
                            <div className="text-sm text-purple-600 font-medium">Max Detections</div>
                            <div className="text-lg font-bold text-purple-900">{Math.max(...results.detectionCounts)}</div>
                        </div>
                        <div className="bg-orange-50 p-3 rounded-lg">
                            <div className="text-sm text-orange-600 font-medium">Optimal Alpha</div>
                            <div className="text-lg font-bold text-orange-900">{results.alphaValues[optimalIndex].toFixed(4)}</div>
                        </div>
                    </div>

                    {/* Results Table */}
                    <div className="overflow-x-auto" ref={tableRef}>
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Index
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Alpha
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        eFDR (%)
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Detections
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Gradient
                                    </th>
                                </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                                {results.alphaValues.map((alpha, index) => {
                                    const isSelected = selectedIndex === index;
                                    const isOptimal = index === optimalIndex;
                                    
                                    return (
                                        <tr 
                                            key={index}
                                            ref={el => rowRefs.current[index] = el}
                                            className={`cursor-pointer transition-all duration-200 ${
                                                isSelected 
                                                    ? 'bg-indigo-100 hover:bg-indigo-200 shadow-md border-l-4 border-indigo-500' 
                                                    : isOptimal 
                                                        ? 'bg-yellow-50 hover:bg-yellow-100' 
                                                        : 'hover:bg-gray-50'
                                            }`}
                                            onClick={() => handleRowClick(index)}
                                        >
                                            <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {index + 1}
                                                {isOptimal && <span className="ml-1 text-xs text-yellow-600">â˜…</span>}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900 font-mono">
                                                {alpha.toFixed(4)}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`inline-flex px-2 py-1 rounded-full text-xs font-medium ${
                                                    results.fdrValues[index] <= 5 ? 'bg-green-100 text-green-800' :
                                                    results.fdrValues[index] <= 10 ? 'bg-yellow-100 text-yellow-800' :
                                                    'bg-red-100 text-red-800'
                                                }`}>
                                                    {formatNumber(results.fdrValues[index], 1)}%
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                {results.detectionCounts[index]}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`${
                                                    results.gradients[index] > 0 ? 'text-green-600' : 
                                                    results.gradients[index] < 0 ? 'text-red-600' : 'text-gray-500'
                                                }`}>
                                                    {formatNumber(results.gradients[index], 0)}
                                                </span>
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>

                    {/* Selection Status */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 p-4 bg-indigo-50 rounded-lg">
                            <h3 className="font-medium text-indigo-800 mb-2">Selected Alpha for SSVD-R1 Analysis</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                <div>
                                    <span className="text-indigo-600">Alpha:</span>
                                    <span className="font-medium ml-2">{selectedAlpha.toFixed(4)}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">eFDR:</span>
                                    <span className="font-medium ml-2">{formatNumber(results.fdrValues[selectedIndex], 1)}%</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Expected Detections:</span>
                                    <span className="font-medium ml-2">{results.detectionCounts[selectedIndex]}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Index:</span>
                                    <span className="font-medium ml-2">{selectedIndex + 1} / {results.alphaValues.length}</span>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Interactive Analysis Plots */}
                    <div className="mt-6 space-y-6">
                        {/* eFDR vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <FDRChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detections vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <DetectionsChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detection Gradient vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <GradientChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>
                    </div>

                    {/* Next Steps */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 bg-green-50 p-4 rounded-lg">
                            <h3 className="font-medium text-green-800 mb-2">Next: Run SSVD-R1 Algorithm</h3>
                            <p className="text-sm text-green-700">
                                Ready to run SSVD-R1 algorithm with selected alpha = {selectedAlpha.toFixed(4)}. 
                                This will perform sparse SVD decomposition and generate visualization results.
                            </p>
                        </div>
                    )}
                </div>
            );
        };

        // Reusable Histogram Component (Line Plot)
        const HistogramChart = React.memo(({ data, title, xLabel, yLabel, bins = 64 }) => {
            const createHistogramData = (values, numBins) => {
                if (!values.length) return { labels: [], data: [] };
                
                const min = Math.min(...values);
                const max = Math.max(...values);
                const binWidth = (max - min) / numBins;
                
                const binLabels = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin labels
                for (let i = 0; i < numBins; i++) {
                    const binStart = min + i * binWidth;
                    const binEnd = min + (i + 1) * binWidth;
                    binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                }
                
                // Count values in each bin
                values.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binLabels, data: binCounts };
            };

            const histogramData = createHistogramData(data, bins);
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: title,
                    data: histogramData.data,
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                    pointBorderColor: 'rgba(59, 130, 246, 1)',
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false
                }]
            };

            const options = {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: title,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    x: {
                        title: { display: true, text: xLabel },
                        ticks: { maxRotation: 45 }
                    },
                    y: {
                        title: { display: true, text: yLabel },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm">
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        }, (prevProps, nextProps) => {
            // Custom comparison for memo - only re-render if data actually changed
            return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data) &&
                   prevProps.title === nextProps.title &&
                   prevProps.xLabel === nextProps.xLabel &&
                   prevProps.yLabel === nextProps.yLabel &&
                   prevProps.bins === nextProps.bins;
        });

        // Matrix Values Histogram Component (Line Plot with Circle Markers)
        const MatrixHistogram = React.memo(({ matrixData, title, color = 'rgba(59, 130, 246, 1)', bins = 64 }) => {
            const createMatrixHistogram = (matrix, numBins) => {
                if (!matrix || !matrix.length) return { labels: [], data: [] };
                
                // Memory-efficient approach for large matrices
                const P = matrix.length;
                const N = matrix[0].length;
                const totalElements = P * N;
                
                // Use sampling for large matrices to avoid memory issues
                const sampleSize = Math.min(10000, totalElements);
                let samples = [];
                let min = Infinity, max = -Infinity;
                
                if (totalElements <= 10000) {
                    // Small matrix: use all values
                    for (let i = 0; i < P; i++) {
                        for (let j = 0; j < N; j++) {
                            const val = matrix[i][j];
                            samples.push(val);
                            if (val < min) min = val;
                            if (val > max) max = val;
                        }
                    }
                } else {
                    // Large matrix: random sampling
                    for (let s = 0; s < sampleSize; s++) {
                        const i = Math.floor(Math.random() * P);
                        const j = Math.floor(Math.random() * N);
                        const val = matrix[i][j];
                        samples.push(val);
                        if (val < min) min = val;
                        if (val > max) max = val;
                    }
                }
                
                if (!samples.length) return { labels: [], data: [] };
                const binWidth = (max - min) / numBins;
                
                const binCenters = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin center labels for better line plot visualization
                for (let i = 0; i < numBins; i++) {
                    const binCenter = min + (i + 0.5) * binWidth;
                    binCenters.push(binCenter.toFixed(4));
                }
                
                // Count values in each bin
                samples.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binCenters, data: binCounts };
            };

            const histogramData = createMatrixHistogram(matrixData, bins);
            const totalValues = matrixData ? matrixData.length * matrixData[0].length : 0;
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: `${title} (${totalValues.toLocaleString()} values)`,
                    data: histogramData.data,
                    borderColor: color,
                    backgroundColor: color.replace('1)', '0.2)'),
                    pointBackgroundColor: color,
                    pointBorderColor: color,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                }]
            };

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: `${title} Distribution (${bins} bins)`,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: true },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const binValue = parseFloat(context.label);
                                const count = context.parsed.y;
                                const percentage = ((count / totalValues) * 100).toFixed(2);
                                return [
                                    `Bin center: ${binValue.toFixed(4)}`,
                                    `Count: ${count.toLocaleString()}`,
                                    `Percentage: ${percentage}%`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Matrix Value' },
                        ticks: {
                            maxTicksLimit: 8,
                            callback: function(value, index) {
                                return parseFloat(this.getLabelForValue(value)).toFixed(3);
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Frequency' },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm" style={{ height: '400px' }}>
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        });

        // Signal/Noise Analysis Component with Interactive Charts
        const SignalNoiseAnalysis = ({ eigenvalues }) => {
            const [selectedBoundary, setSelectedBoundary] = useState(null);
            const [spectralSNR, setSpectralSNR] = useState(null);
            const chartRefs = useRef({ eigenvalue: null, gradient: null, ratio: null });
            
            // Guard against non-array eigenvalues
            if (!Array.isArray(eigenvalues) || eigenvalues.length === 0) {
                return (
                    <div className="bg-white p-4 rounded-lg shadow-sm border-2 border-dashed border-yellow-300">
                        <div className="text-center text-gray-600 py-8">
                            <div className="text-4xl mb-4">âš ï¸</div>
                            <h3 className="font-medium text-lg mb-2 text-yellow-800">Eigenvalue Analysis Unavailable</h3>
                            <p className="text-sm mb-4">
                                No eigenvalue data available for analysis.
                            </p>
                        </div>
                    </div>
                );
            }

            // Filter and prepare eigenvalues
            const positiveEigenvalues = eigenvalues.filter(val => val > 1e-8);
            
            // Calculate gradients and ratios
            const gradients = [];
            const ratios = [];
            for (let i = 0; i < positiveEigenvalues.length - 1; i++) {
                gradients.push(positiveEigenvalues[i] - positiveEigenvalues[i + 1]);
                ratios.push(positiveEigenvalues[i] / positiveEigenvalues[i + 1]);
            }
            
            // Calculate spectral SNR when boundary is selected
            const calculateSpectralSNR = (boundaryIndex) => {
                if (boundaryIndex === null || boundaryIndex === 0 || boundaryIndex >= positiveEigenvalues.length) {
                    return null;
                }
                const signalEvals = positiveEigenvalues.slice(0, boundaryIndex);
                const noiseEvals = positiveEigenvalues.slice(boundaryIndex);
                const signalSum = signalEvals.reduce((a, b) => a + b, 0);
                const noiseSum = noiseEvals.reduce((a, b) => a + b, 0);
                
                if (noiseSum === 0) return Infinity;
                return 10 * Math.log10(signalSum / noiseSum);
            };

            // Update charts when boundary changes
            useEffect(() => {
                const charts = [];
                
                // Eigenvalue Chart
                if (chartRefs.current.eigenvalue) {
                    const ctx = chartRefs.current.eigenvalue.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: positiveEigenvalues.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Eigenvalue',
                            data: positiveEigenvalues,
                            borderColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            backgroundColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 0.2)' : 'rgba(59, 130, 246, 0.2)'
                            ),
                            pointBackgroundColor: positiveEigenvalues.map((_, i) => 
                                i === selectedBoundary ? 'rgba(239, 68, 68, 1)' : 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            pointRadius: positiveEigenvalues.map((_, i) => i === selectedBoundary ? 6 : 3),
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Spectrum (Click to set boundary)',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Index: ${context.dataIndex + 1}, Eigenvalue: ${context.parsed.y.toFixed(4)}`;
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary,
                                        xMax: selectedBoundary,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Eigenvalue Index' }
                            },
                            y: {
                                title: { display: true, text: 'Eigenvalue Magnitude' },
                                type: 'linear',
                                min: 0
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                setSelectedBoundary(index);
                                const snr = calculateSpectralSNR(index);
                                setSpectralSNR(snr);
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Gradient Chart
                if (chartRefs.current.gradient && gradients.length > 0) {
                    const ctx = chartRefs.current.gradient.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: gradients.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Gradient',
                            data: gradients,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.2)',
                            pointBackgroundColor: gradients.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(34, 197, 94, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Gradient',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const gradient = context.parsed.y;
                                        const eigenval1 = positiveEigenvalues[idx];
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Gradient: ${gradient.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Drop: ${((gradient / eigenval1) * 100).toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Gradient Value' },
                                type: 'linear',
                                min: 0
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Ratio Chart
                if (chartRefs.current.ratio && ratios.length > 0) {
                    const ctx = chartRefs.current.ratio.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: ratios.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Ratio',
                            data: ratios,
                            borderColor: 'rgba(168, 85, 247, 1)',
                            backgroundColor: 'rgba(168, 85, 247, 0.2)',
                            pointBackgroundColor: ratios.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(168, 85, 247, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Ratio',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const ratio = context.parsed.y;
                                        const percentChange = ((1 - (1/ratio)) * 100);
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Ratio: ${ratio.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Change: -${percentChange.toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Ratio Value' },
                                type: 'linear',
                                min: 1
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Cleanup function to destroy charts when component unmounts or updates
                return () => {
                    charts.forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [selectedBoundary, positiveEigenvalues.length]); // Simplified dependencies

            return (
                <div className="bg-white p-6 rounded-lg shadow-sm">
                    <h3 className="text-lg font-semibold mb-4">Signal/Noise Subspace Analysis</h3>
                    
                    {/* Charts Stack - Vertical Layout with Increased Size */}
                    <div className="space-y-6 mb-6">
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.eigenvalue = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.gradient = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.ratio = el} style={{height: '300px'}} />
                        </div>
                    </div>
                    
                    {/* SNR Results */}
                    {selectedBoundary !== null && (
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Selected Boundary</p>
                                    <p className="text-lg font-bold text-blue-700">Index {selectedBoundary + 1}</p>
                                    <p className="text-xs text-blue-600">First noise eigenvalue</p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Signal Subspace</p>
                                    <p className="text-lg font-bold text-blue-700">Eigenvalues 1-{selectedBoundary}</p>
                                    <p className="text-xs text-blue-600">
                                        Sum: {positiveEigenvalues.slice(0, selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Spectral SNR</p>
                                    <p className="text-lg font-bold text-blue-700">
                                        {spectralSNR !== null ? 
                                            (isFinite(spectralSNR) ? `${spectralSNR.toFixed(2)} dB` : 'âˆž dB') : 
                                            'N/A'}
                                    </p>
                                    <p className="text-xs text-blue-600">
                                        Noise sum: {positiveEigenvalues.slice(selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Instructions */}
                    {selectedBoundary === null && (
                        <div className="text-center text-gray-500 text-sm mt-4">
                            <p>Click on any point in the eigenvalue plot to set the signal/noise boundary</p>
                            <p>Hover over points to see detailed values</p>
                        </div>
                    )}
                </div>
            );
        };

        // Keep backward compatibility - alias the old component name
        const EigenvalueSpectrumChart = SignalNoiseAnalysis;

        // Analysis Parameters Display Component
        const AnalysisParametersDisplay = ({ parameters, title = "Analysis Configuration" }) => {
            if (!parameters) return null;
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4">{title}</h2>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                        {parameters.analysisType && (
                            <div>
                                <span className="text-gray-500">Analysis Type:</span>
                                <div className="font-medium text-gray-900 capitalize">
                                    {parameters.analysisType === 'efdr' ? 'eFDR Analysis' : 
                                     parameters.analysisType === 'alpha' ? 'N-Alpha Analysis' : 
                                     'Single Alpha'}
                                </div>
                            </div>
                        )}
                        {parameters.alpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.alpha0 !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Min:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha0.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.alphaMax !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Max:</span>
                                <div className="font-medium text-gray-900">{parameters.alphaMax.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.Nalpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Count:</span>
                                <div className="font-medium text-gray-900">{parameters.Nalpha}</div>
                            </div>
                        )}
                        {parameters.Nperm !== undefined && (
                            <div>
                                <span className="text-gray-500">Permutations:</span>
                                <div className="font-medium text-gray-900">{parameters.Nperm}</div>
                            </div>
                        )}
                        {parameters.nsupp !== undefined && (
                            <div>
                                <span className="text-gray-500">Support Size:</span>
                                <div className="font-medium text-gray-900">{parameters.nsupp}</div>
                            </div>
                        )}
                        {parameters.matrixSize && (
                            <div>
                                <span className="text-gray-500">Matrix Size:</span>
                                <div className="font-medium text-gray-900">{parameters.matrixSize}</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Alpha Sequence Results Display Component
        const AlphaSequenceResultsDisplay = ({ results, selectedIndex, onSelectAlpha, onNewAnalysis, onResetToOriginal, onRunSingleAlpha }) => {
            const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
            
            // Debug logging
            console.log('AlphaSequenceResultsDisplay rendering with results:', results);
            console.log('Has FDR?', results.hasFDR);
            console.log('First result eFDR:', results.results?.[0]?.eFDR);
            
            // Calculate detection gradients
            const resultsWithGradients = useMemo(() => {
                if (!results.results) {
                    console.error('No results.results array found!');
                    return [];
                }
                const data = results.results.map((r, i) => {
                    let gradient = 0;
                    if (i > 0) {
                        gradient = r.detections - results.results[i-1].detections;
                    }
                    return { ...r, gradient, index: i };
                });
                return data;
            }, [results]);
            
            // Sort function
            const sortedResults = useMemo(() => {
                if (!sortConfig.key) return resultsWithGradients;
                
                return [...resultsWithGradients].sort((a, b) => {
                    let aValue = a[sortConfig.key];
                    let bValue = b[sortConfig.key];
                    
                    if (aValue < bValue) {
                        return sortConfig.direction === 'asc' ? -1 : 1;
                    }
                    if (aValue > bValue) {
                        return sortConfig.direction === 'asc' ? 1 : -1;
                    }
                    return 0;
                });
            }, [resultsWithGradients, sortConfig]);
            
            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
                }));
            };
            
            // Export functionality for multi-alpha results
            const [showMultiExportMenu, setShowMultiExportMenu] = useState(false);
            
            const handleExportMultiAlphaResults = () => {
                try {
                    console.log('ðŸ”„ Starting multi-alpha export...');
                    console.log('Results data:', results);
                    console.log('Results with gradients:', resultsWithGradients);
                    
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const headers = results.hasFDR 
                        ? ['Alpha', 'Detections', 'eFDR_Percent', 'Sparsity_Percent', 'Detection_Gradient']
                        : ['Alpha', 'Detections', 'Sparsity_Percent', 'Detection_Gradient'];
                    
                    const rows = resultsWithGradients.map(r => {
                        console.log('Processing result row:', r);
                        console.log('Row properties:', {
                            alpha: r.alpha,
                            detections: r.detections,
                            eFDR: r.eFDR,
                            sparsity: r.sparsity,
                            gradient: r.gradient
                        });
                        
                        if (results.hasFDR) {
                            return [
                                (r.alpha ?? 0).toFixed(6),
                                r.detections ?? 0,
                                (r.eFDR ?? 0).toFixed(2),
                                (r.sparsity ?? 0).toFixed(2),
                                r.gradient ?? 0
                            ];
                        } else {
                            return [
                                (r.alpha ?? 0).toFixed(6),
                                r.detections ?? 0,
                                (r.sparsity ?? 0).toFixed(2),
                                r.gradient ?? 0
                            ];
                        }
                    });
                    
                    console.log('CSV headers:', headers);
                    console.log('CSV rows sample:', rows.slice(0, 3));
                    
                    const csvContent = Papa.unparse({ fields: headers, data: rows });
                    const filename = `SSVD1x_MultiAlpha_${results.hasFDR ? 'eFDR_' : ''}Results_${timestamp}.csv`;
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    saveAs(blob, filename);
                    console.log('âœ… Multi-alpha results exported:', filename);
                    setShowMultiExportMenu(false);
                } catch (error) {
                    console.error('âŒ Error exporting multi-alpha results:', error);
                    alert('Error exporting multi-alpha results: ' + error.message);
                }
            };

            const handleExportSelectedAlpha = () => {
                try {
                    console.log('ðŸ”„ Starting selected alpha export...');
                    console.log('Selected index:', selectedIndex);
                    console.log('Results with gradients length:', resultsWithGradients.length);
                    
                    if (selectedIndex === null || selectedIndex === undefined || !resultsWithGradients[selectedIndex]) {
                        alert('Please select an alpha value from the table first.');
                        return;
                    }
                    
                    const selectedResult = resultsWithGradients[selectedIndex];
                    console.log('Selected result:', selectedResult);
                    
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    
                    const metadata = [
                        ['Parameter', 'Value'],
                        ['Export_Date', new Date().toISOString()],
                        ['Selected_Alpha', (selectedResult.alpha ?? 0).toFixed(6)],
                        ['Detections', selectedResult.detections ?? 0],
                        ['Sparsity_Percent', (selectedResult.sparsity ?? 0).toFixed(2)],
                        ['Detection_Gradient', selectedResult.gradient ?? 0],
                        ...(results.hasFDR ? [['eFDR_Percent', (selectedResult.eFDR ?? 0).toFixed(2)]] : [])
                    ];
                    
                    console.log('Metadata:', metadata);
                    
                    const csvContent = Papa.unparse(metadata);
                    const filename = `SSVD1x_Selected_Alpha_${selectedResult.alpha.toFixed(4)}_${timestamp}.csv`;
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    saveAs(blob, filename);
                    console.log('âœ… Selected alpha exported:', filename);
                    setShowMultiExportMenu(false);
                } catch (error) {
                    console.error('âŒ Error exporting selected alpha:', error);
                    alert('Error exporting selected alpha: ' + error.message);
                }
            };
            
            return (
                <div className="space-y-6">
                    {/* Analysis Parameters */}
                    <AnalysisParametersDisplay 
                        parameters={results.parameters}
                        title={results.analysisType === 'efdr' ? "eFDR Configuration" : "N-Alpha Configuration"}
                    />
                    
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <div>
                                <h2 className="text-2xl font-semibold text-gray-800">
                                    {results.analysisType === 'efdr' ? 'eFDR Table' : 'N-Alpha Table'}
                                </h2>
                                <p className="text-sm text-gray-600 mt-1">
                                    Analyzed {results.alphaValues.length} alpha values from {results.alphaValues[0].toFixed(4)} to {results.alphaValues[results.alphaValues.length - 1].toFixed(4)}
                                </p>
                            </div>
                            <div className="flex space-x-3">
                                <div className="relative">
                                    <button
                                        onClick={() => setShowMultiExportMenu(!showMultiExportMenu)}
                                        className="px-4 py-2 bg-gradient-to-r from-green-600 to-blue-600 text-white rounded-md hover:from-green-700 hover:to-blue-700 transition-colors flex items-center gap-2"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                        </svg>
                                        Export
                                        <svg className={`w-4 h-4 transition-transform ${showMultiExportMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </button>
                                    
                                    {showMultiExportMenu && (
                                        <div className="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-200 z-50">
                                            <div className="p-3 border-b border-gray-200">
                                                <h3 className="text-sm font-semibold text-gray-800">Export Multi-Alpha Results</h3>
                                                <p className="text-xs text-gray-600">{results.alphaValues.length} alpha values</p>
                                            </div>
                                            <div className="p-2 space-y-1">
                                                <button
                                                    onClick={handleExportMultiAlphaResults}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded-md flex items-center gap-2"
                                                >
                                                    <span className="text-blue-600">ðŸ“Š</span>
                                                    All Alpha Results (CSV)
                                                </button>
                                                <button
                                                    onClick={handleExportSelectedAlpha}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-green-50 rounded-md flex items-center gap-2"
                                                    disabled={selectedIndex === null}
                                                >
                                                    <span className="text-green-600">ðŸŽ¯</span>
                                                    Selected Alpha Only (CSV)
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        exportChartsAsImages();
                                                        setShowMultiExportMenu(false);
                                                    }}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-purple-50 rounded-md flex items-center gap-2"
                                                >
                                                    <span className="text-purple-600">ðŸ“ˆ</span>
                                                    Charts (PNG)
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                                <button
                                    onClick={onNewAnalysis}
                                    className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    New Analysis
                                </button>
                                <button
                                    onClick={onResetToOriginal}
                                    className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
                                >
                                    Reset Data
                                </button>
                            </div>
                        </div>
                        
                        {/* Summary Statistics */}
                        {results.hasFDR && (
                            <div className="grid grid-cols-5 gap-4 mb-6">
                                <div className="bg-green-50 p-4 rounded-lg">
                                    <div className="text-sm text-green-600 font-medium">Max Detections</div>
                                    <div className="text-2xl font-bold text-green-900">
                                        {Math.max(...results.results.map(r => r.detections))}
                                    </div>
                                    <div className="text-xs text-green-600 mt-1">
                                        Across all alpha values
                                    </div>
                                </div>
                                <div className="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                                    <div className="text-sm text-yellow-700 font-medium">Min Detections</div>
                                    <div className="text-2xl font-bold text-yellow-900">
                                        {Math.min(...results.results.map(r => r.detections))}
                                    </div>
                                    <div className="text-xs text-yellow-600 mt-1">
                                        Across all alpha values
                                    </div>
                                </div>
                                <div className="bg-orange-50 p-4 rounded-lg">
                                    <div className="text-sm text-orange-600 font-medium">Permutations</div>
                                    <div className="text-2xl font-bold text-orange-900">
                                        {results.Nperm || 'N/A'}
                                    </div>
                                    <div className="text-xs text-orange-600 mt-1">
                                        Per alpha value
                                    </div>
                                </div>
                                <div className="bg-purple-50 p-4 rounded-lg">
                                    <div className="text-sm text-purple-600 font-medium">Total Runs</div>
                                    <div className="text-2xl font-bold text-purple-900">
                                        {results.fdrResults?.totalRuns || results.results.length}
                                    </div>
                                    <div className="text-xs text-purple-600 mt-1">
                                        {results.Nalpha} Ã— {(results.Nperm || 0) + 1} iterations
                                    </div>
                                </div>
                                <div className="bg-indigo-50 p-4 rounded-lg">
                                    <div className="text-sm text-indigo-600 font-medium">Total Runtime</div>
                                    <div className="text-2xl font-bold text-indigo-900">
                                        {results.elapsedTime || 'N/A'}
                                    </div>
                                    <div className="text-xs text-indigo-600 mt-1">
                                        Analysis duration
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Results Table */}
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-200">
                                <thead className="bg-gray-50">
                                    <tr>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('index')}
                                        >
                                            Index {sortConfig.key === 'index' && (sortConfig.direction === 'asc' ? 'â†‘' : 'â†“')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('alpha')}
                                        >
                                            Alpha {sortConfig.key === 'alpha' && (sortConfig.direction === 'asc' ? 'â†‘' : 'â†“')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('detections')}
                                        >
                                            Detections {sortConfig.key === 'detections' && (sortConfig.direction === 'asc' ? 'â†‘' : 'â†“')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('gradient')}
                                        >
                                            Detection Gradient {sortConfig.key === 'gradient' && (sortConfig.direction === 'asc' ? 'â†‘' : 'â†“')}
                                        </th>
                                        {results.hasFDR && (
                                            <th 
                                                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                                onClick={() => handleSort('eFDR')}
                                            >
                                                eFDR (%) {sortConfig.key === 'eFDR' && (sortConfig.direction === 'asc' ? 'â†‘' : 'â†“')}
                                            </th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody className="bg-white divide-y divide-gray-200">
                                    {sortedResults.map((result) => (
                                        <tr 
                                            key={result.index}
                                            className={`hover:bg-gray-50 cursor-pointer ${selectedIndex === result.index ? 'bg-blue-50 border-l-4 border-blue-500' : ''}`}
                                            onClick={() => {
                                                console.log('Row clicked, index:', result.index, 'alpha:', result.alpha);
                                                onSelectAlpha(result.index);

                                                // Automatically trigger single alpha analysis like SSVD1 app
                                                if (onRunSingleAlpha) {
                                                    console.log('Auto-triggering single alpha analysis for Î± =', result.alpha);
                                                    onRunSingleAlpha(result.alpha);
                                                }
                                            }}
                                        >
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {result.index + 1}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.alpha.toFixed(6)}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.detections}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <span className={`inline-flex items-center ${
                                                    result.gradient > 0 ? 'text-green-600' : 
                                                    result.gradient < 0 ? 'text-red-600' : 
                                                    'text-gray-600'
                                                }`}>
                                                    {result.gradient > 0 && '+'}{result.gradient}
                                                    {result.gradient > 0 && ' â†‘'}
                                                    {result.gradient < 0 && ' â†“'}
                                                </span>
                                            </td>
                                            {results.hasFDR && (
                                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                    <span className={`font-medium ${
                                                        result.eFDR < 5 ? 'text-green-600' :
                                                        result.eFDR < 10 ? 'text-yellow-600' :
                                                        'text-red-600'
                                                    }`}>
                                                        {typeof result.eFDR === 'number' ? result.eFDR.toFixed(2) : 'N/A'}
                                                    </span>
                                                </td>
                                            )}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>

                        {/* Interactive Analysis Plots for Alpha Sequence Results */}
                        {results && results.results && results.results.length > 0 && (
                            <div className="mt-6 space-y-6">
                                {/* eFDR vs Alpha Plot */}
                                {results.hasFDR && (
                                    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                        <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                                        <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                            <FDRChart
                                                data={{
                                                    alphaValues: results.results.map(r => r.alpha),
                                                    fdrValues: results.results.map(r => r.eFDR || 0),
                                                    detectionCounts: results.results.map(r => r.detections),
                                                    gradients: results.results.map(r => r.gradient || 0),
                                                    hasFDR: results.hasFDR
                                                }} 
                                                selectedRowIndex={selectedIndex} 
                                                onRowSelect={(index) => {
                                                    onSelectAlpha(index);
                                                    if (onRunSingleAlpha && results.results[index]) {
                                                        onRunSingleAlpha(results.results[index].alpha);
                                                    }
                                                }} 
                                            />
                                        </div>
                                    </div>
                                )}

                                {/* Detections vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <DetectionsChart
                                            data={{
                                                alphaValues: results.results.map(r => r.alpha),
                                                fdrValues: results.results.map(r => r.eFDR || 0),
                                                detectionCounts: results.results.map(r => r.detections),
                                                gradients: results.results.map(r => r.gradient || 0),
                                                hasFDR: results.hasFDR
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>

                                {/* Detection Gradient vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <GradientChart
                                            data={{
                                                alphaValues: results.results.map(r => r.alpha),
                                                fdrValues: results.results.map(r => r.eFDR || 0),
                                                detectionCounts: results.results.map(r => r.detections),
                                                gradients: results.results.map(r => r.gradient || 0),
                                                hasFDR: results.hasFDR
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>
                                
                                {/* Selected Alpha Details - moved here after charts */}
                                {selectedIndex !== null && resultsWithGradients[selectedIndex] && (
                                    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                        <h3 className="font-medium text-gray-700 mb-2">Selected Alpha Details</h3>
                                        <div className="grid grid-cols-4 gap-4 text-sm">
                                            <div>
                                                <span className="text-gray-600">Index:</span>
                                                <span className="ml-2 font-medium">{selectedIndex + 1}</span>
                                            </div>
                                            <div>
                                                <span className="text-gray-600">Alpha:</span>
                                                <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].alpha.toFixed(6)}</span>
                                            </div>
                                            <div>
                                                <span className="text-gray-600">Detections:</span>
                                                <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].detections}</span>
                                            </div>
                                            {results.hasFDR && (
                                                <div>
                                                    <span className="text-gray-600">eFDR:</span>
                                                    <span className="ml-2 font-medium">{typeof resultsWithGradients[selectedIndex].eFDR === 'number' ? resultsWithGradients[selectedIndex].eFDR.toFixed(2) + '%' : 'N/A'}</span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Analysis Selection Steps Component
        const AnalysisSelectionSteps = ({ analysisStep, onStepSelect, onBackToReview }) => {
            if (!analysisStep) {
                // Step 1: Single vs Multi Alpha
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Analysis Type</h2>
                            <button
                                onClick={onBackToReview}
                                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                            >
                                â† Back to Data Review
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('single')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Single Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Run SSVD with one specific alpha value to get detailed results and visualizations
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('multi')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Multi-Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Test multiple alpha values systematically to find optimal sparsity parameters
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            if (analysisStep === 'multi') {
                // Step 2: Alpha Analysis vs eFDR Analysis
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Multi-Alpha Analysis Type</h2>
                            <button
                                onClick={() => onStepSelect(null)}
                                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                            >
                                â† Back to Analysis Type
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('alpha')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Without Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(Alpha Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Test alpha sequence without permutations - faster analysis for alpha path exploration
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('efdr')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-yellow-500 hover:bg-yellow-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">With Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(eFDR Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Include permutation testing for empirical False Discovery Rate analysis
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            return null; // This will be replaced by parameter collection UIs
        };

        // Matrix Data Review Component
        const MatrixDataReview = ({ matrix, matrixInfo, statistics, onProceedToAnalysis, onReset }) => {
            return (
                <div className="space-y-6">
                    {/* Basic Matrix Overview */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-2xl font-bold mb-4">Matrix Overview</h2>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                <div className="text-2xl font-bold text-blue-900">{statistics.P} Ã— {statistics.N}</div>
                                <div className="text-xs text-blue-600 mt-1">Features Ã— Samples</div>
                            </div>
                            <div className="bg-green-50 p-4 rounded-lg">
                                <div className="text-sm text-green-600 font-medium">Range</div>
                                <div className="text-lg font-bold text-green-900">[{statistics.min.toFixed(2)}, {statistics.max.toFixed(2)}]</div>
                                <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg">
                                <div className="text-sm text-purple-600 font-medium">Overall Mean</div>
                                <div className="text-lg font-bold text-purple-900">{statistics.mean.toFixed(3)}</div>
                                <div className="text-xs text-purple-600 mt-1">All elements</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg">
                                <div className="text-sm text-orange-600 font-medium">Overall Std Dev</div>
                                <div className="text-lg font-bold text-orange-900">{statistics.stdDev.toFixed(3)}</div>
                                <div className="text-xs text-orange-600 mt-1">All elements</div>
                            </div>
                        </div>
                    </div>

                    {/* Row Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Row Statistics (across samples)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.rowMeans} 
                                title="Row Means Distribution"
                                xLabel="Mean Value"
                                yLabel="Frequency"
                                bins={15}
                            />
                            <HistogramChart 
                                data={statistics.rowStdDevs}
                                title="Row Std Devs Distribution" 
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={15}
                            />
                        </div>
                    </div>

                    {/* Column Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Column Statistics (across features)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.columnMeans}
                                title="Column Means Distribution"
                                xLabel="Mean Value" 
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                            <HistogramChart 
                                data={statistics.columnStdDevs}
                                title="Column Std Devs Distribution"
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                        </div>
                    </div>

                    {/* Matrix Values Histogram */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Matrix Values Distribution</h2>
                        <MatrixHistogram 
                            matrixData={matrix}
                            title="Original Matrix Values"
                            color="rgba(59, 130, 246, 1)"
                            bins={64}
                        />
                    </div>


                    {/* Action Buttons */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <p className="text-gray-600 mb-4">
                            Review the statistics and histograms of the uploaded data matrix to verify that it has been properly preprocessed. When ready, click on "Proceed to Analysis" to select analysis type.
                        </p>
                        <div className="flex justify-between items-center">
                            <button
                                className="px-6 py-3 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                onClick={() => onReset()}
                                title="Reset and upload a new matrix"
                            >
                                Reset
                            </button>
                            <button
                                className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                                onClick={() => onProceedToAnalysis()}
                            >
                                Proceed to Analysis
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Data Preprocessing Section Component
        const DataPreprocessingSection = ({ 
            originalMatrix, 
            originalStatistics, 
            onPreprocessingComplete,
            onSkipPreprocessing,
            onProceedToAnalysis
        }) => {
            const [isProcessing, setIsProcessing] = useState(false);
            const [preprocessingResults, setPreprocessingResults] = useState(null);
            const [showPreprocessedStats, setShowPreprocessedStats] = useState(false);

            const handleApplyPreprocessing = async () => {
                setIsProcessing(true);
                
                // Small delay for UI responsiveness
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    // Apply preprocessing
                    const results = preprocessMatrix(originalMatrix);
                    
                    // Calculate statistics for preprocessed matrix
                    const preprocessedStats = calculateMatrixStatistics(results.preprocessedMatrix);
                    
                    // Calculate eigenvalues for preprocessed matrix
                    const preprocessedEigenvalues = calculateEigenvalueSpectrum(results.preprocessedMatrix);
                    
                    setPreprocessingResults({
                        ...results,
                        statistics: preprocessedStats,
                        eigenvalues: preprocessedEigenvalues
                    });
                    
                    setShowPreprocessedStats(true);
                    
                    // Notify parent component
                    onPreprocessingComplete(
                        results.preprocessedMatrix,
                        preprocessedStats,
                        preprocessedEigenvalues,
                        results
                    );
                } catch (error) {
                    console.error('Preprocessing failed:', error);
                    alert(`Preprocessing failed: ${error.message}`);
                } finally {
                    setIsProcessing(false);
                }
            };

            return (
                <div className="space-y-6">
                    {/* Preprocessing Control Panel */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Data Pre-Processing</h2>
                        
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <h3 className="font-semibold text-blue-900 mb-2">Pre-Processing Operations</h3>
                            <div className="space-y-2 text-sm text-blue-800">
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">1.</span>
                                    <div>
                                        <span className="font-semibold">Frobenius Normalization:</span>
                                        <span className="ml-2">Divide each matrix element by the Frobenius norm (||X||<sub>F</sub>)</span>
                                    </div>
                                </div>
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">2.</span>
                                    <div>
                                        <span className="font-semibold">Row Centering:</span>
                                        <span className="ml-2">Subtract row mean from each element to achieve zero-mean rows</span>
                                    </div>
                                </div>
                                <div className="mt-3 p-2 bg-white rounded border border-blue-300">
                                    <span className="font-mono text-xs">
                                        X<sub>processed</sub>[i,j] = (X[i,j] / ||X||<sub>F</sub>) - mean(row<sub>i</sub>)
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="flex gap-4">
                            <button
                                onClick={handleApplyPreprocessing}
                                disabled={isProcessing || preprocessingResults !== null}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isProcessing || preprocessingResults !== null
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isProcessing ? (
                                    <span className="flex items-center">
                                        <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>
                                        Processing...
                                    </span>
                                ) : preprocessingResults ? (
                                    'âœ“ Pre-Processing Applied'
                                ) : (
                                    'Apply Pre-Processing'
                                )}
                            </button>
                            
                            <button
                                onClick={onSkipPreprocessing}
                                disabled={isProcessing}
                                className="px-6 py-3 border border-gray-300 text-gray-700 rounded-md font-medium hover:bg-gray-50 transition-colors"
                            >
                                Skip Pre-Processing
                            </button>
                        </div>

                        {preprocessingResults && (
                            <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <h4 className="font-semibold text-green-900 mb-2">Pre-Processing Complete</h4>
                                <div className="grid grid-cols-2 gap-4 text-sm text-green-800">
                                    <div>
                                        <span className="font-medium">Original Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormOriginal.toFixed(4)}</span>
                                    </div>
                                    <div>
                                        <span className="font-medium">Processed Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormProcessed.toFixed(4)}</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Preprocessed Data Statistics */}
                    {showPreprocessedStats && preprocessingResults && (
                        <>
                            {/* Basic Matrix Overview */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-2xl font-bold mb-4">Preprocessed Matrix Overview</h2>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">
                                            {preprocessingResults.statistics.P} Ã— {preprocessingResults.statistics.N}
                                        </div>
                                        <div className="text-xs text-blue-600 mt-1">Features Ã— Samples</div>
                                    </div>
                                    <div className="bg-green-50 p-4 rounded-lg">
                                        <div className="text-sm text-green-600 font-medium">Range</div>
                                        <div className="text-lg font-bold text-green-900">
                                            [{preprocessingResults.statistics.min.toFixed(3)}, {preprocessingResults.statistics.max.toFixed(3)}]
                                        </div>
                                        <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">Overall Mean</div>
                                        <div className="text-lg font-bold text-purple-900">
                                            {preprocessingResults.statistics.mean.toExponential(2)}
                                        </div>
                                        <div className="text-xs text-purple-600 mt-1">Should be â‰ˆ0</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Overall Std Dev</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {preprocessingResults.statistics.stdDev.toFixed(4)}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">Normalized scale</div>
                                    </div>
                                </div>
                            </div>

                            {/* Row Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Row Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowMeans} 
                                        title="Row Means Distribution (should be ~0)"
                                        xLabel="Mean Value"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowStdDevs}
                                        title="Row Std Devs Distribution" 
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                </div>
                            </div>

                            {/* Column Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Column Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnMeans}
                                        title="Column Means Distribution"
                                        xLabel="Mean Value" 
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnStdDevs}
                                        title="Column Std Devs Distribution"
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                </div>
                            </div>

                            {/* Preprocessed Matrix Values Histogram */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Matrix Values Distribution</h2>
                                <MatrixHistogram 
                                    matrixData={preprocessingResults.preprocessedMatrix}
                                    title="Preprocessed Matrix Values"
                                    color="rgba(34, 197, 94, 1)"
                                    bins={64}
                                />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> After Frobenius normalization and row centering, the matrix values 
                                    should show a more centered distribution with normalized scale.</p>
                                </div>
                            </div>

                            {/* Eigenvalue Spectrum */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Eigenvalue Analysis</h2>
                                <SignalNoiseAnalysis eigenvalues={preprocessingResults.eigenvalues} />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> Preprocessing typically changes the eigenvalue spectrum. 
                                    The signal/noise boundary may be clearer after normalization and centering.</p>
                                </div>
                            </div>

                            {/* Continue Button */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessing Complete</h2>
                                <p className="text-gray-600 mb-4">
                                    Data has been successfully preprocessed. The Frobenius-normalized and row-centered matrix 
                                    will be used for all subsequent analyses.
                                </p>
                                <button
                                    className="px-6 py-3 bg-green-600 text-white rounded-md font-medium hover:bg-green-700 transition-colors"
                                    onClick={onProceedToAnalysis}
                                >
                                    âœ“ Continue with Preprocessed Data
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        // Analysis Configuration Panel Component
        const AnalysisConfigurationPanel = ({ matrix, matrixInfo, analysisStep, isRunningAnalysis = false, onStartAnalysis, onCancel }) => {
            const [analysisMode, setAnalysisMode] = useState('single'); // 'single' or 'multi'
            const [analysisType, setAnalysisType] = useState('alpha'); // 'alpha' or 'efdr'
            const [singleAlpha, setSingleAlpha] = useState(null);
            const [singleAlphaText, setSingleAlphaText] = useState(''); // Separate text state - start blank
            const [Nalpha, setNalpha] = useState(35);
            const [minAlpha, setMinAlpha] = useState(0);
            const [alphaMaxMultiplier, setAlphaMaxMultiplier] = useState(0.75);
            const [Nperm, setNperm] = useState(25);
            const [sprcnt, setSprcnt] = useState(5); // Support percentage (default 5%)
            const [alphaMax, setAlphaMax] = useState(null);
            const [alphaMaxComponents, setAlphaMaxComponents] = useState(null); // Store calculation components
            const [isCalculating, setIsCalculating] = useState(false);
            
            // Calculate alphaMax components and set initial values
            useEffect(() => {
                if (matrixInfo && matrixInfo.alphaMax) {
                    // Calculate components for equation display
                    try {
                        const { u, s } = svd1Sync(matrix);
                        const maxAbsU1 = Math.max(...u.map(val => Math.abs(val)));
                        const baseAlphaMax = alphaMaxMultiplier * maxAbsU1 * s;
                        
                        // Store components for equation display
                        setAlphaMaxComponents((prev) => ({
                            multiplier: alphaMaxMultiplier, // Use current multiplier
                            maxAbsU1: maxAbsU1,
                            s: s,
                            calculated: alphaMaxMultiplier * maxAbsU1 * s // Recalculate with current multiplier
                        }));
                        
                        // Initialize alphaMax with calculated value if empty
                        if (alphaMax === null) {
                            const adjustedAlphaMax = matrixInfo.alphaMax * (alphaMaxMultiplier / 0.75);
                            setAlphaMax(adjustedAlphaMax);
                        }
                        
                        console.log(`AlphaMax components: multiplier=${alphaMaxMultiplier}, max(|u1|)=${maxAbsU1.toFixed(6)}, s=${s.toFixed(6)}, result=${baseAlphaMax.toFixed(6)}`);
                    } catch (error) {
                        console.error('Error calculating alphaMax components:', error);
                    }
                }
            }, [matrixInfo, matrix]); // Removed alphaMaxMultiplier and alphaMax to prevent overriding manual input

            // Separate effect to update equation components when multiplier changes
            useEffect(() => {
                if (alphaMaxComponents) {
                    setAlphaMaxComponents(prev => ({
                        ...prev,
                        multiplier: alphaMaxMultiplier,
                        calculated: alphaMaxMultiplier * prev.maxAbsU1 * prev.s
                    }));
                }
            }, [alphaMaxMultiplier]);
            
            const nsupp = useMemo(() => {
                // nsupp = 0.01 * sprcnt * P
                return Math.round(0.01 * sprcnt * (matrixInfo?.P || 1000));
            }, [sprcnt, matrixInfo]);
            
            const handleStartAnalysis = () => {
                if (analysisStep === 'single') {
                    // Single alpha analysis

                    // Validate alpha value
                    if (singleAlpha === null || singleAlpha === undefined) {
                        alert('Please enter an Alpha value.');
                        return;
                    }

                    if (singleAlpha < 0) {
                        alert('Alpha value must be â‰¥ 0.');
                        return;
                    }

                    if (alphaMax !== null && singleAlpha > alphaMax) {
                        const proceed = confirm(`Warning: Alpha value (${singleAlpha.toFixed(6)}) exceeds AlphaMax (${alphaMax.toFixed(6)}). This will likely result in 0 detections. Continue anyway?`);
                        if (!proceed) return;
                    }

                    const config = {
                        analysisMode: 'single',
                        alpha: singleAlpha,
                        alphaMax
                    };
                    console.log('Starting single alpha analysis with config:', config);
                    console.log('singleAlpha value:', singleAlpha);
                    onStartAnalysis(config);
                } else if (analysisStep === 'alpha' || analysisStep === 'efdr') {
                    // Multi-alpha analysis
                    if (!alphaMax || alphaMax === '') {
                        alert('Please enter a Maximum Alpha value.');
                        return;
                    }
                    
                    const config = {
                        analysisMode: 'multi',
                        analysisType: analysisStep, // Use analysisStep directly
                        Nalpha: Nalpha || 35,
                        alphaMax: alphaMax,
                        alphaMaxMultiplier,
                        alpha0: minAlpha || 0,
                        nsupp,
                        sprcnt,
                        ...(analysisStep === 'efdr' && { Nperm })
                    };
                    
                    onStartAnalysis(config);
                }
            };
            
            // Show summary view during eFDR analysis
            if (isRunningAnalysis && analysisStep === 'efdr') {
                return (
                    <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4">eFDR Configuration</h2>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                            <div>
                                <span className="text-gray-500">Analysis Type:</span>
                                <div className="font-medium text-gray-900">eFDR Analysis</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Alpha Min:</span>
                                <div className="font-medium text-gray-900">{minAlpha.toFixed(4)}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Alpha Max:</span>
                                <div className="font-medium text-gray-900">{alphaMax?.toFixed(4) || 'N/A'}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">N Alpha:</span>
                                <div className="font-medium text-gray-900">{Nalpha}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Permutations:</span>
                                <div className="font-medium text-gray-900">{Nperm}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Support %:</span>
                                <div className="font-medium text-gray-900">{sprcnt}%</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Support Size:</span>
                                <div className="font-medium text-gray-900">{nsupp}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Matrix Size:</span>
                                <div className="font-medium text-gray-900">{matrixInfo?.P || '?'} Ã— {matrixInfo?.N || '?'}</div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="space-y-6">
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="border-b pb-4 mb-6">
                            <div className="flex justify-between items-center mb-2">
                                <h1 className="text-2xl font-bold text-gray-800">
                                    {analysisStep === 'single' ? 'Single-Alpha SSVD Analysis' : 
                                     analysisStep === 'alpha' ? 'N-Alpha SSVD Analysis' : 
                                     analysisStep === 'efdr' ? 'eFDR Parameters' : 'SSVD Analysis'}
                                </h1>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={onCancel}
                                        className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                                    >
                                        â† Back to Analysis Type
                                    </button>
                                    <button
                                        onClick={() => window.location.reload()}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                                    >
                                        Reset
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        
                        {/* Single Alpha Configuration */}
                        {analysisStep === 'single' && (
                            <div className="mb-6 p-4 bg-blue-50 rounded-lg">
                                <h3 className="font-medium text-gray-700 mb-3">Single Alpha Parameters</h3>
                                <div className="grid grid-cols-2 gap-6">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Alpha Value (Sparsity Parameter)
                                        </label>
                                        <div className="space-y-2">
                                            <input
                                                type="text"
                                                value={singleAlphaText}
                                                onChange={(e) => {
                                                    const inputValue = e.target.value;
                                                    console.log('Alpha input raw value:', inputValue);
                                                    setSingleAlphaText(inputValue);
                                                    
                                                    // Try to parse as number
                                                    const numValue = parseFloat(inputValue);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        setSingleAlpha(numValue);
                                                    }
                                                }}
                                                onBlur={() => {
                                                    // On blur, ensure text matches the numeric value
                                                    if (singleAlpha !== null) {
                                                        setSingleAlphaText(singleAlpha.toString());
                                                    } else if (singleAlphaText === '') {
                                                        // Keep it blank if no value entered
                                                        setSingleAlphaText('');
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border-2 border-blue-300 rounded-md text-lg font-semibold focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
                                                placeholder="Enter alpha value"
                                            />
                                            <p className="text-xs text-gray-600 mt-2">
                                                Higher alpha âŸ¹ Greater sparsity (fewer detections)
                                            </p>
                                            {singleAlpha !== null && alphaMax !== null && singleAlpha > alphaMax && (
                                                <p className="text-xs text-red-600 mt-1 font-semibold">
                                                    âš ï¸ Warning: Alpha value exceeds AlphaMax ({alphaMax.toFixed(6)})
                                                </p>
                                            )}
                                            {singleAlpha !== null && singleAlpha < 0 && (
                                                <p className="text-xs text-red-600 mt-1 font-semibold">
                                                    âš ï¸ Warning: Alpha must be â‰¥ 0
                                                </p>
                                            )}
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Maximum Alpha (Zero Detection Threshold)
                                        </label>
                                        <input
                                            type="number"
                                            value={alphaMax === null ? '' : alphaMax}
                                            onChange={(e) => {
                                                console.log('Maximum Alpha input changed:', e.target.value);
                                                const value = e.target.value;
                                                if (value === '' || value === null) {
                                                    setAlphaMax(null);
                                                } else {
                                                    const numValue = parseFloat(value);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        console.log('Setting alphaMax to:', numValue);
                                                        setAlphaMax(numValue);
                                                    }
                                                }
                                            }}
                                            disabled={isCalculating}
                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md disabled:bg-gray-100 disabled:text-gray-500"
                                            placeholder={isCalculating ? "Calculating..." : "Enter or calculate max alpha"}
                                        />
                                        <p className="text-xs text-gray-600 mt-2">
                                            Alpha values above this threshold are likely to result in zero detections
                                        </p>

                                        {/* Static Maximum Alpha equation display */}
                                        {alphaMaxComponents && (
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Default Maximum Alpha Calculation:</div>
                                                <div className="font-mono text-gray-600">
                                                    AlphaMax = AlphaMaxMultiplier Ã— max(|U1|) Ã— S1 = <span className="font-bold">0.75</span> Ã— <span className="font-bold">{alphaMaxComponents.maxAbsU1.toFixed(4)}</span> Ã— <span className="font-bold">{alphaMaxComponents.s.toFixed(4)}</span> = <span className="font-bold">{(0.75 * alphaMaxComponents.maxAbsU1 * alphaMaxComponents.s).toFixed(6)}</span>
                                                </div>
                                                <div className="text-gray-500 mt-1 text-xs">Input field above is fully editable - you can override this default value</div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Configuration */}
                        {(analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <>
                                {/* Alpha Sequence Configuration */}
                                <div className="grid grid-cols-2 gap-6 mb-1">
                                    {/* Upper left: Number of Alphas */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Number of Alphas (nAlpha)
                                        </label>
                                        <input
                                            type="number"
                                            min="5"
                                            max="75"
                                            value={Nalpha}
                                            onChange={(e) => {
                                                const value = e.target.value;
                                                setNalpha(value === '' ? '' : parseInt(value) || 35);
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Number of alpha values to test (5-75)
                                        </p>
                                    </div>
                                    
                                    {/* Upper right: Minimum Alpha */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Minimum Alpha (AlphaMin)
                                        </label>
                                        <input
                                            type="number"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={minAlpha}
                                            onChange={(e) => {
                                                const value = e.target.value;
                                                setMinAlpha(value === '' ? '' : parseFloat(value) || 0);
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Starting alpha value (typically 0)
                                        </p>
                                    </div>
                                    
                                    {/* Lower left: Number of Permutations - for eFDR analysis */}
                                    {analysisStep === 'efdr' && (
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                                Number of Permutations (Nperm)
                                            </label>
                                            <input
                                                type="number"
                                                min="5"
                                                max="100"
                                                value={Nperm}
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    if (val === '') {
                                                        setNperm('');
                                                    } else {
                                                        const num = parseInt(val);
                                                        if (!isNaN(num)) {
                                                            setNperm(num);
                                                        }
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    console.log('Nperm onBlur triggered, current value:', e.target.value);
                                                    if (e.target.value === '' || parseInt(e.target.value) < 5) {
                                                        console.log('Nperm reset to 25 due to invalid value (< 5)');
                                                        setNperm(25);
                                                    } else if (parseInt(e.target.value) > 100) {
                                                        console.log('Nperm capped to 100');
                                                        setNperm(100);
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                                            />
                                        </div>
                                    )}
                                    
                                    {/* Lower right: Maximum Alpha */}
                                    <div className={analysisStep !== 'efdr' ? 'col-start-1' : ''}>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Maximum Alpha (AlphaMax)
                                        </label>
                                        <input
                                            type="number"
                                            value={alphaMax === null ? '' : alphaMax}
                                            onChange={(e) => {
                                                console.log('Maximum Alpha input changed:', e.target.value);
                                                const value = e.target.value;
                                                if (value === '' || value === null) {
                                                    setAlphaMax(null);
                                                } else {
                                                    const numValue = parseFloat(value);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        console.log('Setting alphaMax to:', numValue);
                                                        setAlphaMax(numValue);
                                                    }
                                                }
                                            }}
                                            disabled={isCalculating}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md disabled:bg-gray-100 disabled:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                            placeholder={isCalculating ? "Calculating..." : "Enter or calculate max alpha"}
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Alpha values above this threshold are likely to result in zero detections
                                        </p>

                                        {/* Static Maximum Alpha equation display */}
                                        {alphaMaxComponents && (
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Default Maximum Alpha Calculation:</div>
                                                <div className="font-mono text-gray-600">
                                                    AlphaMax = AlphaMaxMultiplier Ã— max(|U1|) Ã— S1 = <span className="font-bold">0.75</span> Ã— <span className="font-bold">{alphaMaxComponents.maxAbsU1.toFixed(4)}</span> Ã— <span className="font-bold">{alphaMaxComponents.s.toFixed(4)}</span> = <span className="font-bold">{(0.75 * alphaMaxComponents.maxAbsU1 * alphaMaxComponents.s).toFixed(6)}</span>
                                                </div>
                                                <div className="text-gray-500 mt-1 text-xs">Input field above is fully editable - you can override this default value</div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Expected Support Percentage - much closer to Nperm */}
                                {analysisStep === 'efdr' && (
                                    <div className="grid grid-cols-2 gap-6 -mt-16">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                                Expected Support Percentage (sprcnt)
                                            </label>
                                            <input
                                                type="number"
                                                min="1"
                                                max="50"
                                                step="1"
                                                value={sprcnt}
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    if (val === '') {
                                                        setSprcnt('');
                                                    } else {
                                                        const num = parseFloat(val);
                                                        if (!isNaN(num)) {
                                                            setSprcnt(num);
                                                        }
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    if (e.target.value === '' || parseFloat(e.target.value) < 1) {
                                                        setSprcnt(5);
                                                    } else if (parseFloat(e.target.value) > 50) {
                                                        setSprcnt(50);
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                                            />
                                            
                                            {/* Estimated Support Size display */}
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Estimated Number of Detections (nsupp):</div>
                                                <div className="font-mono text-gray-600">
                                                    nsupp = 0.01 x sprcnt x P = 0.01 x {sprcnt} x {matrixInfo?.P || 'P'} = <span className="font-bold">{nsupp}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div></div>
                                    </div>
                                )}
                                
                                {/* eFDR Analysis Time Estimate */}
                                {analysisStep === 'efdr' && (
                                    <div className="mt-3 p-3 bg-yellow-100 border border-yellow-300 rounded-lg">
                                        <div className="flex items-start">
                                            <span className="text-lg mr-2 mt-0.5">â±ï¸</span>
                                            <div className="flex-1">
                                                <p className="text-sm font-semibold text-yellow-800">
                                                    Analysis Time Estimate
                                                </p>
                                                <p className="text-xs text-yellow-700 mt-1">
                                                    Will run <span className="font-bold">{Nalpha * (1 + Nperm)}</span> SSVD iterations
                                                    ({Nalpha} alphas Ã— {1 + Nperm} runs each)
                                                </p>
                                                <p className="text-xs text-yellow-600 mt-1">
                                                    Estimated time: {Math.ceil(Nalpha * (1 + Nperm) * 0.5)} - {Math.ceil(Nalpha * (1 + Nperm) * 1.5)} seconds
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </>
                        )}
                        
                        {/* Action Buttons */}
                        <div className="flex justify-end mt-8">
                            <button
                                onClick={handleStartAnalysis}
                                disabled={isCalculating || ((analysisStep === 'alpha' || analysisStep === 'efdr') && (!alphaMax || alphaMax === '')) || (analysisStep === 'single' && (singleAlpha === null || singleAlpha === undefined))}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isCalculating || ((analysisStep === 'alpha' || analysisStep === 'efdr') && (!alphaMax || alphaMax === '')) || (analysisStep === 'single' && (singleAlpha === null || singleAlpha === undefined))
                                        ? 'bg-gray-400 text-gray-200 cursor-not-allowed' 
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isCalculating ? 'Calculating AlphaMax...' :
                                 analysisStep === 'single' ? 'Run Analysis' :
                                 analysisStep === 'efdr' ? 'Start eFDR Analysis' :
                                 'Start N-Alpha Analysis'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Heatmap Chart Component - Full 191x368 solution submatrix using Canvas
        const HeatmapChart = ({ ssvdResults, matrix, analysisMode }) => {
            const canvasRef = React.useRef(null);
            const canvasRef2 = React.useRef(null); // Second canvas for rank-1 reconstruction
            const [isRendering, setIsRendering] = React.useState(false);
            const [isRenderingRank1, setIsRenderingRank1] = React.useState(false);

            if (!ssvdResults || !matrix || !ssvdResults.detectedIndices || ssvdResults.detectedIndices.length === 0) {
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h3 className="text-lg font-semibold mb-4">Solution Submatrix Heatmap</h3>
                        <div className="flex items-center justify-center h-40 text-gray-500">
                            No detections found - heatmap not available
                        </div>
                    </div>
                );
            }

            const detectedIndices = ssvdResults.detectedIndices;
            const Q = detectedIndices.length; // 191 detections
            const N = matrix[0].length;       // 368 samples
            
            // Canvas dimensions for full heatmap - increased width for better viewing
            // Ensure minimum dimensions for visibility
            const minHeight = 200; // Minimum 200px height for visibility
            const minWidth = 600;  // Increased minimum width for better visibility

            // Calculate dimensions with minimums - increased max width to 1200px
            const canvasWidth = Math.max(minWidth, Math.min(1200, N * 3));  // Min 600px, Max 1200px, 3px per sample
            const canvasHeight = Math.max(minHeight, Math.min(600, Q * 4)); // Min 200px, Max 600px, 4px per detection for better visibility
            const cellWidth = canvasWidth / N;
            const cellHeight = canvasHeight / Q;

            // Extract full submatrix for all 191 detections x 368 samples
            const submatrix = detectedIndices.map(rowIdx => matrix[rowIdx]);
            
            // Calculate z-scores for color mapping
            const zScoredMatrix = submatrix.map(row => {
                const mean = row.reduce((sum, val) => sum + val, 0) / row.length;
                const variance = row.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / row.length;
                const std = Math.sqrt(variance);
                return row.map(val => std > 0 ? (val - mean) / std : 0);
            });
            
            // Color mapping function for Canvas (returns RGB array)
            const getColorRGB = (zScore) => {
                const clampedZ = Math.max(-3, Math.min(3, zScore));
                const normalized = (clampedZ + 3) / 6; // 0 to 1

                if (normalized < 0.5) {
                    // Blue to white
                    const intensity = normalized * 2;
                    const val = Math.round(255 * (1 - intensity * 0.5));
                    return [val, val, 255];
                } else {
                    // White to red
                    const intensity = (normalized - 0.5) * 2;
                    const val = Math.round(255 * (1 - intensity * 0.5));
                    return [255, val, val];
                }
            };

            // Canvas rendering effect
            React.useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                setIsRendering(true);
                const ctx = canvas.getContext('2d');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Create ImageData for efficient pixel manipulation
                const imageData = ctx.createImageData(canvasWidth, canvasHeight);
                const data = imageData.data;

                // Render each cell as pixels
                for (let rowIdx = 0; rowIdx < Q; rowIdx++) {
                    for (let colIdx = 0; colIdx < N; colIdx++) {
                        const zScore = zScoredMatrix[rowIdx][colIdx];
                        const [r, g, b] = getColorRGB(zScore);

                        // Calculate pixel coordinates
                        const startX = Math.floor(colIdx * cellWidth);
                        const endX = Math.floor((colIdx + 1) * cellWidth);
                        const startY = Math.floor(rowIdx * cellHeight);
                        const endY = Math.floor((rowIdx + 1) * cellHeight);

                        // Fill the cell area
                        for (let y = startY; y < endY; y++) {
                            for (let x = startX; x < endX; x++) {
                                const pixelIndex = (y * canvasWidth + x) * 4;
                                data[pixelIndex] = r;     // Red
                                data[pixelIndex + 1] = g; // Green
                                data[pixelIndex + 2] = b; // Blue
                                data[pixelIndex + 3] = 255; // Alpha
                            }
                        }
                    }
                }

                // Draw the image data to canvas
                ctx.putImageData(imageData, 0, 0);
                setIsRendering(false);
            }, [detectedIndices, matrix]);

            // Rank-1 reconstruction effect for N-alpha mode with sorted columns
            React.useEffect(() => {
                if (analysisMode !== 'nalpha' || !ssvdResults.u || !ssvdResults.v || !ssvdResults.s) return;

                const canvas2 = canvasRef2.current;
                if (!canvas2) return;

                setIsRenderingRank1(true);
                const ctx = canvas2.getContext('2d');
                canvas2.width = canvasWidth;
                canvas2.height = canvasHeight;

                // Calculate rank-1 reconstruction A1 = u1 * s1 * v1^T
                // First, get the detected rows from u1
                const u1_detected = detectedIndices.map(idx => ssvdResults.u[idx]);
                const s1 = ssvdResults.s;
                const v1 = ssvdResults.v;

                // Create sorted indices for v1 (ascending order)
                const v1WithIndex = v1.map((val, idx) => ({ value: val, index: idx }));
                const sortedV1 = [...v1WithIndex].sort((a, b) => a.value - b.value);
                const sortedIndices = sortedV1.map(item => item.index);

                // Compute rank-1 reconstruction for detected rows only, with sorted columns
                // A1[i][j] = u1[i] * s1 * v1[sorted_j]
                const rank1Matrix = [];
                for (let i = 0; i < detectedIndices.length; i++) {
                    const row = [];
                    // Use sorted order for columns
                    for (let j = 0; j < N; j++) {
                        const originalColIdx = sortedIndices[j];
                        row.push(u1_detected[i] * s1 * v1[originalColIdx]);
                    }
                    rank1Matrix.push(row);
                }

                // Calculate z-scores for the rank-1 matrix
                const zScoredRank1 = rank1Matrix.map(row => {
                    const mean = row.reduce((sum, val) => sum + val, 0) / row.length;
                    const variance = row.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / row.length;
                    const std = Math.sqrt(variance);
                    return row.map(val => std > 0 ? (val - mean) / std : 0);
                });

                // Create ImageData for rank-1 heatmap
                const imageData = ctx.createImageData(canvasWidth, canvasHeight);
                const data = imageData.data;

                // Render each cell as pixels
                for (let rowIdx = 0; rowIdx < detectedIndices.length; rowIdx++) {
                    for (let colIdx = 0; colIdx < N; colIdx++) {
                        const zScore = zScoredRank1[rowIdx][colIdx];
                        const [r, g, b] = getColorRGB(zScore);

                        // Calculate pixel coordinates
                        const startX = Math.floor(colIdx * cellWidth);
                        const endX = Math.floor((colIdx + 1) * cellWidth);
                        const startY = Math.floor(rowIdx * cellHeight);
                        const endY = Math.floor((rowIdx + 1) * cellHeight);

                        // Fill the cell area
                        for (let y = startY; y < endY; y++) {
                            for (let x = startX; x < endX; x++) {
                                const pixelIndex = (y * canvasWidth + x) * 4;
                                data[pixelIndex] = r;     // Red
                                data[pixelIndex + 1] = g; // Green
                                data[pixelIndex + 2] = b; // Blue
                                data[pixelIndex + 3] = 255; // Alpha
                            }
                        }
                    }
                }

                // Draw the image data to canvas
                ctx.putImageData(imageData, 0, 0);

                // Draw quartile lines on the heatmap
                const q1Position = Math.floor(N * 0.25);
                const q2Position = Math.floor(N * 0.50);
                const q3Position = Math.floor(N * 0.75);

                // Draw vertical quartile lines
                ctx.strokeStyle = 'rgba(220, 38, 127, 0.8)'; // Pink for Q1
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(q1Position * cellWidth, 0);
                ctx.lineTo(q1Position * cellWidth, canvasHeight);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(147, 51, 234, 0.8)'; // Purple for Median
                ctx.beginPath();
                ctx.moveTo(q2Position * cellWidth, 0);
                ctx.lineTo(q2Position * cellWidth, canvasHeight);
                ctx.stroke();

                ctx.strokeStyle = 'rgba(59, 130, 246, 0.8)'; // Blue for Q3
                ctx.beginPath();
                ctx.moveTo(q3Position * cellWidth, 0);
                ctx.lineTo(q3Position * cellWidth, canvasHeight);
                ctx.stroke();

                // Reset line dash
                ctx.setLineDash([]);

                setIsRenderingRank1(false);
            }, [detectedIndices, matrix, analysisMode, ssvdResults]);

            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">
                        Solution Submatrix Heatmap ({Q} detections Ã— {N} samples)
                    </h3>

                    {isRendering && (
                        <div className="flex items-center justify-center py-8 text-blue-600">
                            <div className="animate-pulse">Rendering heatmap...</div>
                        </div>
                    )}

                    <div className="flex justify-center">
                        <canvas
                            ref={canvasRef}
                            data-chart-type="heatmap-original"
                            style={{
                                maxWidth: '100%',
                                border: '1px solid #e5e7eb',
                                backgroundColor: 'white'
                            }}
                        />
                    </div>

                    <div className="mt-4 text-sm text-gray-600 text-center">
                        <div>Blue = Below average, Red = Above average (Z-score normalized)</div>
                        <div>Rows: {Q} detected variables, Columns: {N} samples</div>
                    </div>

                    {/* Rank-1 Reconstruction Heatmap - only for N-alpha mode */}
                    {analysisMode === 'nalpha' && ssvdResults.u && ssvdResults.v && ssvdResults.s && (
                        <>
                            <h3 className="text-lg font-semibold mt-8 mb-4">
                                Rank-1 Reconstruction Heatmap (U1Â·S1Â·V1^T) - Columns Sorted by V1 ({Q} detections Ã— {N} samples)
                            </h3>

                            {isRenderingRank1 && (
                                <div className="flex items-center justify-center py-8 text-blue-600">
                                    <div className="animate-pulse">Rendering rank-1 reconstruction...</div>
                                </div>
                            )}

                            <div className="flex justify-center">
                                <canvas
                                    ref={canvasRef2}
                                    data-chart-type="heatmap-sorted"
                                    style={{
                                        maxWidth: '100%',
                                        border: '1px solid #e5e7eb',
                                        backgroundColor: 'white'
                                    }}
                                />
                            </div>

                            <div className="mt-4 text-sm text-gray-600 text-center">
                                <div>Rank-1 approximation with columns sorted by V1 scores (ascending left to right)</div>
                                <div>Shows the common pattern across detected variables: U1Â·S1Â·V1^T</div>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        // ===================================================================
        // COMPREHENSIVE EXPORT SYSTEM - EXPORT_SYSTEM_v1.0_SSVD1X
        // ===================================================================

        // CSV Export Functions
        const exportDetectedRowsCSV = (results, matrix, matrixInfo) => {
            if (!results || !results.detectedIndices || results.detectedIndices.length === 0) {
                alert('No detections found for this alpha value.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const alpha = results.alpha || 0;

            // Create header row: Row_Index, Variable_Name, U_Value, then sample columns
            const headers = ['Row_Index', 'Variable_Name', 'U_Value'];
            for (let i = 0; i < matrix[0].length; i++) {
                headers.push(`Sample_${i + 1}`);
            }

            // Create detected rows data
            const rows = results.detectedIndices.map(idx => {
                const oneBasedIdx = idx + 1;
                const varName = matrixInfo?.rowHeaders?.[idx] || `Variable_${oneBasedIdx}`;
                const uValue = results.u[idx];
                const row = [oneBasedIdx, varName, uValue.toFixed(6)];
                
                // Add sample values
                matrix[idx].forEach(val => {
                    row.push(val.toFixed(6));
                });
                return row;
            });

            const csvContent = Papa.unparse({
                fields: headers,
                data: rows
            });

            const filename = `SSVD1x_DetectedRows_Alpha${alpha.toFixed(4)}_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log(`âœ… Detected rows exported (${results.detectedIndices.length} rows):`, filename);
        };

        const exportAnalysisParametersCSV = (results, matrixInfo, analysisParams) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

            const metadata = [
                ['Parameter', 'Value'],
                ['Analysis Date', new Date().toISOString()],
                ['Matrix Dimensions (P x N)', `${matrixInfo?.P || matrixInfo?.rows || 'N/A'} x ${matrixInfo?.N || matrixInfo?.cols || 'N/A'}`],
                ['Alpha Value', results.alpha.toFixed(6)],
                ['Detections Count', results.detections],
                ['Sparsity (%)', results.sparsity],
                ['Iterations', results.iterations],
                ['Converged', results.converged ? 'Yes' : 'No'],
                ['Singular Value (S1)', results.s.toFixed(6)],
                ...(analysisParams ? Object.entries(analysisParams).map(([k, v]) => [k, v]) : [])
            ];

            const csvContent = Papa.unparse(metadata);
            const filename = `SSVD1x_Analysis_Parameters_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log('âœ… Analysis parameters exported:', filename);
        };

        const exportV1ScoresCSV = (results, matrixInfo) => {
            if (!results || !results.v || results.v.length === 0) {
                alert('No V1 scores available. Please run analysis first.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const alpha = results.alpha || 0;

            // Create header row: Sample_Index, Sample_Name, V1_Score
            const headers = ['Sample_Index', 'Sample_Name', 'V1_Score'];

            // Create V1 scores data
            const rows = results.v.map((score, idx) => {
                const oneBasedIdx = idx + 1;
                const sampleName = matrixInfo?.colHeaders?.[idx] || `Sample_${oneBasedIdx}`;
                return [oneBasedIdx, sampleName, score.toFixed(6)];
            });

            const csvContent = Papa.unparse({
                fields: headers,
                data: rows
            });

            const filename = `SSVD1x_V1_Scores_Alpha${alpha.toFixed(4)}_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log(`âœ… V1 scores exported (${results.v.length} samples):`, filename);
        };

        // Chart Export Functions - PNG ONLY with proper SVG handling
        const exportChartsAsImages = async () => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const canvasCharts = document.querySelectorAll('canvas');
            const svgCharts = document.querySelectorAll('svg');
            
            console.log(`ðŸ“Š Found ${canvasCharts.length} canvas charts and ${svgCharts.length} SVG charts for export`);
            
            if (canvasCharts.length === 0 && svgCharts.length === 0) {
                alert('No charts available to export. Please run analysis first.');
                return;
            }

            // Export Canvas charts (Chart.js) as PNG
            canvasCharts.forEach((canvas, index) => {
                try {
                    const chartContainer = canvas.closest('.bg-white, .chart-container');
                    const titleElement = chartContainer ? chartContainer.querySelector('h3, h4, h5') : null;
                    let chartTitle = titleElement ? titleElement.textContent.trim() : `Chart_${index + 1}`;

                    // Add sorted identifier based on data attribute
                    const chartType = canvas.getAttribute('data-chart-type');
                    if (chartType === 'v1-sorted') {
                        chartTitle = chartTitle.replace('V1 Analysis', 'V1_Sorted_Scores');
                    } else if (chartType === 'v1-original') {
                        chartTitle = chartTitle.replace('V1 Analysis', 'V1_Original_Order');
                    } else if (chartType === 'heatmap-sorted') {
                        // Extract dimensions from title like "32 detections Ã— 100 samples"
                        const dimensionMatch = chartTitle.match(/(\d+)\s+detections.*?(\d+)\s+samples/);
                        if (dimensionMatch) {
                            const detections = dimensionMatch[1];
                            const samples = dimensionMatch[2];
                            chartTitle = `Solution_Submatrix_Sorted_Heatmap_${detections}_detections_${samples}_samples`;
                        } else {
                            chartTitle = 'Solution_Submatrix_Sorted_Heatmap';
                        }
                    } else if (chartType === 'heatmap-original') {
                        // Extract dimensions from title like "32 detections Ã— 100 samples"
                        const dimensionMatch = chartTitle.match(/(\d+)\s+detections.*?(\d+)\s+samples/);
                        if (dimensionMatch) {
                            const detections = dimensionMatch[1];
                            const samples = dimensionMatch[2];
                            chartTitle = `Solution_Submatrix_Heatmap_${detections}_detections_${samples}_samples`;
                        } else {
                            chartTitle = 'Solution_Submatrix_Heatmap';
                        }
                    }

                    const cleanTitle = chartTitle.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_');
                    const filename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                    
                    // Create canvas with white background
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    tempCanvas.toBlob(blob => {
                        if (blob) {
                            saveAs(blob, filename);
                            console.log('âœ… Canvas chart exported as PNG:', filename);
                        }
                    }, 'image/png', 1.0);
                } catch (error) {
                    console.error('Error exporting canvas chart:', error);
                }
            });

            // Export only relevant SVG charts (filter out small legends and decorative elements)
            const relevantSVGs = Array.from(svgCharts).filter(svg => {
                const width = parseInt(svg.getAttribute('width') || svg.viewBox?.baseVal?.width || 0);
                const height = parseInt(svg.getAttribute('height') || svg.viewBox?.baseVal?.height || 0);
                const rect = svg.getBoundingClientRect();
                
                // Filter out small SVGs (likely legends or icons)
                const minSize = 100; // Minimum size in pixels
                const isLargeEnough = (width > minSize || rect.width > minSize) && 
                                      (height > minSize || rect.height > minSize);
                
                // Check if it's inside a chart container
                const container = svg.closest('.bg-white, .chart-container');
                const hasTitle = container ? container.querySelector('h3, h4, h5') : false;
                
                console.log('SVG filter check:', { 
                    width, height, 
                    rectWidth: rect.width, rectHeight: rect.height,
                    isLargeEnough, hasTitle,
                    container: container?.className
                });
                
                return isLargeEnough && hasTitle;
            });
            
            console.log(`ðŸ“Š Filtered to ${relevantSVGs.length} relevant SVG charts for export`);

            // Export filtered SVG charts as PNG
            relevantSVGs.forEach((svg, index) => {
                try {
                    const chartContainer = svg.closest('.bg-white, .chart-container');
                    const titleElement = chartContainer ? chartContainer.querySelector('h3, h4, h5') : null;
                    const chartTitle = titleElement ? titleElement.textContent.trim() : `SVG_Chart_${index + 1}`;
                    
                    const cleanTitle = chartTitle.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_');
                    
                    // Get actual SVG dimensions
                    const svgRect = svg.getBoundingClientRect();
                    const width = Math.max(svgRect.width, 600);
                    const height = Math.max(svgRect.height, 400);
                    
                    // Clone and prepare SVG for export
                    const svgClone = svg.cloneNode(true);
                    svgClone.setAttribute('width', width);
                    svgClone.setAttribute('height', height);
                    
                    // Add white background if not present
                    if (!svgClone.querySelector('rect.background')) {
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bgRect.setAttribute('width', '100%');
                        bgRect.setAttribute('height', '100%');
                        bgRect.setAttribute('fill', 'white');
                        svgClone.insertBefore(bgRect, svgClone.firstChild);
                    }
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    
                    const img = new Image();
                    img.width = width;
                    img.height = height;
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        
                        // White background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the SVG image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob(blob => {
                            if (blob) {
                                const pngFilename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                                saveAs(blob, pngFilename);
                                console.log('âœ… SVG chart exported as PNG:', pngFilename);
                            }
                            URL.revokeObjectURL(svgUrl);
                        }, 'image/png', 1.0);
                    };
                    
                    img.onerror = (e) => {
                        console.error('Failed to convert SVG to PNG for:', cleanTitle, e);
                        URL.revokeObjectURL(svgUrl);
                        
                        // Fallback: Try with base64 encoding
                        try {
                            const base64Url = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
                            const fallbackImg = new Image();
                            fallbackImg.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = width;
                                canvas.height = height;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(fallbackImg, 0, 0);
                                
                                canvas.toBlob(blob => {
                                    if (blob) {
                                        const pngFilename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                                        saveAs(blob, pngFilename);
                                        console.log('âœ… SVG chart exported as PNG (fallback):', pngFilename);
                                    }
                                }, 'image/png', 1.0);
                            };
                            fallbackImg.src = base64Url;
                        } catch (fallbackError) {
                            console.error('Fallback also failed:', fallbackError);
                        }
                    };
                    
                    img.src = svgUrl;
                } catch (error) {
                    console.error('Error exporting SVG chart:', error);
                }
            });
        };

        // JSON Export Functions
        const exportAnalysisStateJSON = (results, matrix, matrixInfo, analysisParams) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            
            const analysisState = {
                exportInfo: {
                    timestamp: new Date().toISOString(),
                    version: 'SSVD1x_v2.0',
                    exportType: 'complete_analysis_state'
                },
                matrixInfo: {
                    dimensions: {
                        rows: matrixInfo?.P || matrixInfo?.rows || 0,
                        cols: matrixInfo?.N || matrixInfo?.cols || 0
                    },
                    rowHeaders: matrixInfo.rowHeaders,
                    colHeaders: matrixInfo.colHeaders,
                    filename: matrixInfo.filename
                },
                analysisResults: {
                    alpha: results.alpha,
                    detections: results.detections,
                    sparsity: results.sparsity,
                    iterations: results.iterations,
                    converged: results.converged,
                    singularValue: results.s,
                    detectedIndices: results.detectedIndices,
                    uVector: results.u,
                    vVector: results.v,
                    errors: results.errors || [],
                    sparsityHistory: results.sparsityHistory || []
                },
                analysisParameters: analysisParams || {},
                matrixData: {
                    original: matrix,
                    detectedRows: results.detectedIndices.map(idx => matrix[idx])
                }
            };

            const jsonContent = JSON.stringify(analysisState, null, 2);
            const filename = `SSVD1x_Analysis_State_${timestamp}.json`;
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            saveAs(blob, filename);
            console.log('âœ… Complete analysis state exported:', filename);
        };

        // PDF Report Generation with improved formatting
        const generatePDFReport = async (results, matrix, matrixInfo, analysisParams) => {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                
                const P = matrixInfo?.P || matrixInfo?.rows || 0;
                const N = matrixInfo?.N || matrixInfo?.cols || 0;

                // Page 1: Title and Executive Summary
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                pdf.text('SSVD1x Analysis Report', 105, 30, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(100);
                pdf.text('Sparse Singular Value Decomposition Analysis', 105, 40, { align: 'center' });
                
                // Report metadata box
                pdf.setDrawColor(200);
                pdf.setFillColor(245, 245, 245);
                pdf.rect(15, 50, 180, 30, 'FD');
                
                pdf.setTextColor(0);
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, 60);
                pdf.text(`File: ${matrixInfo?.filename || 'User Upload'}`, 20, 67);
                pdf.text(`Matrix Dimensions: ${P} Ã— ${N} (PÃ—N)`, 20, 74);
                
                // Analysis Results Section
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Analysis Parameters', 20, 95);
                
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(11);
                
                // Two-column layout for parameters
                const leftCol = 25;
                const rightCol = 110;
                let yPos = 105;
                
                // Left column
                pdf.text(`Alpha Value:`, leftCol, yPos);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.alpha.toFixed(6)}`, leftCol + 35, yPos);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Detections:`, leftCol, yPos + 8);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.detections} / ${P} (${((results.detections/P)*100).toFixed(1)}%)`, leftCol + 35, yPos + 8);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Sparsity:`, leftCol, yPos + 16);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.sparsity || 0}% non-zero`, leftCol + 35, yPos + 16);
                pdf.setFont(undefined, 'normal');
                
                // Right column
                pdf.text(`Iterations:`, rightCol, yPos);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.iterations || 'N/A'}`, rightCol + 35, yPos);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Converged:`, rightCol, yPos + 8);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.converged ? 'Yes' : 'No'}`, rightCol + 35, yPos + 8);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Singular Value:`, rightCol, yPos + 16);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.s.toFixed(4)}`, rightCol + 35, yPos + 16);
                pdf.setFont(undefined, 'normal');

                // Experiment Description Section
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Analysis Overview', 20, 145);
                
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(10);
                
                // Experiment description text
                let descY = 155;
                const descText = [
                    `This SSVD analysis was performed on a ${P} Ã— ${N} data matrix to identify sparse patterns`,
                    `in the first singular vector using L1 regularization with alpha = ${results.alpha.toFixed(4)}.`,
                    '',
                    `The algorithm detected ${results.detections} variables (${((results.detections/P)*100).toFixed(1)}% of total)`,
                    `that contribute to the primary singular vector pattern with singular value ${results.s.toFixed(2)}.`
                ];
                
                descText.forEach(line => {
                    if (line) {
                        pdf.text(line, 20, descY);
                    }
                    descY += 6;
                });
                
                // Analysis Method Box
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Method Details', 20, 195);
                
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(9);
                
                // Method info box
                pdf.setFillColor(245, 250, 255);
                pdf.rect(15, 200, 180, 45, 'FD');
                
                let methodY = 208;
                pdf.text('Algorithm: Sparse SVD Rank-1 (SSVD-R1) with iterative soft thresholding', 20, methodY);
                methodY += 7;
                pdf.text(`Regularization: L1 penalty with alpha = ${results.alpha.toFixed(6)}`, 20, methodY);
                methodY += 7;
                pdf.text(`Convergence: ${results.converged ? 'Yes' : 'No'} (${results.iterations} iterations)`, 20, methodY);
                methodY += 7;
                pdf.text(`Detection Threshold: |U| > 1e-8`, 20, methodY);
                methodY += 7;
                pdf.text(`Analysis Mode: ${analysisParams?.analysisType || 'Single Alpha'}`, 20, methodY);
                
                // Add a note about visualizations
                if (results.detections > 0) {
                    methodY += 10;
                    pdf.setFont(undefined, 'italic');
                    pdf.setFontSize(8);
                    pdf.setTextColor(100);
                    pdf.text('Note: Export charts separately for U1/V1 plots and solution submatrix heatmap visualizations.', 20, methodY);
                }

                const filename = `SSVD1x_Report_${timestamp}.pdf`;
                pdf.save(filename);
                console.log('âœ… PDF report generated:', filename);
            } catch (error) {
                console.error('Error generating PDF report:', error);
                alert('Error generating PDF report. Please try again.');
            }
        };

        // Unified Export Function
        const exportAllFormats = async (results, matrix, matrixInfo, analysisParams) => {
            try {
                console.log('ðŸ“¦ Starting comprehensive export...');

                // Export CSVs
                exportDetectedRowsCSV(results, matrix, matrixInfo);
                setTimeout(() => exportV1ScoresCSV(results, matrixInfo), 200);
                setTimeout(() => exportAnalysisParametersCSV(results, matrixInfo, analysisParams), 400);

                // Export JSON
                setTimeout(() => exportAnalysisStateJSON(results, matrix, matrixInfo, analysisParams), 600);
                
                // Export Charts
                setTimeout(() => exportChartsAsImages(), 800);

                // Export PDF
                setTimeout(() => generatePDFReport(results, matrix, matrixInfo, analysisParams), 1000);
                
                console.log('ðŸ“¦ All exports initiated successfully');
            } catch (error) {
                console.error('Error in comprehensive export:', error);
                alert('Error during export process. Some files may not have been generated.');
            }
        };

        // SSVD Results Display Components
        const SSVDResultsDisplay = ({ results, matrixInfo, matrix, onNewAnalysis, onResetToOriginal, onRerunWithAlpha }) => {
            if (!results) return null;
            
            // Export UI state
            const [showExportMenu, setShowExportMenu] = useState(false);
            
            // Individual export handlers that use the new comprehensive functions
            const handleExportDetectedRows = () => {
                console.log('Export Detected Rows clicked. Results:', results, 'Matrix:', matrix?.length, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportDetectedRowsCSV(results, matrix, matrixInfo);
                setShowExportMenu(false);
            };

            const handleExportV1Scores = () => {
                console.log('Export V1 Scores clicked. Results:', results, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportV1ScoresCSV(results, matrixInfo);
                setShowExportMenu(false);
            };

            const handleExportParameters = () => {
                console.log('Export Parameters clicked. Results:', results, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportAnalysisParametersCSV(results, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            const handleExportCharts = async () => {
                try {
                    await exportChartsAsImages();
                    setShowExportMenu(false);
                } catch (error) {
                    console.error('Export charts failed:', error);
                    alert('Failed to export charts: ' + error.message);
                }
            };
            
            const handleExportJSON = () => {
                exportAnalysisStateJSON(results, matrix, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            const handleExportPDF = () => {
                generatePDFReport(results, matrix, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            const handleExportAll = () => {
                exportAllFormats(results, matrix, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            return (
                <div className="space-y-6 mt-6">
                    {/* Summary Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="mb-4 flex justify-between items-center">
                            <h2 className="text-xl font-semibold">Summary of Results</h2>
                            <div className="relative">
                                <button
                                    onClick={() => {
                                        console.log('Export button clicked, current showExportMenu:', showExportMenu);
                                        setShowExportMenu(!showExportMenu);
                                    }}
                                    className="bg-gradient-to-r from-green-600 to-blue-600 hover:from-green-700 hover:to-blue-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                    title="Export analysis results in multiple formats"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                    </svg>
                                    Export Results
                                    <svg className={`w-4 h-4 transition-transform ${showExportMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                    </svg>
                                </button>
                                
                                {showExportMenu && (
                                    <div className="absolute right-0 mt-2 w-64 bg-white rounded-lg shadow-xl border border-gray-200 z-50">
                                        <div className="p-3 border-b border-gray-200">
                                            <h3 className="text-sm font-semibold text-gray-800">Export Options</h3>
                                            <p className="text-xs text-gray-600">Alpha = {results?.alpha?.toFixed(4) || 'N/A'}</p>
                                        </div>
                                        <div className="p-2 space-y-1">
                                            <button
                                                onClick={handleExportDetectedRows}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-blue-600">ðŸ“Š</span>
                                                Detected Rows (CSV)
                                            </button>
                                            <button
                                                onClick={handleExportV1Scores}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-indigo-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-indigo-600">ðŸ“‰</span>
                                                V1 Scores (CSV)
                                            </button>
                                            <button
                                                onClick={handleExportParameters}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-green-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-green-600">âš™ï¸</span>
                                                Analysis Parameters (CSV)
                                            </button>
                                            <button
                                                onClick={handleExportCharts}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-purple-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-purple-600">ðŸ“ˆ</span>
                                                Charts (PNG)
                                            </button>
                                            <button
                                                onClick={handleExportJSON}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-orange-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-orange-600">ðŸ”¢</span>
                                                Complete State (JSON)
                                            </button>
                                            <button
                                                onClick={handleExportPDF}
                                                className="w-full text-left px-3 py-2 text-sm hover:bg-red-50 rounded-md flex items-center gap-2"
                                            >
                                                <span className="text-red-600">ðŸ“„</span>
                                                Report (PDF)
                                            </button>
                                            <div className="border-t border-gray-200 pt-2 mt-2">
                                                <button
                                                    onClick={handleExportAll}
                                                    className="w-full text-left px-3 py-2 text-sm bg-gradient-to-r from-green-50 to-blue-50 hover:from-green-100 hover:to-blue-100 rounded-md flex items-center gap-2 font-medium"
                                                >
                                                    <span className="text-indigo-600">ðŸ“¦</span>
                                                    Export All Formats
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                        <div className={`grid grid-cols-1 ${results.eFDR !== undefined ? 'md:grid-cols-5' : 'md:grid-cols-4'} gap-4 mb-6`}>
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <div className="text-sm text-blue-600 font-medium">Alpha Value</div>
                                <div className="text-2xl font-bold text-blue-900">{results.alpha.toFixed(4)}</div>
                                <div className="text-xs text-blue-600">sparsity parameter</div>
                            </div>
                            {results.eFDR !== undefined && (
                                <div className="bg-yellow-50 p-4 rounded-lg">
                                    <div className="text-sm text-yellow-600 font-medium">eFDR</div>
                                    <div className="text-2xl font-bold text-yellow-900">{results.eFDR.toFixed(2)}%</div>
                                    <div className="text-xs text-yellow-600">false discovery rate</div>
                                </div>
                            )}
                            <div className="bg-green-50 p-4 rounded-lg">
                                <div className="text-sm text-green-600 font-medium">Detections</div>
                                <div className="text-2xl font-bold text-green-900">{results.detections}</div>
                                <div className="text-xs text-green-600">out of {results.u.length}</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg">
                                <div className="text-sm text-purple-600 font-medium">Sparsity</div>
                                <div className="text-2xl font-bold text-purple-900">{results.sparsity}%</div>
                                <div className="text-xs text-purple-600">non-zero loadings</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg">
                                <div className="text-sm text-orange-600 font-medium">Iterations</div>
                                <div className="text-2xl font-bold text-orange-900">{results.iterations || 'N/A'}</div>
                                <div className="text-xs text-orange-600">{results.converged ? 'Converged' : 'Max iterations reached'}</div>
                            </div>
                        </div>
                    </div>
                    
                    {/* U1 Vector Visualization */}
                    <U1VectorPlot u={results.u} alpha={results.alpha} detectedIndices={results.detectedIndices} />
                    
                    {/* V1 Vector Visualization */}
                    <V1VectorPlot v={results.v} s={results.s} />
                    
                    {/* Solution Submatrix Heatmap */}
                    <HeatmapChart ssvdResults={results} matrix={matrix} analysisMode={results.fromAnalysisStep || 'single'} />
                </div>
            );
        };
        
        // U1 Vector Scatter Plot Component
        const U1VectorPlot = ({ u, alpha, detectedIndices }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || !u) return;
                
                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                
                // Prepare data for scatter plot
                const data = u.map((val, idx) => ({
                    x: idx + 1,
                    y: val
                }));
                
                // Separate detected and undetected points using stored indices
                const detectedSet = new Set(detectedIndices || []);
                const detectedPoints = data.filter(p => detectedSet.has(p.x - 1)); // Convert back to 0-based for comparison
                const undetectedPoints = data.filter(p => !detectedSet.has(p.x - 1));
                
                chartRef.current = new Chart(canvasRef.current, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: `Detected (${detectedPoints.length})`,
                                data: detectedPoints,
                                backgroundColor: 'rgba(34, 197, 94, 0.6)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                pointRadius: 4
                            },
                            {
                                label: `Undetected (${undetectedPoints.length})`,
                                data: undetectedPoints,
                                backgroundColor: 'rgba(156, 163, 175, 0.3)',
                                borderColor: 'rgba(156, 163, 175, 0.5)',
                                pointRadius: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `U1 Vector - Sparse Biomarker Detection (Î± = ${alpha.toFixed(4)})`
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Row Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'U1 Value'
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [u, alpha]);
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Sparse Left-Singular Vector U1</h3>
                    <div className="h-80">
                        <canvas ref={canvasRef}></canvas>
                    </div>
                </div>
            );
        };
        
        // V1 Vector Line Plot Component - Enhanced with sorted scores
        const V1VectorPlot = ({ v, s }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            const canvasRef2 = useRef(null);
            const chartRef2 = useRef(null);

            // Create sorted version of V1 with indices
            const sortedV1Data = useMemo(() => {
                if (!v) return null;
                // Create array of {value, originalIndex} pairs
                const indexed = v.map((value, idx) => ({ value, originalIndex: idx }));
                // Sort by value (ascending)
                const sorted = [...indexed].sort((a, b) => a.value - b.value);
                return {
                    sortedValues: sorted.map(item => item.value),
                    sortedIndices: sorted.map(item => item.originalIndex),
                    originalIndices: sorted.map((_, idx) => idx + 1) // 1-based for display
                };
            }, [v]);

            // Original V1 plot
            useEffect(() => {
                if (!canvasRef.current || !v) return;

                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                chartRef.current = new Chart(canvasRef.current, {
                    type: 'line',
                    data: {
                        labels: v.map((_, idx) => idx + 1),
                        datasets: [{
                            label: `V1 Vector (Ïƒ = ${s.toFixed(4)})`,
                            data: v,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Dense Right-Singular Vector V1 (Original Order)'
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Sample Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'V1 Value'
                                }
                            }
                        }
                    }
                });

                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [v, s]);

            // Sorted V1 plot with quartile lines
            useEffect(() => {
                if (!canvasRef2.current || !sortedV1Data) return;

                // Destroy existing chart
                if (chartRef2.current) {
                    chartRef2.current.destroy();
                }

                // Calculate quartile positions
                const n = sortedV1Data.sortedValues.length;
                const q1Position = Math.floor(n * 0.25);
                const q2Position = Math.floor(n * 0.50);
                const q3Position = Math.floor(n * 0.75);

                // Store quartile positions globally for heatmap use
                if (window) {
                    window.v1QuartilePositions = {
                        q1: q1Position,
                        q2: q2Position,
                        q3: q3Position,
                        total: n
                    };
                }

                chartRef2.current = new Chart(canvasRef2.current, {
                    type: 'line',
                    data: {
                        labels: sortedV1Data.originalIndices,
                        datasets: [{
                            label: `Sorted V1 Scores (Ïƒ = ${s.toFixed(4)})`,
                            data: sortedV1Data.sortedValues,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'V1 Scores Sorted (Ascending) with Quartiles'
                            },
                            legend: {
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        const originalIdx = sortedV1Data.sortedIndices[context.dataIndex];
                                        return `Original Index: ${originalIdx + 1}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Rank (Sorted Position)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'V1 Score'
                                }
                            }
                        }
                    },
                    plugins: [{
                        afterDraw: function(chart) {
                            const ctx = chart.ctx;
                            const chartArea = chart.chartArea;

                            // Calculate quartile positions on the chart
                            const xScale = chart.scales.x;
                            const yScale = chart.scales.y;

                            const q1X = xScale.getPixelForValue(q1Position);
                            const q2X = xScale.getPixelForValue(q2Position);
                            const q3X = xScale.getPixelForValue(q3Position);

                            // Draw quartile lines
                            ctx.save();
                            ctx.setLineDash([5, 5]);
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.7;

                            // Q1 line (pink)
                            ctx.strokeStyle = 'rgba(220, 38, 127, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q1X, chartArea.top);
                            ctx.lineTo(q1X, chartArea.bottom);
                            ctx.stroke();

                            // Q2 line (purple)
                            ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q2X, chartArea.top);
                            ctx.lineTo(q2X, chartArea.bottom);
                            ctx.stroke();

                            // Q3 line (blue)
                            ctx.strokeStyle = 'rgba(59, 130, 246, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q3X, chartArea.top);
                            ctx.lineTo(q3X, chartArea.bottom);
                            ctx.stroke();

                            ctx.restore();
                        }
                    }]
                });

                return () => {
                    if (chartRef2.current) {
                        chartRef2.current.destroy();
                    }
                };
            }, [sortedV1Data, s]);

            // Export sorted indices for use by heatmap
            useEffect(() => {
                if (sortedV1Data && window) {
                    window.v1SortedIndices = sortedV1Data.sortedIndices;
                }
            }, [sortedV1Data]);

            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Dense Right-Singular Vector V1 Analysis</h3>
                    <div className="h-80 mb-6">
                        <canvas ref={canvasRef} data-chart-type="v1-original"></canvas>
                    </div>
                    <div className="h-80">
                        <canvas ref={canvasRef2} data-chart-type="v1-sorted"></canvas>
                    </div>
                </div>
            );
        };
        
        const App = () => {
            // Original data state
            const [originalMatrix, setOriginalMatrix] = useState(null);
            const [originalMatrixInfo, setOriginalMatrixInfo] = useState(null);
            const [originalStatistics, setOriginalStatistics] = useState(null);
            const [originalEigenvalues, setOriginalEigenvalues] = useState(null);
            
            // Working data state (can be original or preprocessed)
            const [matrix, setMatrix] = useState(null);
            const [matrixInfo, setMatrixInfo] = useState(null);
            const [statistics, setStatistics] = useState(null);
            const [eigenvalues, setEigenvalues] = useState(null);
            
            // Processing state
            // Preprocessing state removed
            
            // Analysis state
            const [fdrResults, setFDRResults] = useState(null);
            const [selectedAlpha, setSelectedAlpha] = useState(null);
            const [ssvdResults, setSSVDResults] = useState(null);
            const [showAnalysisPanel, setShowAnalysisPanel] = useState(false);
            const [analysisStep, setAnalysisStep] = useState(null); // null, 'single', 'multi', 'alpha', 'efdr'

            const handleDataLoaded = (newMatrix, newMatrixInfo) => {
                // Calculate SVD once for this matrix
                console.log('Calculating initial SVD for matrix...');
                const svdResult = svd1Sync(newMatrix);
                
                // Calculate alphaMax using the SVD result
                console.log('Calculating alphaMax from SVD...');
                const maxAbsU1 = Math.max(...svdResult.u.map(val => Math.abs(val)));
                const calculatedAlphaMax = 0.75 * maxAbsU1 * svdResult.s;
                
                // Add SVD results and alphaMax to matrixInfo
                const enrichedMatrixInfo = {
                    ...newMatrixInfo,
                    alphaMax: calculatedAlphaMax,
                    initialSVD: svdResult  // Cache the SVD for reuse
                };
                
                // Store both as original and working data
                setOriginalMatrix(newMatrix);
                setOriginalMatrixInfo(enrichedMatrixInfo);
                setMatrix(newMatrix);
                setMatrixInfo(enrichedMatrixInfo);
                
                // Calculate statistics for data review
                console.log('Calculating matrix statistics...');
                const stats = calculateMatrixStatistics(newMatrix);
                setOriginalStatistics(stats);
                setStatistics(stats);
                
                // Eigenvalue computation moved to external preprocessing
                console.log('Skipping eigenvalue computation for large matrix performance');
                setOriginalEigenvalues([]);
                setEigenvalues([]);
                
                console.log(`Data loaded: ${enrichedMatrixInfo.P}Ã—${enrichedMatrixInfo.N} matrix, alphaMax: ${calculatedAlphaMax.toFixed(6)}`);
            };

            const resetData = () => {
                console.log('Reset button clicked - clearing all data and results');
                
                // Reset original data
                setOriginalMatrix(null);
                setOriginalMatrixInfo(null);
                setOriginalStatistics(null);
                setOriginalEigenvalues(null);
                
                // Reset working data
                setMatrix(null);
                setMatrixInfo(null);
                setStatistics(null);
                setEigenvalues(null);
                
                // Reset ALL analysis state and results
                setFDRResults(null);
                setSelectedAlpha(null);
                setSSVDResults(null);
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                // Scroll to top to show upload page
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                console.log('All data and results cleared - returning to upload page');
            };
            
            const handleProceedToAnalysis = () => {
                // Clear any analysis results and start stepped selection
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setAnalysisStep(null); // Start at step 1: Single vs Multi
                setShowAnalysisPanel(true);
                
                // Smooth scroll to analysis section
                setTimeout(() => {
                    window.scrollTo({
                        top: document.documentElement.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
            };
            
            const handleAnalysisStepSelect = (step) => {
                setAnalysisStep(step);
            };
            
            const handleBackToDataReview = () => {
                setShowAnalysisPanel(false);
                setAnalysisStep(null);
            };
            
            
            const handleResetToOriginalData = () => {
                // Reset to original data
                setMatrix(originalMatrix);
                setMatrixInfo(originalMatrixInfo);
                setStatistics(originalStatistics);
                setEigenvalues(originalEigenvalues);
                
                // Clear ALL analysis results and go back to data review
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setFDRResults(null);
                setSelectedAlpha(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                console.log('Reset to original data for analysis');
            };
            
            const handleRerunWithAlpha = async (newAlpha) => {
                try {
                    console.log(`Re-running SSVD with alpha=${newAlpha}`);
                    const results = await runSingleAlphaAnalysis(newAlpha);
                    setAnalysisResults(results);
                    console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity`);
                } catch (error) {
                    console.error('Re-run failed:', error);
                    alert(`Failed to re-run analysis: ${error.message}`);
                }
            };
            
            const handleCancelAnalysis = () => {
                setShowAnalysisPanel(false);
            };
            
            const [isRunningAnalysis, setIsRunningAnalysis] = useState(false);
            const [analysisProgress, setAnalysisProgress] = useState({ current: 0, total: 0, message: '' });
            const [isAnalysisCancelled, setIsAnalysisCancelled] = useState(false);
            const [analysisResults, setAnalysisResults] = useState(null);
            const [alphaSequenceResults, setAlphaSequenceResults] = useState(null);
            const [selectedAlphaIndex, setSelectedAlphaIndex] = useState(null);

            // Ref for auto-scrolling to progress indicator
            const progressIndicatorRef = useRef(null);
            
            const runSingleAlphaAnalysis = async (alpha) => {
                console.log(`Running SSVD with alpha=${alpha}, using cached SVD: ${matrixInfo?.initialSVD ? 'yes' : 'no'}`);
                console.log(`SSVD Parameters: maxIter=1000, tolerance=0.001`);
                const startTime = performance.now();
                const results = await SSVDR1Algorithm({
                    matrix: matrix,
                    alpha: alpha,
                    maxIter: 1000,
                    tolerance: 0.001,
                    initialSVD: matrixInfo?.initialSVD  // Pass cached SVD
                });
                const endTime = performance.now();
                const elapsedSeconds = (endTime - startTime) / 1000;
                console.log(`SSVD completed in ${elapsedSeconds.toFixed(2)}s with ${results.iterations} iterations`);

                // Format elapsed time for display
                const formatElapsedTime = (seconds) => {
                    if (seconds < 60) {
                        return `${seconds.toFixed(1)}s`;
                    } else if (seconds < 3600) {
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = Math.floor(seconds % 60);
                        return `${minutes}m ${remainingSeconds}s`;
                    } else {
                        const hours = Math.floor(seconds / 3600);
                        const minutes = Math.floor((seconds % 3600) / 60);
                        return `${hours}h ${minutes}m`;
                    }
                };
                const elapsedTimeFormatted = formatElapsedTime(elapsedSeconds);
                
                // Calculate detected indices and summary statistics
                const detectedIndices = [];
                results.u.forEach((val, idx) => {
                    if (Math.abs(val) > 1e-8) {
                        detectedIndices.push(idx);
                    }
                });
                const detections = detectedIndices.length;
                // Sparsity = percentage of non-zero loadings in u1
                const sparsity = (detections / matrix.length * 100).toFixed(1);
                
                return {
                    mode: 'single',
                    alpha: alpha,
                    u: results.u,
                    v: results.v,
                    s: results.s,
                    detections: detections,
                    detectedIndices: detectedIndices,
                    sparsity: sparsity,
                    iterations: results.iterations,
                    converged: results.converged,
                    convergenceInfo: results.convergenceInfo,
                    elapsedTime: elapsedTimeFormatted,
                    parameters: {
                        analysisType: 'single',
                        alpha: alpha,
                        matrixSize: `${matrix.length} Ã— ${matrix[0].length}`
                    }
                };
            };
            
            const handleStartAnalysis = async (config) => {
                console.log('Starting analysis with config:', config);
                console.log('ðŸ”„ Setting isRunningAnalysis to TRUE');
                setIsRunningAnalysis(true);
                setIsAnalysisCancelled(false);
                setAnalysisProgress({ current: 0, total: 0, message: 'Initializing analysis...' });
                // Keep panel visible for single alpha (combined view), keep visible for multi-alpha during analysis
                // Note: Multi-alpha analysis should show configuration panel during analysis
                if (config.analysisMode !== 'single' && config.analysisMode !== 'multi') {
                    setShowAnalysisPanel(false);
                }

                // Small delay to ensure UI renders before starting intensive computation
                await new Promise(resolve => setTimeout(resolve, 100));

                // Auto-scroll to progress indicator for N-alpha and eFDR analysis
                if (config.analysisMode === 'multi' || config.analysisMode === 'efdr') {
                    setTimeout(() => {
                        if (progressIndicatorRef.current) {
                            progressIndicatorRef.current.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                    }, 200); // Give a bit more time for UI to render
                }
                
                try {
                    if (config.analysisMode === 'single') {
                        // Single alpha analysis
                        const results = await runSingleAlphaAnalysis(config.alpha);
                        setAnalysisResults(results);
                        console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity, ${results.iterations} iterations`);
                    } else if (config.analysisMode === 'multi') {
                        // Multi-alpha analysis
                        const alphaValues = [];
                        const results = [];
                        
                        // Generate alpha sequence
                        for (let i = 0; i < config.Nalpha; i++) {
                            const alpha = config.alpha0 + (config.alphaMax - config.alpha0) * i / (config.Nalpha - 1);
                            alphaValues.push(alpha);
                        }
                        
                        // Set progress tracking
                        const totalSteps = config.analysisType === 'efdr' ? config.Nalpha + (config.Nalpha * config.Nperm) : config.Nalpha;
                        setAnalysisProgress({ current: 0, total: totalSteps, message: 'Starting alpha sequence analysis...' });
                        
                        // Run SSVD for each alpha
                        for (let i = 0; i < alphaValues.length; i++) {
                            // Check for cancellation
                            if (isAnalysisCancelled) {
                                console.log('Analysis cancelled by user');
                                return;
                            }
                            
                            const alpha = alphaValues[i];
                            console.log(`Running SSVD ${i+1}/${alphaValues.length}: alpha=${alpha.toFixed(4)}`);
                            
                            setAnalysisProgress({ 
                                current: i + 1, 
                                total: totalSteps, 
                                message: `Alpha ${i + 1}/${alphaValues.length}: Î±=${alpha.toFixed(4)}` 
                            });
                            
                            // Small delay to make progress visible
                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            const result = await SSVDR1Algorithm({
                                matrix: matrix,
                                alpha: alpha,
                                maxIter: 1000,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                tolerance: 0.001
                            });
                            
                            // Calculate detected indices and count
                            const detectedIndices = [];
                            result.u.forEach((val, idx) => {
                                if (Math.abs(val) > 1e-8) {
                                    detectedIndices.push(idx);
                                }
                            });
                            const detections = detectedIndices.length;
                            
                            // Calculate sparsity percentage (percentage of non-zero loadings in u1)
                            const sparsity = (detections / matrix.length * 100).toFixed(1);
                            
                            results.push({
                                index: i,  // Use 0-based indexing for consistency
                                alpha: alpha,
                                detections: detections,
                                detectedIndices: detectedIndices,
                                sparsity: parseFloat(sparsity), // Store as number
                                iterations: result.iterations,
                                converged: result.converged,
                                u: result.u,
                                v: result.v,
                                s: result.s
                            });
                        }
                        
                        // Calculate detection gradients (simple difference, not rate)
                        for (let i = 0; i < results.length; i++) {
                            if (i === 0) {
                                results[i].gradient = 0;
                            } else {
                                results[i].gradient = results[i].detections - results[i-1].detections;
                            }
                        }
                        
                        // Don't set results yet if we're doing eFDR analysis
                        if (config.analysisType === 'alpha') {
                            // Alpha-only analysis - set results immediately
                            setAlphaSequenceResults({
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    matrixSize: `${matrix.length} Ã— ${matrix[0].length}`
                                }
                            });
                        }
                        
                        // Run eFDR if requested
                        if (config.analysisType === 'efdr') {
                            console.log('Running eFDR analysis...');
                            // Start keep-alive system and progress sync for long-running eFDR analysis
                            startKeepAlive();
                            startProgressSync();

                            // Expose setAnalysisProgress globally for background sync
                            window.setProgress = (progress) => setAnalysisProgress(progress);

                            const fdrResults = await runFDRAnalysisEnhanced({
                                matrix: matrix,
                                alpha0: config.alpha0,
                                alphaMax: config.alphaMax,
                                Nalpha: config.Nalpha,
                                Nperm: config.Nperm,
                                nsupp: config.nsupp,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                isCancelled: () => isAnalysisCancelled,  // Pass cancellation check
                                onProgress: (current, total, message) => {
                                    const adjustedCurrent = config.Nalpha + current - 1; // Offset for alpha sequence completion
                                    setAnalysisProgress({
                                        current: adjustedCurrent,
                                        total: totalSteps,
                                        message: `eFDR: ${message}`
                                    });
                                    console.log(`FDR Progress: ${current}/${total} - ${message}`);
                                    // Save progress periodically for large analyses
                                    if (current % 5 === 0) {
                                        saveFDRProgress({
                                            current: adjustedCurrent,
                                            total: totalSteps,
                                            message: `eFDR: ${message}`,
                                            config
                                        });
                                    }
                                }
                            });
                            
                            console.log('FDR Results received:', fdrResults);
                            console.log('FDR Values:', fdrResults.fdrValues);
                            console.log('FDR Results structure:', Object.keys(fdrResults));
                            
                            if (!fdrResults.fdrValues) {
                                console.error('ERROR: fdrResults.fdrValues is undefined!');
                                console.error('Available keys:', Object.keys(fdrResults));
                                alert('eFDR analysis failed: No FDR values returned');
                                return;
                            }
                            
                            // Merge FDR results with alpha results
                            for (let i = 0; i < results.length; i++) {
                                results[i].eFDR = fdrResults.fdrValues[i] ?? 100;  // Default to 100% if undefined
                                console.log(`Result ${i}: alpha=${results[i].alpha}, eFDR=${results[i].eFDR}`);
                            }
                            
                            console.log('Updating state with eFDR results...');
                            console.log('Final results array length:', results.length);
                            console.log('Sample result with eFDR:', results[0]);
                            
                            const finalResultsObject = {
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,  // This now includes eFDR values
                                hasFDR: true,
                                fdrResults: fdrResults,
                                Nperm: config.Nperm,  // Add Nperm for display
                                totalRuns: fdrResults.totalRuns,
                                pi0: fdrResults.pi0,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    Nperm: config.Nperm,
                                    nsupp: config.nsupp,
                                    matrixSize: `${matrix.length} Ã— ${matrix[0].length}`
                                }
                            };
                            
                            // Capture elapsed time before clearing progress
                            const progressData = loadFDRProgress();
                            const elapsedTime = progressData?.elapsedTimeFormatted || null;

                            // Add elapsed time to results
                            finalResultsObject.elapsedTime = elapsedTime;

                            console.log('Setting final results object:', finalResultsObject);
                            setAlphaSequenceResults(finalResultsObject);
                            console.log('âœ… eFDR state update complete');
                        }

                        console.log(`ðŸŽ‰ Alpha sequence complete: ${config.Nalpha} values tested`);
                        clearFDRProgress(true); // Clear saved progress and report final time
                    }
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert(`Analysis failed: ${error.message}`);
                } finally {
                    console.log('âœ… Setting isRunningAnalysis to FALSE');
                    setIsRunningAnalysis(false);
                    setIsAnalysisCancelled(false);
                    setAnalysisProgress({ current: 0, total: 0, message: '' });
                    stopKeepAlive(); // Stop keep-alive system
                    stopProgressSync(); // Stop progress sync system
                    window.setProgress = null; // Clean up global reference
                    // Force UI refresh to clear any stuck progress indicators
                    setTimeout(() => {
                        setIsRunningAnalysis(false);
                    }, 100);
                }
            };

            const cancelAnalysis = () => {
                console.log('ðŸ›‘ User requested analysis cancellation');
                setIsAnalysisCancelled(true);
                setAnalysisProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            // Debug logging
            useEffect(() => {
                console.log('App State:', {
                    hasOriginalMatrix: !!originalMatrix,
                    hasOriginalStats: !!originalStatistics,
                    hasOriginalEigenvalues: !!originalEigenvalues,
                    showAnalysisPanel,
                    isRunningAnalysis
                });
            }, [originalMatrix, originalStatistics, originalStatistics, showAnalysisPanel, isRunningAnalysis]);
            
            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Main Content */}
                    <div className="max-w-7xl mx-auto px-6 py-8">
                        {/* CSV Upload Component */}
                        {!originalMatrix && <CSVUploader onDataLoaded={handleDataLoaded} />}

                        {/* Matrix Data Review - Show only when no analysis results exist */}
                        {originalMatrix && originalStatistics && !showAnalysisPanel && !analysisResults && !alphaSequenceResults && (
                            <MatrixDataReview
                                matrix={originalMatrix}
                                matrixInfo={originalMatrixInfo}
                                statistics={originalStatistics}
                                onProceedToAnalysis={handleProceedToAnalysis}
                                onReset={resetData}
                            />
                        )}
                        
                        
                        {/* Analysis Selection Steps */}
                        {matrix && matrixInfo && showAnalysisPanel && !isRunningAnalysis && !analysisResults && !alphaSequenceResults && (
                            <AnalysisSelectionSteps
                                analysisStep={analysisStep}
                                onStepSelect={handleAnalysisStepSelect}
                                onBackToReview={handleBackToDataReview}
                            />
                        )}
                        
                        {/* Parameter Configuration for Selected Analysis Type */}
                        {matrix && matrixInfo && showAnalysisPanel && analysisStep === 'single' && (
                            <>
                                <AnalysisConfigurationPanel
                                    matrix={matrix}
                                    matrixInfo={matrixInfo}
                                    analysisStep={analysisStep}
                                    onStartAnalysis={handleStartAnalysis}
                                    onCancel={() => {
                                        setAnalysisStep(null);
                                        setAnalysisResults(null);
                                        setAlphaSequenceResults(null);
                                    }}
                                />
                                {/* Show progress when running single-alpha */}
                                {isRunningAnalysis && (
                                    <div className="bg-white rounded-lg shadow-md p-6 mt-6">
                                        <div className="flex flex-col items-center justify-center">
                                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                            <p className="text-gray-600">Running SSVD Analysis...</p>
                                        </div>
                                    </div>
                                )}
                                {/* Show results when not running */}
                                {!isRunningAnalysis && analysisResults && analysisResults.mode === 'single' && (
                                    <SSVDResultsDisplay 
                                        results={analysisResults}
                                        matrixInfo={matrixInfo}
                                        matrix={matrix}
                                        onNewAnalysis={() => {
                                            setAnalysisResults(null);
                                        }}
                                        onResetToOriginal={resetData}
                                        onRerunWithAlpha={handleRerunWithAlpha}
                                    />
                                )}
                            </>
                        )}
                        
                        {/* Multi-alpha configuration - keep visible during N-Alpha and eFDR analysis */}
                        {matrix && matrixInfo && showAnalysisPanel && (!isRunningAnalysis || analysisStep === 'efdr' || analysisStep === 'alpha') && !analysisResults && !alphaSequenceResults && (analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <AnalysisConfigurationPanel
                                matrix={matrix}
                                matrixInfo={matrixInfo}
                                analysisStep={analysisStep}
                                isRunningAnalysis={isRunningAnalysis && (analysisStep === 'efdr' || analysisStep === 'alpha')}
                                onStartAnalysis={handleStartAnalysis}
                                onCancel={() => setAnalysisStep(null)}
                            />
                        )}
                        
                        {/* Analysis Running Indicator - for multi-alpha only */}
                        {isRunningAnalysis && analysisStep !== 'single' && (
                            <div ref={progressIndicatorRef} className="bg-white rounded-lg shadow-md p-8">
                                <div className="flex flex-col items-center justify-center">
                                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                    <h3 className="text-lg font-semibold text-gray-700 mb-4">
                                        {analysisStep === 'efdr' ? 'Running eFDR Analysis' : 'Running N-Alpha Analysis'}
                                    </h3>
                                    {console.log('ðŸŽ¯ PROGRESS BAR RENDERING:', { isRunningAnalysis, analysisProgress })}
                                    
                                    {/* Enhanced Progress Bar with System Monitoring */}
                                    {analysisProgress.total > 0 && (
                                        <div className="w-full max-w-2xl mb-4">
                                            <div className="flex justify-between text-sm text-gray-600 mb-2">
                                                <span>Progress: {analysisProgress.current}/{analysisProgress.total}</span>
                                                <div className="flex space-x-4">
                                                    <span>{Math.round((analysisProgress.current / analysisProgress.total) * 100)}%</span>
                                                    {(() => {
                                                        const stored = loadFDRProgress();
                                                        return stored ? (
                                                            <div className="flex space-x-3">
                                                                {stored.elapsedTimeFormatted && (
                                                                    <span className="text-green-600">Elapsed: {stored.elapsedTimeFormatted}</span>
                                                                )}
                                                                {stored.estimatedTimeRemaining && (
                                                                    <span className="text-blue-600">ETA: {stored.estimatedTimeRemaining}</span>
                                                                )}
                                                            </div>
                                                        ) : null;
                                                    })()}
                                                </div>
                                            </div>
                                            <div className="w-full bg-gray-200 rounded-full h-3">
                                                <div
                                                    className={`h-3 rounded-full transition-all duration-300 ease-out ${
                                                        analysisStep === 'efdr' ? 'bg-yellow-600' : 'bg-indigo-600'
                                                    }`}
                                                    style={{ width: `${Math.min((analysisProgress.current / analysisProgress.total) * 100, 100)}%` }}
                                                ></div>
                                            </div>

                                            {/* System Resource Monitoring */}
                                            {(() => {
                                                const resources = getSystemResources();
                                                return (
                                                    <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                                        <div className="grid grid-cols-2 gap-4 text-xs">
                                                            <div>
                                                                <div className="font-medium text-blue-700 mb-1">System Resources</div>
                                                                {resources.memory.used && (
                                                                    <div className="flex justify-between text-blue-600">
                                                                        <span>Memory:</span>
                                                                        <span>{resources.memory.used}MB / {resources.memory.limit}MB</span>
                                                                    </div>
                                                                )}
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>CPU Cores:</span>
                                                                    <span>{resources.browser.hardwareConcurrency}</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Browser:</span>
                                                                    <span>{resources.browser.userAgent}</span>
                                                                </div>
                                                            </div>
                                                            <div>
                                                                <div className="font-medium text-blue-700 mb-1">Performance</div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Web Worker:</span>
                                                                    <span className="text-green-600">âœ“ Active</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Tab Throttling:</span>
                                                                    <span className="text-green-600">âœ“ Protected</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Progress Sync:</span>
                                                                    <span className="text-green-600">âœ“ Background</span>
                                                                </div>
                                                                {(() => {
                                                                    const stored = loadFDRProgress();
                                                                    if (stored && stored.elapsedTimeFormatted) {
                                                                        return (
                                                                            <div className="flex justify-between text-blue-600 border-t border-blue-200 pt-1 mt-1">
                                                                                <span>Runtime:</span>
                                                                                <span className="text-green-600">{stored.elapsedTimeFormatted}</span>
                                                                            </div>
                                                                        );
                                                                    }
                                                                    return null;
                                                                })()}
                                                            </div>
                                                        </div>
                                                        <div className="mt-2 text-xs text-blue-500 text-center">
                                                            ðŸ’¡ Analysis continues at full speed even when tab is in background
                                                        </div>
                                                    </div>
                                                );
                                            })()}
                                        </div>
                                    )}

                                    <div className="w-full max-w-2xl">
                                        <p className="text-sm font-medium text-gray-700 text-center mb-2">
                                            {analysisProgress.message || 'Initializing analysis...'}
                                        </p>
                                        {analysisStep === 'efdr' && analysisProgress.message && analysisProgress.message.includes('Permutation') && (
                                            <p className="text-xs text-gray-500 text-center">
                                                Running permutations to estimate false discovery rate
                                            </p>
                                        )}
                                        {analysisStep === 'efdr' && analysisProgress.message && analysisProgress.message.includes('Original run') && (
                                            <p className="text-xs text-gray-500 text-center">
                                                Computing sparse solution for original matrix
                                            </p>
                                        )}

                                        {/* Cancel Button with Confirmation */}
                                        <div className="flex justify-center mt-4">
                                            <button
                                                onClick={() => {
                                                    const progress = Math.round((analysisProgress.current / analysisProgress.total) * 100);
                                                    const confirmMessage = `Cancel eFDR analysis?\n\nProgress: ${progress}% complete (${analysisProgress.current}/${analysisProgress.total})\n\nThis will stop the analysis and you'll lose current progress. The analysis may take a long time to reach this point again.\n\nAre you sure you want to cancel?`;

                                                    if (confirm(confirmMessage)) {
                                                        console.log('ðŸ›‘ User confirmed eFDR analysis cancellation');
                                                        setIsAnalysisCancelled(true);
                                                        setAnalysisProgress(prev => ({
                                                            ...prev,
                                                            message: 'Cancelling analysis... (Web Worker stopping)'
                                                        }));
                                                        // Also signal the Web Worker to stop
                                                        if (fdrWorker) {
                                                            console.log('Sending cancel signal to Web Worker');
                                                        }
                                                    } else {
                                                        console.log('User cancelled the cancellation - continuing analysis');
                                                    }
                                                }}
                                                className={`px-6 py-2 rounded-md font-medium transition-colors ${
                                                    isAnalysisCancelled
                                                        ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                                                        : 'bg-red-600 text-white hover:bg-red-700'
                                                }`}
                                                disabled={isAnalysisCancelled}
                                            >
                                                {isAnalysisCancelled ? 'Cancelling...' : 'Cancel Analysis'}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Results Table */}
                        {originalMatrix && alphaSequenceResults && (
                            <>
                                <AlphaSequenceResultsDisplay 
                                    results={alphaSequenceResults}
                                    selectedIndex={selectedAlphaIndex}
                                    onSelectAlpha={(index) => {
                                        console.log('Alpha row selected, index:', index);
                                        setSelectedAlphaIndex(index);
                                        console.log('Selected alpha index state updated to:', index);
                                    }}
                                    onRunSingleAlpha={async (alpha) => {
                                        console.log('Chart selection for Î± =', alpha);

                                        // Check if we have pre-computed results for this alpha
                                        const preComputed = alphaSequenceResults?.results?.find(r => Math.abs(r.alpha - alpha) < 1e-10);
                                        if (preComputed) {
                                            console.log('âœ… Using pre-computed result (100x faster)');
                                            const singleResult = {
                                                mode: 'single',
                                                fromAnalysisStep: 'nalpha',  // Track it's from N-alpha
                                                alpha: preComputed.alpha,
                                                eFDR: preComputed.eFDR,  // Include eFDR if available
                                                u: preComputed.u,
                                                v: preComputed.v,
                                                s: preComputed.s,
                                                detections: preComputed.detections,
                                                detectedIndices: preComputed.detectedIndices,
                                                sparsity: preComputed.sparsity.toString(),
                                                iterations: preComputed.iterations,
                                                converged: preComputed.converged,
                                                parameters: {
                                                    analysisType: 'single',
                                                    alpha: preComputed.alpha,
                                                    matrixSize: `${matrix.length} Ã— ${matrix[0].length}`
                                                }
                                            };
                                            setAnalysisResults(singleResult);
                                            return;
                                        }

                                        // Fallback to running analysis if no pre-computed result found
                                        console.log('âŒ No pre-computed result found, running SSVD for Î± =', alpha);
                                        try {
                                            setIsRunningAnalysis(true);
                                            const singleResults = await runSingleAlphaAnalysis(alpha);
                                            setAnalysisResults(singleResults);
                                            console.log('Single alpha analysis complete:', singleResults);
                                        } catch (error) {
                                            console.error('Single alpha analysis failed:', error);
                                            alert(`Analysis failed: ${error.message}`);
                                        } finally {
                                            setIsRunningAnalysis(false);
                                        }
                                    }}
                                    onNewAnalysis={() => {
                                        // Clear ALL analysis results to go back to parameter selection
                                        setAlphaSequenceResults(null);
                                        setSelectedAlphaIndex(null);
                                        setAnalysisResults(null);
                                        setFDRResults(null);
                                        setSelectedAlpha(null);
                                        setShowAnalysisPanel(true);
                                    }}
                                    onResetToOriginal={resetData}
                                />
                                
                                {/* Show progress indicator when running single-alpha from N-alpha table */}
                                {isRunningAnalysis && (
                                    <div className="bg-white rounded-lg shadow-md p-6 mt-6">
                                        <div className="flex flex-col items-center justify-center">
                                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                            <p className="text-gray-600">Running SSVD Analysis...</p>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Show single-alpha results when selected from N-alpha table */}
                                {!isRunningAnalysis && analysisResults && analysisResults.mode === 'single' && (
                                    <SSVDResultsDisplay 
                                        results={analysisResults}
                                        matrixInfo={matrixInfo}
                                        matrix={matrix}
                                        onNewAnalysis={() => {
                                            setAnalysisResults(null);
                                        }}
                                        onResetToOriginal={resetData}
                                        onRerunWithAlpha={handleRerunWithAlpha}
                                    />
                                )}
                            </>
                        )}

                        {/* Old Matrix Information (temporary during transition) */}
                        {matrixInfo && !statistics && (
                            <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Matrix Information</h2>
                                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">{matrixInfo.P} Ã— {matrixInfo.N}</div>
                                        <div className="text-xs text-blue-600 mt-1">
                                            {matrixInfo.rowHeaders ? `${matrixInfo.P} features` : `P=${matrixInfo.P}`} Ã— {matrixInfo.columnHeaders ? `${matrixInfo.N} samples` : `N=${matrixInfo.N}`}
                                        </div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">File</div>
                                        <div className="text-lg font-bold text-purple-900 truncate">{matrixInfo.filename}</div>
                                        <div className="text-xs text-purple-600 mt-1">{(matrixInfo.fileSize / 1024).toFixed(1)} KB</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Format</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Gene Expression' : 
                                             matrixInfo.hasHeaders ? 'With Headers' : 'Pure Numeric'}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Row & column headers' :
                                             matrixInfo.rowHeaders ? 'Row headers detected' :
                                             matrixInfo.columnHeaders ? 'Column headers detected' :
                                             'No headers detected'}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Show sample headers if available */}
                                {(matrixInfo.rowHeaders || matrixInfo.columnHeaders) && (
                                    <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                                        <div className="text-sm text-gray-600">
                                            {matrixInfo.rowHeaders && (
                                                <div className="mb-2">
                                                    <span className="font-medium">Sample features: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.rowHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.rowHeaders.length > 5 && ` ... (${matrixInfo.rowHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                            {matrixInfo.columnHeaders && (
                                                <div>
                                                    <span className="font-medium">Sample names: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.columnHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.columnHeaders.length > 5 && ` ... (${matrixInfo.columnHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* FDR Analysis Panel - Only shown when user proceeds to analysis */}
                        {/* This will be implemented in Phase 4 */}

                        {/* Phase 3: FDR Results Display */}
                        {originalMatrix && fdrResults && <FDRResultsDisplay 
                            results={fdrResults} 
                            onAlphaSelected={setSelectedAlpha} 
                            selectedAlpha={selectedAlpha}
                            onRunSingleAlpha={async (alpha) => {
                                console.log('eFDR chart selection for Î± =', alpha);

                                // Check if we have pre-computed results for this alpha from eFDR
                                const preComputed = alphaSequenceResults?.results?.find(r => Math.abs(r.alpha - alpha) < 1e-10);
                                if (preComputed) {
                                    console.log('âœ… Using pre-computed eFDR result (100x faster)');
                                    const singleResult = {
                                        mode: 'single',
                                        alpha: preComputed.alpha,
                                        eFDR: preComputed.eFDR,  // Include eFDR if available
                                        u: preComputed.u,
                                        v: preComputed.v,
                                        s: preComputed.s,
                                        detections: preComputed.detections,
                                        detectedIndices: preComputed.detectedIndices,
                                        sparsity: preComputed.sparsity.toString(),
                                        iterations: preComputed.iterations,
                                        converged: preComputed.converged,
                                        parameters: {
                                            analysisType: 'single',
                                            alpha: preComputed.alpha,
                                            matrixSize: `${matrix.length} Ã— ${matrix[0].length}`
                                        }
                                    };
                                    setAnalysisResults(singleResult);
                                    return;
                                }

                                // Fallback to running analysis if no pre-computed result found
                                console.log('âŒ No pre-computed result found, running SSVD for Î± =', alpha);
                                try {
                                    setIsRunningAnalysis(true);
                                    const singleResults = await runSingleAlphaAnalysis(alpha);
                                    setAnalysisResults(singleResults);
                                    console.log('âœ… SSVD analysis complete:', singleResults);
                                } catch (error) {
                                    console.error('âŒ SSVD analysis failed:', error);
                                    alert(`Analysis failed: ${error.message}`);
                                } finally {
                                    setIsRunningAnalysis(false);
                                }
                            }}
                        />}
                    </div>
                </div>
            );
        };

        // Render the application
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>