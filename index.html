<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net; img-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net;">
    <title>SSVD1x - CSV Matrix Analysis - v2.0 Fixed SVD</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        .chart-container {
            background: linear-gradient(90deg, #f8fafc 0%, #f1f5f9 100%);
        }
    </style>
</head>

<body class="min-h-screen bg-gray-50">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef, createContext, useContext } = React;

        // ===================================================================
        // CORE ALGORITHMS COPIED FROM SSVD1 (PHASE 1)
        // ===================================================================

        // -------------------------------------------------------------------
        // 1. CORE MATRIX OPERATIONS
        // -------------------------------------------------------------------

        const matrixMultiply = function matrixMultiply(A, B) {
            if (!A.length || !B.length || A[0].length !== B.length) {
                throw new Error('Invalid matrix dimensions for multiplication');
            }
            const result = Array(A.length).fill().map(() => Array(B[0].length).fill(0));
            for (let i = 0; i < A.length; i++) {
                for (let j = 0; j < B[0].length; j++) {
                    for (let k = 0; k < B.length; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        };

        const transpose = function transpose(matrix) {
            if (!matrix.length || !matrix[0].length) return [];
            return matrix[0].map((_, i) => matrix.map(row => row[i]));
        };

        const norm = function norm(vector) {
            return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        };

        // -------------------------------------------------------------------
        // 2. STATISTICAL UTILITIES
        // -------------------------------------------------------------------

        const generateGaussianNoise = function generateGaussianNoise(variance) {
            const u1 = Math.random(), u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * Math.sqrt(variance);
        };

        const calculateMean = function calculateMean(array) {
            return array.reduce((sum, val) => sum + val, 0) / array.length;
        };

        const calculateVariance = function calculateVariance(array, mean = null) {
            const m = mean !== null ? mean : calculateMean(array);
            return array.reduce((sum, val) => sum + Math.pow(val - m, 2), 0) / array.length;
        };

        // -------------------------------------------------------------------
        // 3. MATRIX ROW PERMUTATION
        // -------------------------------------------------------------------

        const permuteMatrixRows = function permuteMatrixRows(matrix, fixedPattern = null) {
            if (fixedPattern) {
                // Use provided permutation pattern
                return fixedPattern.map(idx => matrix[idx]);
            }
            // Original random permutation of columns within each row
            const permuted = matrix.map(row => [...row]);
            for (let i = 0; i < permuted.length; i++) {
                for (let j = permuted[i].length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [permuted[i][j], permuted[i][k]] = [permuted[i][k], permuted[i][j]];
                }
            }
            return permuted;
        };

        // -------------------------------------------------------------------
        // 4. SOFT THRESHOLDING
        // -------------------------------------------------------------------

        const softThreshold = function softThreshold(x, alpha) {
            return Math.sign(x) * Math.max(Math.abs(x) - alpha, 0);
        };

        const calculateSparsity = function calculateSparsity(vector) {
            const nonZeros = vector.filter(x => Math.abs(x) > 1e-8).length;
            return vector.length > 0 ? (vector.length - nonZeros) / vector.length : 0;
        };

        // -------------------------------------------------------------------
        // 5. SVD IMPLEMENTATION (POWER ITERATION)
        // -------------------------------------------------------------------
        
        // SVD_v2.1_VALIDATED: Power iteration implementation with convergence criteria
        const simpleSVD = function simpleSVD(X) {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            const P = X.length;
            const N = X[0].length;

            // Use power iteration to find dominant singular vectors
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = norm(v);
            v = v.map(x => x / vNorm);
            let u = Array(P).fill(0);
            let prevSingularValue = 0;

            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 50; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += X[i][j] * v[j];
                    }
                }

                // Normalize u and get singular value
                const uNormValue = norm(u);
                if (uNormValue === 0) break;
                u = u.map(x => x / uNormValue);

                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += X[i][j] * u[i];
                    }
                }

                // Normalize v and get singular value
                vNorm = norm(v);
                if (vNorm === 0) break;
                v = v.map(x => x / vNorm);

                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-8) {
                    break;
                }
                prevSingularValue = vNorm;
            }

            // Final singular value computation
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * X[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };

        const svd1Sync = simpleSVD;
        const svd1 = async function(X) {
            await new Promise(resolve => setTimeout(resolve, 0));
            return simpleSVD(X);
        };
        
        // COMPUTE_ALL_SV_v2.0_NUMERICALLY_STABLE: Direct SVD decomposition for all singular values
        const computeAllSingularValues = (X) => {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            
            const P = X.length;
            const N = X[0].length;
            const numSingularValues = Math.min(P, N);
            
            console.log('Computing all singular values via direct SVD decomposition...');
            console.log(`Matrix dimensions: ${P} x ${N}, computing ${numSingularValues} singular values`);
            
            const singularValues = [];
            
            // Create working copy of matrix
            let workingMatrix = X.map(row => [...row]);
            
            // Use deflation to extract all singular values one by one
            for (let k = 0; k < numSingularValues; k++) {
                // Use power iteration to find dominant singular value
                const svdResult = performSingleSVD(workingMatrix);
                
                if (svdResult.s < 1e-12) {
                    console.log(`Singular value ${k+1} is effectively zero (${svdResult.s.toExponential(3)}), stopping deflation`);
                    // Fill remaining with zeros
                    for (let j = k; j < numSingularValues; j++) {
                        singularValues.push(0);
                    }
                    break;
                }
                
                singularValues.push(svdResult.s);
                
                // Deflate: subtract rank-1 approximation σ * u * v^T
                if (k < numSingularValues - 1) {
                    const currentP = workingMatrix.length;
                    const currentN = workingMatrix[0].length;
                    
                    for (let i = 0; i < currentP; i++) {
                        for (let j = 0; j < currentN; j++) {
                            workingMatrix[i][j] -= svdResult.s * svdResult.u[i] * svdResult.v[j];
                        }
                    }
                }
                
                if (k % 10 === 0 || k < 5) {
                    console.log(`Singular value ${k+1}: ${svdResult.s.toFixed(6)}`);
                }
            }
            
            // Sort in descending order
            singularValues.sort((a, b) => b - a);
            
            console.log(`Computed ${singularValues.length} singular values`);
            console.log('Largest 10 singular values:', singularValues.slice(0, 10).map(s => s.toFixed(6)));
            console.log('Singular value range:', singularValues[0]?.toFixed(6), 'to', singularValues[singularValues.length-1]?.toFixed(6));
            
            return singularValues;
        };
        
        // Perform single SVD to get dominant singular triplet (u, σ, v)
        const performSingleSVD = (matrix) => {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Initialize random right singular vector
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
            v = v.map(x => x / vNorm);
            
            let u = Array(P).fill(0);
            let prevSingularValue = 0;
            
            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 100; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += matrix[i][j] * v[j];
                    }
                }
                
                // Normalize u and get singular value estimate
                const uNorm = Math.sqrt(u.reduce((sum, x) => sum + x * x, 0));
                if (uNorm < 1e-15) break;
                u = u.map(x => x / uNorm);
                
                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += matrix[i][j] * u[i];
                    }
                }
                
                // Normalize v and get singular value
                vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
                if (vNorm < 1e-15) break;
                v = v.map(x => x / vNorm);
                
                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-10) {
                    break;
                }
                prevSingularValue = vNorm;
            }
            
            // Final singular value computation: σ = u^T * X * v
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * matrix[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };
        
        // Improved eigenvalue computation using iterative methods for symmetric matrices
        const computeEigenvalues = (A) => {
            const n = A.length;
            console.log('Computing eigenvalues using improved method for', n, 'x', n, 'matrix');
            
            const trace = A.reduce((sum, row, i) => sum + row[i], 0);
            console.log('Matrix trace:', trace.toFixed(2));
            
            // Use deflation method with power iteration for better accuracy
            const eigenvalues = [];
            let workingMatrix = A.map(row => [...row]);
            
            for (let k = 0; k < n; k++) {
                const eigenvalue = powerIterationEigenvalue(workingMatrix);
                
                if (eigenvalue < 1e-10) {
                    // Fill remaining with small positive values
                    const remaining = n - eigenvalues.length;
                    for (let i = 0; i < remaining; i++) {
                        eigenvalues.push(Math.max(1e-12, eigenvalue * Math.random()));
                    }
                    break;
                }
                
                eigenvalues.push(eigenvalue);
                
                // Deflate matrix by removing the contribution of this eigenvalue
                // Find corresponding eigenvector and deflate
                const eigenvector = powerIterationEigenvector(workingMatrix);
                
                // Deflate: A := A - λ * v * v^T
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        workingMatrix[i][j] -= eigenvalue * eigenvector[i] * eigenvector[j];
                    }
                }
                
                if (k % 10 === 0) {
                    console.log(`Computed eigenvalue ${k+1}: ${eigenvalue.toFixed(2)}`);
                }
            }
            
            console.log('Computed', eigenvalues.length, 'eigenvalues, largest =', eigenvalues[0]?.toFixed(2));
            console.log('Eigenvalue range:', Math.min(...eigenvalues).toFixed(2), 'to', Math.max(...eigenvalues).toFixed(2));
            
            return eigenvalues.sort((a, b) => b - a);
        };
        
        // Power iteration for largest eigenvalue of symmetric matrix
        const powerIterationEigenvalue = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            let lambda = 0;
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Compute eigenvalue estimate v^T * A * v
                const newLambda = v.reduce((sum, vi, i) => sum + vi * Av[i], 0);
                
                // Check convergence
                if (Math.abs(newLambda - lambda) < 1e-12) {
                    lambda = newLambda;
                    break;
                }
                lambda = newLambda;
                
                // Update v for next iteration
                v = Av;
            }
            
            return lambda;
        };
        
        // Power iteration for eigenvector corresponding to largest eigenvalue
        const powerIterationEigenvector = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Update v for next iteration
                v = Av;
            }
            
            // Final normalization
            const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
            if (norm > 1e-15) {
                v = v.map(x => x / norm);
            }
            
            return v;
        };
        
        // Wrapper function to compute eigenvalues (σ²) from singular values (σ) 
        const fullSVD = (matrix) => {
            // Step 1: Compute all singular values via direct SVD
            const singularValues = computeAllSingularValues(matrix);
            
            // Step 2: Square them to get eigenvalues (σ²)
            const eigenvalues = singularValues.map(sigma => sigma * sigma);
            
            console.log('Converted singular values to eigenvalues:');
            console.log('Singular values (σ):', singularValues.slice(0, 5).map(s => s.toFixed(2)));
            console.log('Eigenvalues (σ²):', eigenvalues.slice(0, 5).map(e => e.toFixed(2)));
            
            return eigenvalues;
        };

        // -------------------------------------------------------------------
        // 6. CALCULATE ALPHA MAX
        // -------------------------------------------------------------------
        
        // ALPHAMAX_v1.2_VALIDATED: Sparsity parameter upper bound calculation
        const calculateAlphaMax = function(matrix, alphaMaxMultiplier = 0.75) {
            if (!matrix || !matrix.length) {
                return 1.0;
            }
            
            try {
                const { u, s } = svd1Sync(matrix);
                const maxAbsU1 = Math.max(...u.map(val => Math.abs(val)));
                const result = alphaMaxMultiplier * maxAbsU1 * s;
                return result;
            } catch (error) {
                console.error('AlphaMax calculation failed:', error);
                return 1.0;
            }
        };

        // -------------------------------------------------------------------
        // 7. SSVD-R1 ALGORITHM
        // -------------------------------------------------------------------
        
        // SSVD-R1_v2.3_VALIDATED: Correct SSVD1 implementation following exact MATLAB sequence: u=X*v, threshold, normalize
        const SSVDR1Algorithm = async function({ matrix, alpha, maxIter = 1000, tolerance = 0.001, onProgress = null, initialSVD = null }) {
            console.log(`SSVDR1Algorithm v2.3 called with: alpha=${alpha}, maxIter=${maxIter}, tolerance=${tolerance}, matrixSize=${matrix?.length}x${matrix?.[0]?.length}`);
            if (!matrix || !matrix.length || !matrix[0].length) {
                throw new Error('Invalid matrix provided');
            }

            const P = matrix.length;
            const N = matrix[0].length;

            // Special case: alpha = 0, return standard SVD result
            if (Math.abs(alpha) < 1e-10) {
                console.log(`Alpha ${alpha} treated as 0, returning standard SVD`);
                const svdResult = initialSVD || await svd1(matrix);
                const { u, s, v } = svdResult;
                const nonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
                const sparsity = (P - nonZeros) / P;

                return {
                    u, s, v,
                    iterations: 0,
                    converged: true,
                    errors: [0],
                    sparsityHistory: [sparsity],
                    singularValues: [s]
                };
            }

            // Step 1: Get initial SVD (u0, s0, v0) - this is the expensive part, done ONCE
            if (initialSVD) {
                console.log('✅ Using cached SVD - skipping SVD computation');
            } else {
                console.log('⚠️ No cached SVD - computing SVD from scratch');
            }
            const svdResult = initialSVD || await svd1(matrix);
            const { u: u0, s: s0, v: v0 } = svdResult;

            // Initialize with SVD results
            let u = [...u0];
            let s = s0;
            let v = [...v0];  // v will be updated during iterations per MATLAB reference
            let uPrev = [...u0];

            let iterCount = 0;
            let error = 1;
            const errors = [];
            const sparsityHistory = [];
            const singularValues = [s0];

            // CORRECT SSVD1: Iterate only on u vector with soft thresholding
            const iterStartTime = performance.now();
            while (error > tolerance && iterCount < maxIter) {
                iterCount++;

                // Store previous u for convergence check
                uPrev = [...u];

                // STEP 1: Update u from X*v (MATLAB line 75: u = X*v)
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += matrix[i][j] * v[j];
                    }
                }

                // STEP 2: Apply soft thresholding to u (MATLAB line 76: u = sign(u).*max(abs(u)-alpha,0))
                u = u.map(x => Math.sign(x) * Math.max(Math.abs(x) - alpha, 0));

                // STEP 3: Normalize u if non-zero (MATLAB line 78: u = u/norm(u,2))
                let uNorm = norm(u);
                if (uNorm > 0) {
                    u = u.map(x => x / uNorm);
                } else {
                    // If u becomes all zeros, we've converged to zero solution
                    console.log(`Converged to zero solution at iteration ${iterCount}`);
                    u = Array(P).fill(0);
                    s = 0;
                    break;
                }

                // STEP 4: Update v from X^T*u (MATLAB line 69: v = X'*u0)
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += matrix[i][j] * u[i];
                    }
                }

                // STEP 5: Normalize v (MATLAB line 72: v = v./norm(v,2))
                let vNorm = norm(v);
                if (vNorm > 0) {
                    v = v.map(x => x / vNorm);
                } else {
                    // If v becomes all zeros, we've converged to zero solution
                    console.log(`v became zero at iteration ${iterCount}`);
                    break;
                }

                // Check convergence based on change in u vector (NOT matrix operations!)
                error = 0;
                for (let i = 0; i < u.length; i++) {
                    const diff = u[i] - uPrev[i];
                    error += diff * diff;
                }
                error = Math.sqrt(error);
                errors.push(error);

                // Track sparsity
                const nonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
                const sparsity = (P - nonZeros) / P;
                sparsityHistory.push(sparsity);

                // Compute singular value for this sparse u (optional, for monitoring)
                // s = u^T * X * v (only computation involving matrix, done rarely)
                if (iterCount % 10 === 0 || error < tolerance) {
                    s = Math.abs(u.reduce((sum, uVal, i) =>
                        sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0));
                    singularValues.push(s);
                }

                // Early termination for numerical stability
                if (isNaN(error) || !isFinite(error)) {
                    console.warn('Numerical instability detected');
                    break;
                }

                // Yield control back to browser periodically
                if (iterCount % 100 === 0) {
                    if (onProgress) {
                        onProgress(iterCount, maxIter, error);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            const iterEndTime = performance.now();
            console.log(`SSVD1 v2.3 completed: ${iterCount} iterations in ${((iterEndTime - iterStartTime) / 1000).toFixed(2)}s (correct MATLAB sequence)`);

            // Final singular value computation (only if u is non-zero)
            const finalS = s > 0 ? Math.abs(u.reduce((sum, uVal, i) =>
                sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0)) : 0;

            // Count final non-zeros for reporting
            const finalNonZeros = u.filter(val => Math.abs(val) > 1e-8).length;
            const finalSparsity = (P - finalNonZeros) / P;

            return {
                u,
                s: finalS,
                v,
                iterations: iterCount,
                converged: error <= tolerance,
                errors,
                sparsityHistory,
                singularValues,
                convergenceInfo: {
                    finalError: error,
                    tolerance: tolerance,
                    sparsity: finalSparsity,
                    nonZeros: finalNonZeros
                }
            };
        };

        // -------------------------------------------------------------------
        // 8. FDR ANALYSIS
        // -------------------------------------------------------------------
        
        // Fixed permutation pattern generation for reproducible testing
        const generateFixedPermutations = function(Nperm, matrixRows) {
            const patterns = [];
            for (let i = 0; i < Nperm; i++) {
                const indices = Array.from({length: matrixRows}, (_, i) => i);
                // Fisher-Yates shuffle with fixed sequence
                for (let j = indices.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [indices[j], indices[k]] = [indices[k], indices[j]];
                }
                patterns.push(indices);
            }
            return patterns;
        };
        
        // Store/retrieve patterns for A/B testing
        const savePermutationPatterns = function(patterns) {
            localStorage.setItem('ssvd1x_fixed_permutations', JSON.stringify(patterns));
        };
        
        const loadPermutationPatterns = function() {
            const stored = localStorage.getItem('ssvd1x_fixed_permutations');
            return stored ? JSON.parse(stored) : null;
        };
        
        // FDR_ANALYSIS_v2.0_VALIDATED: Empirical False Discovery Rate with permutation testing
        const runFDRAnalysis = async function({ matrix, alpha0, alphaMax, Nalpha, Nperm, nsupp, onProgress, initialSVD = null, isCancelled = () => false, useFixedPermutations = false }) {
            const P = matrix.length;
            const pi0 = (P - nsupp) / P;
            
            // Load or generate fixed permutation patterns if requested
            let fixedPatterns = null;
            if (useFixedPermutations) {
                fixedPatterns = loadPermutationPatterns();
                if (!fixedPatterns || fixedPatterns.length < Nperm) {
                    console.log('Generating fixed permutation patterns...');
                    fixedPatterns = generateFixedPermutations(Nperm, P);
                    savePermutationPatterns(fixedPatterns);
                    console.log(`Generated and saved ${Nperm} fixed permutation patterns`);
                } else {
                    console.log(`Using ${Nperm} fixed permutation patterns from storage`);
                }
            }
            
            const alphaValues = [];
            for (let i = 0; i < Nalpha; i++) {
                // Handle single alpha case (Nalpha = 1) to avoid division by zero
                const alpha = Nalpha === 1 ? alpha0 : alpha0 + (alphaMax - alpha0) * i / (Nalpha - 1);
                alphaValues.push(alpha);
            }

            const results = [];
            let totalProgress = 0;
            const totalRuns = Nalpha * (1 + Nperm);

            for (let alphaIdx = 0; alphaIdx < alphaValues.length; alphaIdx++) {
                // Check for cancellation before processing each alpha
                if (isCancelled()) {
                    console.log('FDR analysis cancelled by user');
                    return {
                        alphaValues: alphaValues.slice(0, alphaIdx),
                        fdrValues: results.map(r => r.eFDR),
                        detectionCounts: results.map(r => r.detectionCount),
                        gradients: results.map(r => r.gradient),
                        results,
                        pi0,
                        totalRuns,
                        cancelled: true
                    };
                }
                
                const alpha = alphaValues[alphaIdx];
                
                try {
                    console.log(`Starting original SSVD for alpha ${alphaIdx + 1}/${Nalpha}: ${alpha.toFixed(6)}`);
                    
                    // Run SSVD on original matrix with optimized parameters
                    const alphaRatio = alpha / alphaMax;
                    
                    // For ORIGINAL matrix: Give small alphas the iterations they need
                    const adaptiveMaxIterOrig = 
                        alphaRatio < 0.05 ? 2000 :     // Very small: many iterations
                        alphaRatio < 0.2 ? 1000 :       // Small: standard
                        alphaRatio < 0.5 ? 500 :        // Medium: fewer
                        alphaRatio < 0.75 ? 200 :       // Large: fast
                        100;                            // Near alphaMax: very fast
                    
                    const adaptiveToleranceOrig = 
                        alphaRatio < 0.2 ? 0.0001 :     // Tight for small alphas
                        alphaRatio < 0.5 ? 0.001 :      
                        0.01;                           // Looser for large alphas
                    
                    const originalResult = await SSVDR1Algorithm({
                        matrix, 
                        alpha,
                        maxIter: adaptiveMaxIterOrig,   // Use adaptive
                        tolerance: adaptiveToleranceOrig,  // Use adaptive
                        initialSVD   // Pass the cached SVD for original matrix
                    });
                    const originalDetections = originalResult.u.filter(val => Math.abs(val) > 1e-8).length;
                    
                    console.log(`Original SSVD completed for alpha ${alpha.toFixed(6)}: ${originalDetections} detections, ${originalResult.iterations} iterations`);
                    
                    // Early termination: If solution becomes all zeros, all higher alphas will also be zero
                    if (originalDetections === 0 && alphaIdx > 0) {
                        console.log(`Early termination: Zero detections at alpha ${alpha.toFixed(6)}. Skipping remaining alphas.`);
                        // Fill remaining results with zeros
                        for (let i = alphaIdx; i < alphaValues.length; i++) {
                            results.push({
                                alpha: alphaValues[i],
                                detectionCount: 0,
                                eFDR: 0,
                                gradient: 0,
                                permutationDetections: 0
                            });
                        }
                        break; // Exit the alpha loop
                    }
                    
                    totalProgress++;
                    if (onProgress) {
                        onProgress(totalProgress, totalRuns, 
                            `Alpha ${alphaIdx + 1}/${Nalpha} (α=${alpha.toFixed(4)}): Original run`);
                    }

                // Permutation tests with batching
                let totalPermDetections = 0;
                
                // Detect optimal batch size based on hardware
                const batchSize = Math.min(navigator.hardwareConcurrency || 4, 8);
                console.log(`Processing ${Nperm} permutations in batches of ${batchSize}`);
                
                // Process permutations in batches
                for (let batchStart = 0; batchStart < Nperm; batchStart += batchSize) {
                    // Check for cancellation before each batch
                    if (isCancelled()) {
                        console.log('FDR analysis cancelled during permutations');
                        break;
                    }
                    
                    const batchEnd = Math.min(batchStart + batchSize, Nperm);
                    const currentBatchSize = batchEnd - batchStart;
                    const batchNumber = Math.floor(batchStart / batchSize) + 1;
                    const totalBatches = Math.ceil(Nperm / batchSize);
                    
                    console.log(`Starting batch ${batchNumber}/${totalBatches} (perms ${batchStart + 1}-${batchEnd}) for alpha ${alphaIdx + 1}/${Nalpha}`);
                    
                    // Create promises for all permutations in this batch
                    const batchPromises = [];
                    for (let perm = batchStart; perm < batchEnd; perm++) {
                        batchPromises.push(
                            (async () => {
                                try {
                                    const permutedMatrix = useFixedPermutations && fixedPatterns ? 
                                        permuteMatrixRows(matrix, fixedPatterns[perm]) :
                                        permuteMatrixRows(matrix);
                                    // Data-driven adaptive parameters based on alphaMax ratio (OPTIMIZED for permutations)
                                    const alphaRatio = alpha / alphaMax;
                                    
                                    // For PERMUTATIONS: Prioritize speed, invert iteration logic
                                    const adaptiveMaxIter = 
                                        alphaRatio < 0.05 ? 400 :      // Very small: cap iterations (was 1000!)
                                        alphaRatio < 0.2 ? 350 :        // Small: less time
                                        alphaRatio < 0.5 ? 250 :        // Medium: faster
                                        alphaRatio < 0.75 ? 150 :       // Large: very fast
                                        50;                             // Near alphaMax: minimal
                                    
                                    const adaptiveTolerance = 
                                        alphaRatio < 0.2 ? 0.01 :       // Loose for small alphas (was 0.0001!)
                                        alphaRatio < 0.5 ? 0.005 :      
                                        0.001;                          // Tighter only for large alphas
                                    
                                    // Use reduced parameters for permutations (only need approximate null distribution)
                                    const permResult = await SSVDR1Algorithm({
                                        matrix: permutedMatrix,
                                        alpha,
                                        maxIter: adaptiveMaxIter,  // Adaptive based on alpha
                                        tolerance: adaptiveTolerance  // Adaptive based on alpha
                                    });
                                    const permDetections = permResult.u.filter(val => Math.abs(val) > 1e-8).length;
                                    return permDetections;
                                } catch (error) {
                                    console.error(`Permutation ${perm + 1} in batch ${batchNumber} failed:`, error);
                                    return 0; // Return 0 detections on error
                                }
                            })()
                        );
                    }
                    
                    // Wait for all permutations in batch to complete
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Sum up detections from this batch
                    const batchDetections = batchResults.reduce((sum, val) => sum + val, 0);
                    totalPermDetections += batchDetections;
                    
                    console.log(`Batch ${batchNumber}/${totalBatches} completed: ${batchDetections} total detections from ${currentBatchSize} permutations`);
                    
                    // Update progress for the batch - throttle updates to reduce jitter
                    totalProgress += currentBatchSize;
                    if (onProgress) {
                        // Only update progress every 2nd batch or on first/last batch to reduce jitter
                        if (batchNumber === 1 || batchNumber === totalBatches || batchNumber % 2 === 0) {
                            onProgress(totalProgress, totalRuns,
                                `Alpha ${alphaIdx + 1}/${Nalpha} (α=${alpha.toFixed(4)}): Permutation batch ${batchNumber}/${totalBatches}`);
                        }
                    }
                }

                    const avgPermDetections = totalPermDetections / Nperm;
                    const expectedFalsePos = pi0 * avgPermDetections;
                    const fdr = originalDetections > 0 ? expectedFalsePos / originalDetections : 0;
                    const eFDR = Math.min(fdr * 100, 100);
                    
                    // Calculate gradient (change in detections from previous alpha)
                    let gradient = 0;
                    if (alphaIdx > 0) {
                        gradient = originalDetections - results[alphaIdx - 1].detectionCount;
                    }

                    results.push({
                        alpha,
                        detectionCount: originalDetections,
                        avgPermDetections,
                        eFDR,
                        gradient
                    });
                    
                    console.log(`Alpha ${alphaIdx + 1}/${Nalpha} complete: eFDR = ${eFDR.toFixed(2)}%`);
                    
                } catch (error) {
                    console.error(`Alpha ${alphaIdx + 1} failed:`, error);
                    // Add a failed result to keep indexing consistent
                    results.push({
                        alpha,
                        detectionCount: 0,
                        avgPermDetections: 0,
                        eFDR: 100,  // Assume worst case
                        gradient: 0
                    });
                }
            }

            return {
                alphaValues,
                fdrValues: results.map(r => r.eFDR),
                detectionCounts: results.map(r => r.detectionCount),
                gradients: results.map(r => r.gradient),
                results,
                pi0,
                totalRuns
            };
        };

        // ===================================================================
        // WEB WORKER FDR ANALYSIS - PERFORMANCE OPTIMIZED
        // ===================================================================

        // Web Worker wrapper for FDR analysis to prevent browser tab throttling
        let fdrWorker = null;
        let workerMessageId = 0;
        const workerPromises = new Map();

        const initializeFDRWorker = () => {
            if (fdrWorker) {
                fdrWorker.terminate();
            }

            fdrWorker = new Worker('fdr-worker.js');

            fdrWorker.onmessage = (e) => {
                const { type, id, data } = e.data;
                const promise = workerPromises.get(id);

                switch (type) {
                    case 'progress':
                        if (promise && promise.onProgress) {
                            promise.onProgress(data.current, data.total, data.message);
                        }
                        break;

                    case 'storeProgress':
                        // Store enhanced progress data from worker
                        saveFDRProgress(data);
                        break;

                    case 'result':
                        if (promise) {
                            promise.resolve(data);
                            workerPromises.delete(id);
                        }
                        break;

                    case 'error':
                        if (promise) {
                            promise.reject(new Error(data.message));
                            workerPromises.delete(id);
                        }
                        break;

                    case 'cancelled':
                        if (promise) {
                            promise.resolve({ cancelled: true });
                            workerPromises.delete(id);
                        }
                        break;

                    case 'ready':
                        console.log('FDR Worker ready for analysis');
                        break;
                }
            };

            fdrWorker.onerror = (error) => {
                console.error('FDR Worker error:', error);
                // Fallback to main thread analysis if worker fails
                workerPromises.forEach(promise => {
                    promise.reject(new Error('Worker failed: ' + error.message));
                });
                workerPromises.clear();
            };

            return fdrWorker;
        };

        // Single-Alpha eFDR: Run permutations only (original SSVD already cached from N-alpha)
        const runPermutationsForAlpha = async function({ matrix, alpha, originalDetections, Nperm, nsupp, onProgress, isCancelled }) {
            console.log(`Running permutations for α = ${alpha.toFixed(6)}, originalDetections = ${originalDetections}, Nperm = ${Nperm}, nsupp = ${nsupp}`);

            // Defensive checks
            if (!matrix || !matrix.length) {
                throw new Error('Matrix is undefined or empty');
            }
            if (!alpha || isNaN(alpha)) {
                throw new Error(`Invalid alpha value: ${alpha}`);
            }
            if (originalDetections === undefined || originalDetections < 0) {
                throw new Error(`Invalid originalDetections: ${originalDetections}`);
            }
            if (!nsupp || nsupp <= 0) {
                throw new Error(`Invalid nsupp value: ${nsupp}`);
            }

            const P = matrix.length;
            const pi0 = (P - nsupp) / P;

            console.log(`Matrix: ${P}x${matrix[0].length}, π₀ = ${pi0.toFixed(4)}`);

            // Calculate alphaMax for adaptive parameters
            const alphaMax = 0.01; // Fallback estimate
            const alphaRatio = alpha / alphaMax;

            let totalPermDetections = 0;
            const totalRuns = Nperm;
            let completedRuns = 0;

            // Use smaller batch size for more responsive cancellation (2 permutations at a time)
            const batchSize = 2;
            console.log(`Processing ${Nperm} permutations in batches of ${batchSize} (responsive cancellation)`);
            console.log(`onProgress callback exists: ${!!onProgress}`);

            // Initialize progress reporting
            if (onProgress) {
                console.log('📊 Initializing progress: 0/' + totalRuns);
                onProgress(0, totalRuns, 'Starting permutation testing...');
            }

            // Process permutations in batches for parallelism
            for (let batchStart = 0; batchStart < Nperm; batchStart += batchSize) {
                // Check for cancellation
                if (isCancelled && isCancelled()) {
                    console.log('Permutation testing cancelled by user');
                    throw new Error('Analysis cancelled by user');
                }

                const batchEnd = Math.min(batchStart + batchSize, Nperm);
                const currentBatchSize = batchEnd - batchStart;
                const batchNumber = Math.floor(batchStart / batchSize) + 1;
                const totalBatches = Math.ceil(Nperm / batchSize);

                console.log(`Starting batch ${batchNumber}/${totalBatches} (perms ${batchStart + 1}-${batchEnd})`);

                // Process permutations with individual progress updates
                const batchPromises = [];
                for (let perm = batchStart; perm < batchEnd; perm++) {
                    batchPromises.push(
                        (async () => {
                            try {
                                // Check for cancellation before starting this permutation
                                if (isCancelled && isCancelled()) {
                                    console.log(`Permutation ${perm + 1} cancelled before execution`);
                                    return 0; // Return 0 detections for cancelled permutation
                                }

                                const permutedMatrix = permuteMatrixRows(matrix);

                                // Adaptive parameters based on alpha ratio
                                const adaptiveMaxIter =
                                    alphaRatio < 0.05 ? 400 :
                                    alphaRatio < 0.2 ? 350 :
                                    alphaRatio < 0.5 ? 250 :
                                    alphaRatio < 0.75 ? 150 :
                                    50;

                                const adaptiveTolerance =
                                    alphaRatio < 0.2 ? 0.01 :
                                    alphaRatio < 0.5 ? 0.005 :
                                    0.001;

                                const permResult = await SSVDR1Algorithm({
                                    matrix: permutedMatrix,
                                    alpha,
                                    maxIter: adaptiveMaxIter,
                                    tolerance: adaptiveTolerance
                                });

                                // Check for cancellation after permutation completes
                                if (isCancelled && isCancelled()) {
                                    console.log(`Permutation ${perm + 1} cancelled after completion`);
                                    return 0; // Don't count this result
                                }

                                const permDetections = permResult.u.filter(val => Math.abs(val) > 1e-8).length;

                                // Update progress AFTER permutation completes (only on 5% increments)
                                completedRuns++;
                                if (onProgress) {
                                    const currentPercent = Math.floor((completedRuns / totalRuns) * 100);
                                    const previousPercent = Math.floor(((completedRuns - 1) / totalRuns) * 100);

                                    // Report if we crossed a 5% threshold OR if we're at 100%
                                    const currentBucket = Math.floor(currentPercent / 5);
                                    const previousBucket = Math.floor(previousPercent / 5);

                                    if (currentBucket > previousBucket || completedRuns === totalRuns) {
                                        const progressMessage = `${currentPercent}% complete (${completedRuns}/${totalRuns} permutations)`;
                                        console.log(`🔄 Calling onProgress: ${completedRuns}/${totalRuns} (${currentPercent}%)`);
                                        onProgress(completedRuns, totalRuns, progressMessage);
                                    }
                                }

                                return permDetections;
                            } catch (error) {
                                console.error(`Permutation ${perm + 1} in batch ${batchNumber} failed:`, error);
                                return 0;
                            }
                        })()
                    );
                }

                // Wait for all permutations in batch to complete
                const batchResults = await Promise.all(batchPromises);

                // Check for cancellation immediately after batch completes
                if (isCancelled && isCancelled()) {
                    console.log(`Analysis cancelled after batch ${batchNumber}/${totalBatches} completed`);
                    throw new Error('Analysis cancelled by user');
                }

                // Sum up detections from this batch
                const batchDetections = batchResults.reduce((sum, val) => sum + val, 0);
                totalPermDetections += batchDetections;

                console.log(`Batch ${batchNumber}/${totalBatches} completed: ${batchDetections} total detections from ${currentBatchSize} permutations`);

                // Small delay to allow UI update (also check cancellation during delay)
                await new Promise(resolve => setTimeout(resolve, 10));

                // Final check after UI delay
                if (isCancelled && isCancelled()) {
                    console.log(`Analysis cancelled during UI delay after batch ${batchNumber}/${totalBatches}`);
                    throw new Error('Analysis cancelled by user');
                }
            }

            // Calculate eFDR
            const avgPermDetections = totalPermDetections / Nperm;
            const expectedFalsePos = pi0 * avgPermDetections;
            const fdr = originalDetections > 0 ? expectedFalsePos / originalDetections : 0;
            const eFDR = Math.min(fdr, 1.0); // Keep as fraction (0-1), not percentage

            console.log(`eFDR Calculation: avgPerm=${avgPermDetections.toFixed(2)}, expectedFP=${expectedFalsePos.toFixed(2)}, eFDR=${(eFDR*100).toFixed(2)}%`);

            return {
                eFDR,
                pi0,
                avgPermDetections,
                Nperm,
                nsupp,
                originalDetections, // Include for display calculations
                alpha // Include alpha for complete display
            };
        };

        // Web Worker-based FDR analysis function
        const runFDRAnalysisWorker = async function(params) {
            return new Promise((resolve, reject) => {
                // Initialize worker if needed
                if (!fdrWorker) {
                    initializeFDRWorker();
                }

                const messageId = ++workerMessageId;

                // Store promise handlers
                workerPromises.set(messageId, {
                    resolve,
                    reject,
                    onProgress: params.onProgress
                });

                // Send analysis request to worker
                fdrWorker.postMessage({
                    type: 'runFDRAnalysis',
                    id: messageId,
                    data: {
                        matrix: params.matrix,
                        alpha0: params.alpha0,
                        alphaMax: params.alphaMax,
                        Nalpha: params.Nalpha,
                        Nperm: params.Nperm,
                        nsupp: params.nsupp,
                        initialSVD: params.initialSVD,
                        useFixedPermutations: params.useFixedPermutations,
                        analysisStartTime: params.analysisStartTime
                    }
                });

                // Remove complex cancellation logic - rely on immediate termination instead
                // No need for periodic checks since we terminate immediately
            });
        };

        // Enhanced FDR analysis with fallback
        const runFDRAnalysisEnhanced = async function(params) {
            // Check if already cancelled before starting
            if (params.isCancelled && params.isCancelled()) {
                return { cancelled: true };
            }

            // Initialize worker if needed
            if (!fdrWorker) {
                initializeFDRWorker();
            }

            // Use Web Worker with immediate cancellation support
            try {
                console.log('Starting FDR analysis with Web Worker...');
                const result = await runFDRAnalysisWorker(params);
                return result;
            } catch (error) {
                // Worker was likely terminated due to cancellation
                console.log('Worker terminated (likely due to cancellation)');
                return { cancelled: true };
            }
        };

        // Enhanced progress persistence system
        const saveFDRProgress = (progressData) => {
            try {
                localStorage.setItem('ssvd1x_fdr_progress', JSON.stringify({
                    ...progressData,
                    timestamp: Date.now()
                }));
            } catch (error) {
                console.warn('Failed to save FDR progress:', error);
            }
        };

        // System resource monitoring
        const getSystemResources = () => {
            const resources = {
                timestamp: Date.now(),
                memory: {},
                performance: {},
                browser: {}
            };

            // Memory information (if available)
            if (performance.memory) {
                resources.memory = {
                    used: Math.round(performance.memory.usedJSHeapSize / (1024 * 1024)),
                    total: Math.round(performance.memory.totalJSHeapSize / (1024 * 1024)),
                    limit: Math.round(performance.memory.jsHeapSizeLimit / (1024 * 1024))
                };
            }

            // Performance timing
            if (performance.now) {
                resources.performance = {
                    currentTime: Math.round(performance.now()),
                    timeOrigin: performance.timeOrigin
                };
            }

            // Browser information
            resources.browser = {
                hardwareConcurrency: navigator.hardwareConcurrency || 'Unknown',
                userAgent: navigator.userAgent.includes('Chrome') ? 'Chrome' :
                          navigator.userAgent.includes('Firefox') ? 'Firefox' :
                          navigator.userAgent.includes('Safari') ? 'Safari' : 'Other',
                online: navigator.onLine
            };

            return resources;
        };

        // Background progress sync system
        let progressSyncInterval = null;
        const startProgressSync = () => {
            if (progressSyncInterval) return;

            progressSyncInterval = setInterval(() => {
                // Check for updated progress from worker storage
                const storedProgress = loadFDRProgress();
                if (storedProgress && storedProgress.timestamp > Date.now() - 10000) {
                    // Update UI with fresh progress if recent (within 10 seconds)
                    if (window.setProgress && typeof window.setProgress === 'function') {
                        window.setProgress(storedProgress);
                    }
                }
            }, 2000); // Check every 2 seconds
        };

        const stopProgressSync = () => {
            if (progressSyncInterval) {
                clearInterval(progressSyncInterval);
                progressSyncInterval = null;
            }
        };

        // Tab visibility change handler for progress sync
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                // Tab became visible - immediately sync progress
                const storedProgress = loadFDRProgress();
                if (storedProgress && window.setProgress) {
                    window.setProgress(storedProgress);
                }
            }
        });

        const loadFDRProgress = () => {
            try {
                const stored = localStorage.getItem('ssvd1x_fdr_progress');
                if (stored) {
                    const progress = JSON.parse(stored);
                    // Check if progress is recent (within 24 hours)
                    if (Date.now() - progress.timestamp < 24 * 60 * 60 * 1000) {
                        return progress;
                    }
                }
            } catch (error) {
                console.warn('Failed to load FDR progress:', error);
            }
            return null;
        };

        const clearFDRProgress = (reportFinalTime = false) => {
            try {
                if (reportFinalTime) {
                    // Capture final elapsed time before clearing
                    const stored = localStorage.getItem('ssvd1x_fdr_progress');
                    if (stored) {
                        const progress = JSON.parse(stored);
                        if (progress.elapsedTimeFormatted) {
                            console.log(`🎉 eFDR Analysis completed in: ${progress.elapsedTimeFormatted}`);

                            // Completion notification suppressed per user request
                            // const completionMessage = `eFDR Analysis Complete!\n\nTotal Runtime: ${progress.elapsedTimeFormatted}\nAnalysis Type: ${progress.analysisData?.alphaValues || 'N/A'} alphas × ${progress.analysisData?.permutations || 'N/A'} permutations\nMatrix Size: ${progress.analysisData?.matrixSize || 'N/A'}`;
                            // setTimeout(() => { alert(completionMessage); }, 1000);
                        }
                    }
                }
                localStorage.removeItem('ssvd1x_fdr_progress');
            } catch (error) {
                console.warn('Failed to clear FDR progress:', error);
            }
        };

        // Keep-alive system to prevent throttling
        let keepAliveInterval = null;
        let audioContext = null;

        const startKeepAlive = () => {
            if (keepAliveInterval) return;

            // Audio context keep-alive (silent)
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                gainNode.gain.setValueAtTime(0, audioContext.currentTime); // Silent
                oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
                oscillator.start();

                console.log('Audio context keep-alive started');
            } catch (error) {
                console.warn('Audio context keep-alive failed:', error);
            }

            // Periodic small operations to keep tab active
            keepAliveInterval = setInterval(() => {
                // Minimal operation to maintain activity
                performance.now();
            }, 30000); // Every 30 seconds

            console.log('Keep-alive system activated for long-running analysis');
        };

        const stopKeepAlive = () => {
            if (keepAliveInterval) {
                clearInterval(keepAliveInterval);
                keepAliveInterval = null;
            }

            if (audioContext) {
                try {
                    audioContext.close();
                    audioContext = null;
                } catch (error) {
                    console.warn('Error closing audio context:', error);
                }
            }

            console.log('Keep-alive system deactivated');
        };

        // ===================================================================
        // PHASE 3: DATA REVIEW - STATISTICS AND VISUALIZATIONS
        // ===================================================================

        // Adaptive decimal formatting for small values (handles preprocessed gene expression data)
        const formatSmallValue = (val) => {
            const absVal = Math.abs(val);
            if (absVal === 0) return "0.000";
            if (absVal < 0.001) return val.toExponential(3);  // e.g., "1.234e-4"
            if (absVal < 1) return val.toFixed(6);             // e.g., "0.000123"
            return val.toFixed(3);                              // e.g., "1.234"
        };

        // Calculate comprehensive matrix statistics
        const calculateMatrixStatistics = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Memory-efficient overall statistics
            let min = Infinity, max = -Infinity, sum = 0, count = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    if (val < min) min = val;
                    if (val > max) max = val;
                    sum += val;
                    count++;
                }
            }
            const mean = sum / count;
            
            // Calculate variance in second pass
            let sumSquaredDiff = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    sumSquaredDiff += Math.pow(val - mean, 2);
                }
            }
            const variance = sumSquaredDiff / count;
            const stdDev = Math.sqrt(variance);
            
            // Row statistics (across samples for each feature)
            const rowMeans = matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N);
            const rowStdDevs = matrix.map((row, i) => {
                const rowMean = rowMeans[i];
                const variance = row.reduce((sum, val) => sum + Math.pow(val - rowMean, 2), 0) / N;
                return Math.sqrt(variance);
            });
            
            // Column statistics (across features for each sample)
            const columnMeans = Array(N).fill(0).map((_, j) => 
                matrix.reduce((sum, row) => sum + row[j], 0) / P
            );
            const columnStdDevs = columnMeans.map((colMean, j) => {
                const variance = matrix.reduce((sum, row) => sum + Math.pow(row[j] - colMean, 2), 0) / P;
                return Math.sqrt(variance);
            });
            
            return {
                P, N, min, max, mean, stdDev,
                rowMeans, rowStdDevs,
                columnMeans, columnStdDevs,
                frobeniusNorm: calculateFrobeniusNorm(matrix)
            };
        };

        // Calculate eigenvalue spectrum (σ²) from SVD
        const calculateEigenvalueSpectrum = function(matrix) {
            console.log('🔥 COMPUTING EIGENVALUE SPECTRUM (σ²) v3.0 🔥');
            console.log('Matrix dimensions for SVD:', matrix.length, 'x', matrix[0].length);
            // Use fullSVD to get eigenvalues (σ²)
            const eigenvalues = fullSVD(matrix);
            console.log('🔥 EIGENVALUES COMPUTED:', eigenvalues.length, 'values, range:', 
                        eigenvalues.length > 0 ? `${eigenvalues[0].toFixed(2)} to ${eigenvalues[eigenvalues.length-1].toFixed(2)}` : 'empty');
            return eigenvalues; // Return array of eigenvalues (σ²)
        };

        // ===================================================================
        // DATA PREPROCESSING FUNCTIONS
        // ===================================================================

        // Calculate Frobenius norm of a matrix
        const calculateFrobeniusNorm = function(matrix) {
            let sumSquares = 0;
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    sumSquares += matrix[i][j] * matrix[i][j];
                }
            }
            return Math.sqrt(sumSquares);
        };

        // Apply preprocessing: Frobenius normalization followed by row centering
        const preprocessMatrix = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Step 1: Calculate Frobenius norm
            const frobeniusNorm = calculateFrobeniusNorm(matrix);
            console.log(`Frobenius norm of original matrix: ${frobeniusNorm.toFixed(6)}`);
            
            // Step 2: Normalize by Frobenius norm
            const normalizedMatrix = matrix.map(row => 
                row.map(val => val / frobeniusNorm)
            );
            
            // Step 3: Calculate row means of normalized matrix
            const rowMeans = normalizedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            
            // Step 4: Center each row by subtracting row mean
            const preprocessedMatrix = normalizedMatrix.map((row, i) => 
                row.map(val => val - rowMeans[i])
            );
            
            // Verify preprocessing
            const newFrobeniusNorm = calculateFrobeniusNorm(preprocessedMatrix);
            const newRowMeans = preprocessedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            const maxRowMean = Math.max(...newRowMeans.map(Math.abs));
            
            console.log(`Frobenius norm after preprocessing: ${newFrobeniusNorm.toFixed(6)}`);
            console.log(`Max absolute row mean after centering: ${maxRowMean.toExponential(3)}`);
            
            return {
                preprocessedMatrix,
                frobeniusNormOriginal: frobeniusNorm,
                frobeniusNormProcessed: newFrobeniusNorm,
                rowMeansOriginal: matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N),
                rowMeansProcessed: newRowMeans
            };
        };

        // ===================================================================
        // REACT COMPONENTS (PHASE 2: ENHANCED CSV UPLOAD)
        // ===================================================================

        // CSV Upload Component with drag-and-drop and preview
        const CSVUploader = ({ onDataLoaded }) => {
            const [isDragging, setIsDragging] = useState(false);
            const [preview, setPreview] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingMessage, setProcessingMessage] = useState('');

            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            };

            const handleFile = (file) => {
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    alert('Please select a CSV file');
                    return;
                }

                setIsProcessing(true);
                setProcessingMessage('Starting CSV parsing...');
                
                // Use streaming for large files
                const rawData = [];
                let rowCount = 0;
                let hasHeaders = null;
                let firstRowProcessed = false;
                const fileSize = file.size;
                let bytesProcessed = 0;
                
                Papa.parse(file, {
                    worker: false, // Could enable for better performance
                    step: (row, parser) => {
                        // Process each row as it's parsed
                        if (row.data && row.data.length > 0) {
                            rawData.push(row.data);
                            rowCount++;
                            
                            // Update progress periodically
                            if (rowCount % 1000 === 0) {
                                const progress = Math.round((row.meta.cursor / fileSize) * 100);
                                setProcessingMessage(`Processing row ${rowCount.toLocaleString()} (${progress}% complete)...`);
                            }
                            
                            // For very large files, could add a row limit
                            // if (rowCount > 50000) {
                            //     parser.abort();
                            //     console.warn('Row limit reached, processing first 50,000 rows only');
                            // }
                        }
                    },
                    complete: (results) => {
                        try {
                            setProcessingMessage('Validating matrix data...');
                            
                            // Filter out empty rows
                            const filteredData = rawData.filter(row => 
                                row.some(cell => cell && cell.toString().trim() !== '')
                            );

                            if (filteredData.length === 0) {
                                throw new Error('File appears to be empty');
                            }

                            console.log(`Parsed ${filteredData.length} rows from CSV file`);

                            // Store metadata for display
                            let rowHeaders = [];
                            let columnHeaders = [];
                            let dataStartRow = 0;
                            let dataStartCol = 0;

                            // Check for column headers (first row contains non-numeric values)
                            const firstRow = filteredData[0];
                            const hasColumnHeaders = firstRow.slice(1).some(cell => {
                                const num = parseFloat(cell);
                                return isNaN(num) && cell.toString().trim() !== '';
                            });

                            // Check for row headers (first column contains non-numeric values)
                            const hasRowHeaders = filteredData.slice(1).some(row => {
                                if (row.length > 0) {
                                    const num = parseFloat(row[0]);
                                    return isNaN(num) && row[0].toString().trim() !== '';
                                }
                                return false;
                            });

                            // Detect if corner cell exists (typical for datasets with both row and column headers)
                            const hasCornerLabel = hasColumnHeaders && hasRowHeaders;

                            if (hasColumnHeaders) {
                                columnHeaders = firstRow.slice(hasRowHeaders ? 1 : 0);
                                dataStartRow = 1;
                                console.log(`Column headers detected: ${columnHeaders.slice(0, 5).join(', ')}${columnHeaders.length > 5 ? '...' : ''}`);
                            }

                            if (hasRowHeaders) {
                                rowHeaders = filteredData.slice(dataStartRow).map(row => row[0]);
                                dataStartCol = 1;
                                console.log(`Row headers detected: ${rowHeaders.slice(0, 5).join(', ')}${rowHeaders.length > 5 ? '...' : ''}`);
                            }

                            // Extract numeric data matrix
                            const dataRows = filteredData.slice(dataStartRow);
                            
                            if (dataRows.length === 0) {
                                throw new Error('No data rows found after removing headers');
                            }

                            // Convert to numeric matrix, collecting errors instead of throwing
                            const parseErrors = [];
                            const MAX_ERRORS_TO_COLLECT = 10; // Limit error collection
                            
                            const matrix = dataRows.map((row, rowIndex) => {
                                const dataRow = row.slice(dataStartCol);
                                return dataRow.map((cell, colIndex) => {
                                    const num = parseFloat(cell);
                                    if (isNaN(num)) {
                                        if (parseErrors.length < MAX_ERRORS_TO_COLLECT) {
                                            const actualRow = rowIndex + dataStartRow + 1;
                                            const actualCol = colIndex + dataStartCol + 1;
                                            let location = `row ${actualRow}, column ${actualCol}`;
                                            if (rowHeaders.length > rowIndex) {
                                                location = `gene/feature "${rowHeaders[rowIndex]}"`;
                                            }
                                            if (columnHeaders.length > colIndex) {
                                                location += `, sample "${columnHeaders[colIndex]}"`;
                                            }
                                            parseErrors.push(`${location}: "${cell}"`);
                                        }
                                        return 0; // Replace non-numeric with 0 or could use NaN
                                    }
                                    return num;
                                });
                            });
                            
                            // Report errors once if any were found
                            if (parseErrors.length > 0) {
                                const errorMessage = `Found ${parseErrors.length} non-numeric values. First few:\n${parseErrors.slice(0, 5).join('\n')}`;
                                console.warn('Parse warnings:', errorMessage);
                                // Only show alert for critical issues, not warnings
                                if (parseErrors.length > 100) {
                                    alert(`Warning: ${parseErrors.length} non-numeric values found and replaced with 0. Check console for details.`);
                                }
                            }

                            // Display format detection message
                            let formatMessage = 'Processing data';
                            if (hasColumnHeaders && hasRowHeaders) {
                                formatMessage = `Gene expression format detected: ${rowHeaders.length} genes × ${columnHeaders.length} samples`;
                            } else if (hasColumnHeaders) {
                                formatMessage = `Column headers detected: ${columnHeaders.length} columns`;
                            } else if (hasRowHeaders) {
                                formatMessage = `Row headers detected: ${rowHeaders.length} rows`;
                            } else {
                                formatMessage = 'Pure numeric matrix detected';
                            }
                            setProcessingMessage(formatMessage);

                            if (matrix.length === 0 || matrix[0].length === 0) {
                                throw new Error('No valid data found in CSV');
                            }

                            // Validate rectangular matrix
                            const N = matrix[0].length;
                            const isRectangular = matrix.every((row, index) => {
                                if (row.length !== N) {
                                    throw new Error(`Row ${index + 1} has ${row.length} columns, expected ${N}`);
                                }
                                return true;
                            });

                            const P = matrix.length;

                            // Validate matrix size
                            if (P < 2 || N < 2) {
                                throw new Error(`Matrix too small: ${P}×${N}. Minimum size is 2×2`);
                            }

                            // Removed large matrix warning - process all sizes without confirmation

                            // Create preview (first 5×5)
                            const previewSize = Math.min(5, Math.min(P, N));
                            const matrixPreview = matrix.slice(0, previewSize).map(row => row.slice(0, previewSize));

                            setPreview({
                                data: matrixPreview,
                                totalDimensions: { P, N },
                                showMore: P > previewSize || N > previewSize
                            });

                            const matrixInfo = {
                                P, N,
                                filename: file.name,
                                fileSize: file.size,
                                rowHeaders: rowHeaders.length > 0 ? rowHeaders : null,
                                columnHeaders: columnHeaders.length > 0 ? columnHeaders : null,
                                hasHeaders: hasColumnHeaders || hasRowHeaders
                            };

                            setIsProcessing(false);
                            onDataLoaded(matrix, matrixInfo);

                        } catch (error) {
                            console.error('CSV processing error:', error);
                            alert(`Error processing CSV: ${error.message}`);
                            setIsProcessing(false);
                        }
                    },
                    error: (error) => {
                        alert(`CSV parsing failed: ${error.message}`);
                        setIsProcessing(false);
                    },
                    header: false,
                    skipEmptyLines: true,
                    delimiter: ',',
                    dynamicTyping: false
                });
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">Upload CSV Matrix</h2>
                    
                    <div
                        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                            isDragging ? 'border-indigo-500 bg-indigo-50' : 'border-gray-300'
                        }`}
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                    >
                        {isProcessing ? (
                            <div className="flex flex-col items-center space-y-3">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                                <span className="text-gray-700">{processingMessage}</span>
                            </div>
                        ) : (
                            <>
                                <input
                                    type="file"
                                    accept=".csv"
                                    onChange={handleFileChange}
                                    className="hidden"
                                    id="csvUpload"
                                />
                                <div className="space-y-3">
                                    <div className="text-4xl text-gray-400 mb-4">📊</div>
                                    <label
                                        htmlFor="csvUpload"
                                        className="cursor-pointer inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 transition-colors"
                                    >
                                        Choose CSV File
                                    </label>
                                    <p className="text-gray-600">
                                        or drag and drop your CSV file here
                                    </p>

                                    {/* Dedicated Drag-and-Drop Target Area */}
                                    <div
                                        className="mt-4 mx-auto w-full max-w-md h-32 border-4 border-dashed border-indigo-500 rounded-lg bg-indigo-50 flex items-center justify-center"
                                    >
                                        <span className="text-indigo-600 font-semibold text-sm">Drop CSV file here</span>
                                    </div>

                                    <div className="text-sm text-gray-500 mt-2">
                                        <div className="font-medium">Supported formats:</div>
                                        <ul className="mt-1 text-xs space-y-1">
                                            <li>• Numeric CSV matrix (P×N)</li>
                                            <li>• Gene expression format (row & column headers)</li>
                                            <li>• Headers automatically detected and extracted</li>
                                            <li>• Comma-separated values</li>
                                            <li>• Minimum size: 2×2 data matrix</li>
                                        </ul>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>

                    {/* Matrix Preview */}
                    {preview && (
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-medium mb-3">Matrix Preview ({preview.totalDimensions.P} × {preview.totalDimensions.N})</h3>
                            <div className="overflow-x-auto">
                                <table className="min-w-full text-sm">
                                    <tbody>
                                        {preview.data.map((row, i) => (
                                            <tr key={i}>
                                                {row.map((cell, j) => (
                                                    <td key={j} className="px-2 py-1 border border-gray-300 text-right font-mono">
                                                        {cell.toFixed(3)}
                                                    </td>
                                                ))}
                                                {preview.showMore && <td className="px-2 py-1 text-gray-400">...</td>}
                                            </tr>
                                        ))}
                                        {preview.showMore && (
                                            <tr>
                                                <td colSpan={preview.data[0].length + 1} className="px-2 py-1 text-center text-gray-400">⋮</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // FDR Analysis Panel Component
        const FDRAnalysisPanel = ({ matrix, matrixInfo, onResultsReady }) => {
            // Guard against null matrixInfo
            if (!matrixInfo || !matrixInfo.P) {
                return <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="text-center text-gray-500">Loading matrix information...</div>
                </div>;
            }
            
            const [parameters, setParameters] = useState({
                Nalpha: 20,
                nsupp: Math.min(50, Math.floor(matrixInfo.P / 2)),
                Nperm: 100
            });
            const [isRunning, setIsRunning] = useState(false);
            const [progress, setProgress] = useState({ current: 0, total: 0, message: '' });
            const [isCancelled, setIsCancelled] = useState(false);

            const handleParameterChange = (param, value) => {
                setParameters(prev => ({
                    ...prev,
                    [param]: parseInt(value)
                }));
            };

            const runAnalysis = async () => {
                setIsRunning(true);
                setProgress({ current: 0, total: 0, message: 'Initializing FDR analysis...' });

                try {
                    // Start keep-alive system and progress sync for long-running analysis
                    startKeepAlive();
                    startProgressSync();

                    // Expose setProgress globally for background sync
                    window.setProgress = setProgress;

                    const results = await runFDRAnalysisEnhanced({
                        matrix,
                        alpha0: 0,
                        alphaMax: matrixInfo.alphaMax,
                        Nalpha: parameters.Nalpha,
                        Nperm: parameters.Nperm,
                        nsupp: parameters.nsupp,
                        initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                        isCancelled: () => isCancelled,  // Pass cancellation check
                        onProgress: (current, total, message) => {
                            setProgress({ current, total, message });
                            // Save progress periodically
                            if (current % 10 === 0) {
                                saveFDRProgress({ current, total, message, parameters });
                            }
                        }
                    });

                    if (results.cancelled) {
                        setProgress({ current: 0, total: 0, message: 'Analysis cancelled by user' });
                        console.log('FDR analysis was cancelled');
                    } else {
                        // Capture elapsed time before clearing progress
                        const progressData = loadFDRProgress();
                        const elapsedTime = progressData?.elapsedTimeFormatted || null;

                        // Add elapsed time to results
                        results.elapsedTime = elapsedTime;

                        onResultsReady(results);
                        clearFDRProgress(true); // Clear saved progress and report final time
                    }
                } catch (error) {
                    // Only show alert if not cancelled
                    if (!isCancelled && !error.message?.includes('cancelled')) {
                        console.error('FDR Analysis failed:', error);
                        alert(`FDR Analysis failed: ${error.message}`);
                    } else {
                        console.log('🛑 FDR Analysis was cancelled - suppressing error:', error.message);
                    }
                } finally {
                    setIsRunning(false);
                    setIsCancelled(false);
                    stopKeepAlive(); // Stop keep-alive system
                    stopProgressSync(); // Stop progress sync system
                    window.setProgress = null; // Clean up global reference
                }
            };

            const cancelAnalysis = () => {
                setIsCancelled(true);
                setProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            const estimatedTime = Math.ceil((parameters.Nalpha * (1 + parameters.Nperm)) / 10); // rough estimate in seconds

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">FDR Analysis Parameters</h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                        {/* Nalpha Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Number of Alpha Values (Nalpha)
                            </label>
                            <input
                                type="range"
                                min="10"
                                max="100"
                                value={parameters.Nalpha}
                                onChange={(e) => handleParameterChange('Nalpha', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>10</span>
                                <span className="font-medium">{parameters.Nalpha}</span>
                                <span>100</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of alpha values to test between 0 and {matrixInfo.alphaMax.toFixed(6)}
                            </p>
                        </div>

                        {/* nsupp Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Expected Signal Features (nsupp)
                            </label>
                            <input
                                type="range"
                                min="1"
                                max={matrixInfo.P}
                                value={parameters.nsupp}
                                onChange={(e) => handleParameterChange('nsupp', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>1</span>
                                <span className="font-medium">{parameters.nsupp}</span>
                                <span>{matrixInfo.P}</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Expected number of true signal features (π₀ = {((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}% null)
                            </p>
                        </div>

                        {/* Nperm Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Permutation Tests (Nperm)
                            </label>
                            <input
                                type="range"
                                min="50"
                                max="1000"
                                value={parameters.Nperm}
                                onChange={(e) => handleParameterChange('Nperm', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>50</span>
                                <span className="font-medium">{parameters.Nperm}</span>
                                <span>1000</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of permutation tests per alpha value
                            </p>
                        </div>
                    </div>

                    {/* Analysis Summary */}
                    <div className="bg-gray-50 p-4 rounded-lg mb-4">
                        <h3 className="font-medium mb-2">Analysis Summary</h3>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Total runs:</span>
                                <span className="font-medium ml-2">{parameters.Nalpha * (1 + parameters.Nperm)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Est. time:</span>
                                <span className="font-medium ml-2">{Math.floor(estimatedTime / 60)}:{(estimatedTime % 60).toString().padStart(2, '0')}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Alpha range:</span>
                                <span className="font-medium ml-2">0 → {matrixInfo.alphaMax.toFixed(6)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">π₀:</span>
                                <span className="font-medium ml-2">{((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>

                    {/* Enhanced Progress Display with System Monitoring */}
                    {isRunning && (
                        <div className="bg-blue-50 p-4 rounded-lg mb-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-medium text-blue-800">
                                    {progress.message}
                                </span>
                                <span className="text-sm text-blue-600">
                                    {progress.current} / {progress.total}
                                </span>
                            </div>
                            <div className="w-full bg-blue-200 rounded-full h-2">
                                <div
                                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${progress.total > 0 ? (progress.current / progress.total) * 100 : 0}%` }}
                                ></div>
                            </div>
                            <div className="flex justify-between items-center mt-2">
                                <div className="text-xs text-blue-600">
                                    {progress.total > 0 ? `${((progress.current / progress.total) * 100).toFixed(1)}% complete` : 'Initializing...'}
                                </div>
                                {(() => {
                                    const stored = loadFDRProgress();
                                    return stored && stored.estimatedTimeRemaining ? (
                                        <div className="text-xs text-blue-600">
                                            ETA: {stored.estimatedTimeRemaining}
                                        </div>
                                    ) : null;
                                })()}
                            </div>

                            {/* System Resource Monitoring */}
                            {(() => {
                                const resources = getSystemResources();
                                return (
                                    <div className="mt-3 pt-3 border-t border-blue-200">
                                        <div className="grid grid-cols-2 gap-4 text-xs">
                                            <div>
                                                <div className="font-medium text-blue-700 mb-1">System Resources</div>
                                                {resources.memory.used && (
                                                    <div className="flex justify-between text-blue-600">
                                                        <span>Memory:</span>
                                                        <span>{resources.memory.used}MB / {resources.memory.limit}MB</span>
                                                    </div>
                                                )}
                                                <div className="flex justify-between text-blue-600">
                                                    <span>CPU Cores:</span>
                                                    <span>{resources.browser.hardwareConcurrency}</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Browser:</span>
                                                    <span>{resources.browser.userAgent}</span>
                                                </div>
                                            </div>
                                            <div>
                                                <div className="font-medium text-blue-700 mb-1">Performance</div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Web Worker:</span>
                                                    <span className="text-green-600">✓ Active</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Tab Throttling:</span>
                                                    <span className="text-green-600">✓ Protected</span>
                                                </div>
                                                <div className="flex justify-between text-blue-600">
                                                    <span>Progress Sync:</span>
                                                    <span className="text-green-600">✓ Background</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div className="mt-2 text-xs text-blue-500 text-center">
                                            💡 Analysis continues at full speed even when tab is in background
                                        </div>
                                    </div>
                                );
                            })()}
                        </div>
                    )}

                    {/* Resume Analysis Notification */}
                    {(() => {
                        const savedProgress = loadFDRProgress();
                        return savedProgress && !isRunning ? (
                            <div className="mb-4 p-4 bg-yellow-50 border border-yellow-200 rounded-lg">
                                <div className="flex items-center space-x-3">
                                    <div className="flex-shrink-0">
                                        <svg className="h-5 w-5 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                                            <path fillRule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.213 2.98-1.742 2.98H4.42c-1.53 0-2.493-1.646-1.743-2.98l5.58-9.92zM11 13a1 1 0 11-2 0 1 1 0 012 0zm-1-8a1 1 0 00-1 1v3a1 1 0 002 0V6a1 1 0 00-1-1z" clipRule="evenodd" />
                                        </svg>
                                    </div>
                                    <div className="flex-1">
                                        <h3 className="text-sm font-medium text-yellow-800">
                                            Interrupted Analysis Detected
                                        </h3>
                                        <div className="mt-1 text-sm text-yellow-700">
                                            <p>Progress: {savedProgress.current}/{savedProgress.total} - {savedProgress.message}</p>
                                            <p className="text-xs mt-1">Saved: {new Date(savedProgress.timestamp).toLocaleString()}</p>
                                        </div>
                                    </div>
                                    <div className="flex space-x-2">
                                        <button
                                            onClick={() => {
                                                // Clear saved progress and continue with new analysis
                                                clearFDRProgress();
                                                window.location.reload(); // Refresh to update UI
                                            }}
                                            className="px-3 py-1 text-xs bg-yellow-200 text-yellow-800 rounded hover:bg-yellow-300 transition-colors"
                                        >
                                            Start Fresh
                                        </button>
                                        <button
                                            onClick={() => {
                                                // For now, just start fresh as resume logic is complex
                                                // In a full implementation, this would restore parameters
                                                alert('Resume functionality: Clear the progress and run with the same parameters as shown above.');
                                                clearFDRProgress();
                                            }}
                                            className="px-3 py-1 text-xs bg-yellow-600 text-white rounded hover:bg-yellow-700 transition-colors"
                                        >
                                            Resume Analysis
                                        </button>
                                    </div>
                                </div>
                            </div>
                        ) : null;
                    })()}

                    {/* Run/Cancel Analysis Buttons */}
                    <div className="flex justify-end space-x-4">
                        {!isRunning ? (
                            <button
                                onClick={runAnalysis}
                                className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                                title="Run permutation-based False Discovery Rate analysis to estimate detection reliability"
                            >
                                Run FDR Analysis
                            </button>
                        ) : (
                            <div className="space-y-4">
                                <div className="flex items-center space-x-4">
                                    <div className="flex items-center space-x-2 text-indigo-600">
                                        <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600"></div>
                                        <span>Running Analysis...</span>
                                    </div>
                                    <button
                                        onClick={cancelAnalysis}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                    >
                                        Cancel
                                    </button>
                                </div>

                                {/* Performance Status Indicator */}
                                <div className="bg-blue-50 p-3 rounded-lg border border-blue-200">
                                    <div className="flex items-center justify-between">
                                        <div className="flex items-center space-x-2">
                                            <svg className="h-4 w-4 text-blue-500" fill="currentColor" viewBox="0 0 20 20">
                                                <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z" />
                                            </svg>
                                            <span className="text-sm font-medium text-blue-700">Web Worker Performance Mode</span>
                                        </div>
                                        <div className="text-xs text-blue-600">
                                            Tab throttling protected ✓
                                        </div>
                                    </div>
                                    <div className="mt-2 text-xs text-blue-600">
                                        Analysis continues uninterrupted even if you switch tabs or the computer sleeps.
                                        Keep this tab open for best performance monitoring.
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // FDR Results Display Component
        // Interactive FDR Chart Component
        const FDRChart = ({ data, selectedRowIndex, onRowSelect }) => {
            // Chart dimensions and margins
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Data ranges
            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const fdrRange = [Math.min(...data.fdrValues), Math.max(...data.fdrValues)];
            
            // Fixed view ranges (no zoom)
            const currentAlphaMin = alphaRange[0];
            const currentAlphaMax = alphaRange[1];
            const currentValueMin = 0;
            const currentValueMax = Math.max(100, Math.ceil(fdrRange[1] * 1.1));

            // Scale functions
            const xScale = (alpha) => margin.left + ((alpha - currentAlphaMin) / (currentAlphaMax - currentAlphaMin)) * chartWidth;
            const yScale = (fdr) => margin.top + ((currentValueMax - fdr) / (currentValueMax - currentValueMin)) * chartHeight;

            const handlePointClick = (index) => {
                console.log('🎯 FDR Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                onRowSelect(index);
            };

            // Generate axis ticks
            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(currentAlphaMin, currentAlphaMax);
            const yTicks = generateTicks(currentValueMin, currentValueMax);

            return (
                <div className="relative flex items-center justify-center">
                    
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        {/* Grid and Clipping */}
                        <defs>
                            <pattern id="fdrGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="fdrChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#fdrGrid)"/>
                        
                        {/* Axes */}
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {/* Y-axis ticks and labels */}
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(1)}
                                </text>
                            </g>
                        ))}
                        
                        {/* X-axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#fdrChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.fdrValues[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#EF4444" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.fdrValues[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#EF4444"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Click to select`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        {/* Axis labels */}
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            FDR (%)
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Detections Chart Component  
        const DetectionsChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const detectionRange = [0, Math.max(...data.detectionCounts)];

            const xScale = (alpha) => margin.left + ((alpha - alphaRange[0]) / (alphaRange[1] - alphaRange[0])) * chartWidth;
            const yScale = (detections) => margin.top + ((detectionRange[1] - detections) / (detectionRange[1] - detectionRange[0])) * chartHeight;

            const handlePointClick = (index) => {
                console.log('📊 Detections Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                // Always select and run SSVD on click
                onRowSelect(index);
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(alphaRange[0], alphaRange[1]);
            const yTicks = generateTicks(detectionRange[0], detectionRange[1]).map(t => Math.round(t));

            return (
                <div className="relative flex items-center justify-center">
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        <defs>
                            <pattern id="detectGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="detectChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#detectGrid)"/>
                        
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick}
                                </text>
                            </g>
                        ))}
                        
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#detectChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.detectionCounts[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#3B82F6" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.detectionCounts[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#3B82F6"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Click to select`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Number of Detections
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Gradient Chart Component
        const GradientChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const gradientRange = [Math.min(...data.gradients), Math.max(...data.gradients)];
            
            const xScale = (alpha) => margin.left + ((alpha - alphaRange[0]) / (alphaRange[1] - alphaRange[0])) * chartWidth;
            const yScale = (gradient) => margin.top + ((gradientRange[1] - gradient) / (gradientRange[1] - gradientRange[0])) * chartHeight;

            const handlePointClick = (index) => {
                console.log('📈 Gradient Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                onRowSelect(index);
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(alphaRange[0], alphaRange[1]);
            const yTicks = generateTicks(gradientRange[0], gradientRange[1]);

            return (
                <div className="w-full h-full flex items-center justify-center">
                    <svg width={width} height={height} className="border border-gray-300 bg-white">
                        {/* Grid lines */}
                        {xTicks.map((tick, i) => (
                            <line key={`v-${i}`} x1={xScale(tick)} y1={margin.top} x2={xScale(tick)} y2={height - margin.bottom} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        {yTicks.map((tick, i) => (
                            <line key={`h-${i}`} x1={margin.left} y1={yScale(tick)} x2={width - margin.right} y2={yScale(tick)} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        
                        {/* Zero line */}
                        <line x1={margin.left} y1={yScale(0)} x2={width - margin.right} y2={yScale(0)} stroke="#666" strokeWidth="2" strokeDasharray="5,5"/>
                        
                        {/* Data line */}
                        <path 
                            d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.gradients[i])}`).join(' L ')}`}
                            fill="none" 
                            stroke="#2563eb" 
                            strokeWidth="2"
                        />
                        
                        {/* Data points */}
                        {data.alphaValues.map((alpha, index) => {
                            const isSelected = selectedRowIndex === index;
                            return (
                                <circle
                                    key={index}
                                    cx={xScale(alpha)}
                                    cy={yScale(data.gradients[index])}
                                    r={isSelected ? "6" : "4"}
                                    fill={isSelected ? "#FFA500" : "#2563eb"}
                                    stroke={isSelected ? "#FF8C00" : "#1d4ed8"}
                                    strokeWidth="2"
                                    className="cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}${data.fdrValues && data.fdrValues[index] !== undefined && data.hasFDR ? `
eFDR: ${data.fdrValues[index].toFixed(2)}%` : ''}
Detections: ${data.detectionCounts[index]}
Gradient: ${data.gradients[index].toFixed(1)}
Click to select`}
                                    </title>
                                </circle>
                            );
                        })}
                        
                        {/* Axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(0)}
                                </text>
                            </g>
                        ))}
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Detection Gradient
                        </text>
                    </svg>
                </div>
            );
        };

        const FDRResultsDisplay = ({ results, onAlphaSelected, selectedAlpha, onRunSingleAlpha }) => {
            const [selectedIndex, setSelectedIndex] = useState(null);
            const tableRef = useRef(null);
            const rowRefs = useRef([]);

            const handleRowClick = (index) => {
                console.log('🎯 handleRowClick called with index:', index);
                console.log('Alpha value:', results.alphaValues[index]);
                console.log('onRunSingleAlpha exists?', !!onRunSingleAlpha);
                
                setSelectedIndex(index);
                onAlphaSelected(results.alphaValues[index]);
                
                // Run SSVD algorithm for selected alpha
                if (onRunSingleAlpha) {
                    console.log('✅ Calling onRunSingleAlpha with alpha:', results.alphaValues[index]);
                    onRunSingleAlpha(results.alphaValues[index]);
                } else {
                    console.log('❌ onRunSingleAlpha is not defined!');
                }
                
                // Scroll to selected row if needed
                if (rowRefs.current[index]) {
                    rowRefs.current[index].scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            };

            // Find optimal alpha (minimum eFDR with reasonable detections)
            const optimalIndex = results.fdrValues.reduce((minIndex, fdr, index) => {
                if (results.detectionCounts[index] > 0 && fdr < results.fdrValues[minIndex]) {
                    return index;
                }
                return minIndex;
            }, 0);

            const formatNumber = (num, decimals = 2) => {
                if (typeof num !== 'number' || isNaN(num)) return 'N/A';
                return num.toFixed(decimals);
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-semibold">FDR Analysis Results</h2>
                        <div className="text-sm text-gray-500">
                            Click a row to select alpha value
                        </div>
                    </div>

                    {/* Summary Statistics */}
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div className="bg-blue-50 p-3 rounded-lg">
                            <div className="text-sm text-blue-600 font-medium">Alpha Values</div>
                            <div className="text-lg font-bold text-blue-900">{results.alphaValues.length}</div>
                        </div>
                        <div className="bg-purple-50 p-3 rounded-lg">
                            <div className="text-sm text-purple-600 font-medium">Max Detections</div>
                            <div className="text-lg font-bold text-purple-900">{Math.max(...results.detectionCounts)}</div>
                        </div>
                        <div className="bg-orange-50 p-3 rounded-lg">
                            <div className="text-sm text-orange-600 font-medium">Optimal Alpha</div>
                            <div className="text-lg font-bold text-orange-900">{results.alphaValues[optimalIndex].toFixed(4)}</div>
                        </div>
                    </div>

                    {/* Results Table */}
                    <div className="overflow-x-auto" ref={tableRef}>
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Index
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Alpha
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        eFDR (%)
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Detections
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Gradient
                                    </th>
                                </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                                {results.alphaValues.map((alpha, index) => {
                                    const isSelected = selectedIndex === index;
                                    const isOptimal = index === optimalIndex;
                                    
                                    return (
                                        <tr 
                                            key={index}
                                            ref={el => rowRefs.current[index] = el}
                                            className={`cursor-pointer transition-all duration-200 ${
                                                isSelected 
                                                    ? 'bg-indigo-100 hover:bg-indigo-200 shadow-md border-l-4 border-indigo-500' 
                                                    : isOptimal 
                                                        ? 'bg-yellow-50 hover:bg-yellow-100' 
                                                        : 'hover:bg-gray-50'
                                            }`}
                                            onClick={() => handleRowClick(index)}
                                        >
                                            <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {index + 1}
                                                {isOptimal && <span className="ml-1 text-xs text-yellow-600">★</span>}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900 font-mono">
                                                {alpha.toFixed(4)}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`inline-flex px-2 py-1 rounded-full text-xs font-medium ${
                                                    results.fdrValues[index] <= 5 ? 'bg-green-100 text-green-800' :
                                                    results.fdrValues[index] <= 10 ? 'bg-yellow-100 text-yellow-800' :
                                                    'bg-red-100 text-red-800'
                                                }`}>
                                                    {formatNumber(results.fdrValues[index], 1)}%
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                {results.detectionCounts[index]}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`${
                                                    results.gradients[index] > 0 ? 'text-green-600' : 
                                                    results.gradients[index] < 0 ? 'text-red-600' : 'text-gray-500'
                                                }`}>
                                                    {formatNumber(results.gradients[index], 0)}
                                                </span>
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>

                    {/* Selection Status */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 p-4 bg-indigo-50 rounded-lg">
                            <h3 className="font-medium text-indigo-800 mb-2">Selected Alpha for SSVD-R1 Analysis</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                <div>
                                    <span className="text-indigo-600">Alpha:</span>
                                    <span className="font-medium ml-2">{selectedAlpha.toFixed(4)}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">eFDR:</span>
                                    <span className="font-medium ml-2">{formatNumber(results.fdrValues[selectedIndex], 1)}%</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Expected Detections:</span>
                                    <span className="font-medium ml-2">{results.detectionCounts[selectedIndex]}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Index:</span>
                                    <span className="font-medium ml-2">{selectedIndex + 1} / {results.alphaValues.length}</span>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Interactive Analysis Plots */}
                    <div className="mt-6 space-y-6">
                        {/* eFDR vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <FDRChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detections vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <DetectionsChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detection Gradient vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <GradientChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>
                    </div>

                    {/* Next Steps */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 bg-green-50 p-4 rounded-lg">
                            <h3 className="font-medium text-green-800 mb-2">Next: Run SSVD-R1 Algorithm</h3>
                            <p className="text-sm text-green-700">
                                Ready to run SSVD-R1 algorithm with selected alpha = {selectedAlpha.toFixed(4)}. 
                                This will perform sparse SVD decomposition and generate visualization results.
                            </p>
                        </div>
                    )}
                </div>
            );
        };

        // Reusable Histogram Component (Line Plot)
        const HistogramChart = React.memo(({ data, title, xLabel, yLabel, bins = 64 }) => {
            const createHistogramData = (values, numBins) => {
                if (!values.length) return { labels: [], data: [] };
                
                const min = Math.min(...values);
                const max = Math.max(...values);
                const binWidth = (max - min) / numBins;
                
                const binLabels = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin labels
                for (let i = 0; i < numBins; i++) {
                    const binStart = min + i * binWidth;
                    const binEnd = min + (i + 1) * binWidth;
                    binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                }
                
                // Count values in each bin
                values.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binLabels, data: binCounts };
            };

            const histogramData = createHistogramData(data, bins);
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: title,
                    data: histogramData.data,
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                    pointBorderColor: 'rgba(59, 130, 246, 1)',
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false
                }]
            };

            const options = {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: title,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    x: {
                        title: { display: true, text: xLabel },
                        ticks: { maxRotation: 45 }
                    },
                    y: {
                        title: { display: true, text: yLabel },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm">
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        }, (prevProps, nextProps) => {
            // Custom comparison for memo - only re-render if data actually changed
            return JSON.stringify(prevProps.data) === JSON.stringify(nextProps.data) &&
                   prevProps.title === nextProps.title &&
                   prevProps.xLabel === nextProps.xLabel &&
                   prevProps.yLabel === nextProps.yLabel &&
                   prevProps.bins === nextProps.bins;
        });

        // Matrix Values Histogram Component (Line Plot with Circle Markers)
        const MatrixHistogram = React.memo(({ matrixData, title, color = 'rgba(59, 130, 246, 1)', bins = 64 }) => {
            const createMatrixHistogram = (matrix, numBins) => {
                if (!matrix || !matrix.length) return { labels: [], data: [] };
                
                // Memory-efficient approach for large matrices
                const P = matrix.length;
                const N = matrix[0].length;
                const totalElements = P * N;
                
                // Use sampling for large matrices to avoid memory issues
                const sampleSize = Math.min(10000, totalElements);
                let samples = [];
                let min = Infinity, max = -Infinity;
                
                if (totalElements <= 10000) {
                    // Small matrix: use all values
                    for (let i = 0; i < P; i++) {
                        for (let j = 0; j < N; j++) {
                            const val = matrix[i][j];
                            samples.push(val);
                            if (val < min) min = val;
                            if (val > max) max = val;
                        }
                    }
                } else {
                    // Large matrix: random sampling
                    for (let s = 0; s < sampleSize; s++) {
                        const i = Math.floor(Math.random() * P);
                        const j = Math.floor(Math.random() * N);
                        const val = matrix[i][j];
                        samples.push(val);
                        if (val < min) min = val;
                        if (val > max) max = val;
                    }
                }
                
                if (!samples.length) return { labels: [], data: [] };
                const binWidth = (max - min) / numBins;
                
                const binCenters = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin center labels for better line plot visualization
                for (let i = 0; i < numBins; i++) {
                    const binCenter = min + (i + 0.5) * binWidth;
                    binCenters.push(binCenter.toFixed(4));
                }
                
                // Count values in each bin
                samples.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binCenters, data: binCounts };
            };

            const histogramData = createMatrixHistogram(matrixData, bins);
            const totalValues = matrixData ? matrixData.length * matrixData[0].length : 0;
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: `${title} (${totalValues.toLocaleString()} values)`,
                    data: histogramData.data,
                    borderColor: color,
                    backgroundColor: color.replace('1)', '0.2)'),
                    pointBackgroundColor: color,
                    pointBorderColor: color,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                }]
            };

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: `${title} Distribution (${bins} bins)`,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: true },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const binValue = parseFloat(context.label);
                                const count = context.parsed.y;
                                const percentage = ((count / totalValues) * 100).toFixed(2);
                                return [
                                    `Bin center: ${binValue.toFixed(4)}`,
                                    `Count: ${count.toLocaleString()}`,
                                    `Percentage: ${percentage}%`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Matrix Value' },
                        ticks: {
                            maxTicksLimit: 8,
                            callback: function(value, index) {
                                return parseFloat(this.getLabelForValue(value)).toFixed(3);
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Frequency' },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm" style={{ height: '400px' }}>
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        });

        // Signal/Noise Analysis Component with Interactive Charts
        const SignalNoiseAnalysis = ({ eigenvalues }) => {
            const [selectedBoundary, setSelectedBoundary] = useState(null);
            const [spectralSNR, setSpectralSNR] = useState(null);
            const chartRefs = useRef({ eigenvalue: null, gradient: null, ratio: null });
            
            // Guard against non-array eigenvalues
            if (!Array.isArray(eigenvalues) || eigenvalues.length === 0) {
                return (
                    <div className="bg-white p-4 rounded-lg shadow-sm border-2 border-dashed border-yellow-300">
                        <div className="text-center text-gray-600 py-8">
                            <div className="text-4xl mb-4">⚠️</div>
                            <h3 className="font-medium text-lg mb-2 text-yellow-800">Eigenvalue Analysis Unavailable</h3>
                            <p className="text-sm mb-4">
                                No eigenvalue data available for analysis.
                            </p>
                        </div>
                    </div>
                );
            }

            // Filter and prepare eigenvalues
            const positiveEigenvalues = eigenvalues.filter(val => val > 1e-8);
            
            // Calculate gradients and ratios
            const gradients = [];
            const ratios = [];
            for (let i = 0; i < positiveEigenvalues.length - 1; i++) {
                gradients.push(positiveEigenvalues[i] - positiveEigenvalues[i + 1]);
                ratios.push(positiveEigenvalues[i] / positiveEigenvalues[i + 1]);
            }
            
            // Calculate spectral SNR when boundary is selected
            const calculateSpectralSNR = (boundaryIndex) => {
                if (boundaryIndex === null || boundaryIndex === 0 || boundaryIndex >= positiveEigenvalues.length) {
                    return null;
                }
                const signalEvals = positiveEigenvalues.slice(0, boundaryIndex);
                const noiseEvals = positiveEigenvalues.slice(boundaryIndex);
                const signalSum = signalEvals.reduce((a, b) => a + b, 0);
                const noiseSum = noiseEvals.reduce((a, b) => a + b, 0);
                
                if (noiseSum === 0) return Infinity;
                return 10 * Math.log10(signalSum / noiseSum);
            };

            // Update charts when boundary changes
            useEffect(() => {
                const charts = [];
                
                // Eigenvalue Chart
                if (chartRefs.current.eigenvalue) {
                    const ctx = chartRefs.current.eigenvalue.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: positiveEigenvalues.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Eigenvalue',
                            data: positiveEigenvalues,
                            borderColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            backgroundColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 0.2)' : 'rgba(59, 130, 246, 0.2)'
                            ),
                            pointBackgroundColor: positiveEigenvalues.map((_, i) => 
                                i === selectedBoundary ? 'rgba(239, 68, 68, 1)' : 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            pointRadius: positiveEigenvalues.map((_, i) => i === selectedBoundary ? 6 : 3),
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Spectrum (Click to set boundary)',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Index: ${context.dataIndex + 1}, Eigenvalue: ${context.parsed.y.toFixed(4)}`;
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary,
                                        xMax: selectedBoundary,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Eigenvalue Index' }
                            },
                            y: {
                                title: { display: true, text: 'Eigenvalue Magnitude' },
                                type: 'linear',
                                min: 0
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                setSelectedBoundary(index);
                                const snr = calculateSpectralSNR(index);
                                setSpectralSNR(snr);
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Gradient Chart
                if (chartRefs.current.gradient && gradients.length > 0) {
                    const ctx = chartRefs.current.gradient.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: gradients.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Gradient',
                            data: gradients,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.2)',
                            pointBackgroundColor: gradients.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(34, 197, 94, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Gradient',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const gradient = context.parsed.y;
                                        const eigenval1 = positiveEigenvalues[idx];
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Gradient: ${gradient.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Drop: ${((gradient / eigenval1) * 100).toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Gradient Value' },
                                type: 'linear',
                                min: 0
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Ratio Chart
                if (chartRefs.current.ratio && ratios.length > 0) {
                    const ctx = chartRefs.current.ratio.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: ratios.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Ratio',
                            data: ratios,
                            borderColor: 'rgba(168, 85, 247, 1)',
                            backgroundColor: 'rgba(168, 85, 247, 0.2)',
                            pointBackgroundColor: ratios.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(168, 85, 247, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Ratio',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const ratio = context.parsed.y;
                                        const percentChange = ((1 - (1/ratio)) * 100);
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Ratio: ${ratio.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Change: -${percentChange.toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Ratio Value' },
                                type: 'linear',
                                min: 1
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Cleanup function to destroy charts when component unmounts or updates
                return () => {
                    charts.forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [selectedBoundary, positiveEigenvalues.length]); // Simplified dependencies

            return (
                <div className="bg-white p-6 rounded-lg shadow-sm">
                    <h3 className="text-lg font-semibold mb-4">Signal/Noise Subspace Analysis</h3>
                    
                    {/* Charts Stack - Vertical Layout with Increased Size */}
                    <div className="space-y-6 mb-6">
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.eigenvalue = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.gradient = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.ratio = el} style={{height: '300px'}} />
                        </div>
                    </div>
                    
                    {/* SNR Results */}
                    {selectedBoundary !== null && (
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Selected Boundary</p>
                                    <p className="text-lg font-bold text-blue-700">Index {selectedBoundary + 1}</p>
                                    <p className="text-xs text-blue-600">First noise eigenvalue</p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Signal Subspace</p>
                                    <p className="text-lg font-bold text-blue-700">Eigenvalues 1-{selectedBoundary}</p>
                                    <p className="text-xs text-blue-600">
                                        Sum: {positiveEigenvalues.slice(0, selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Spectral SNR</p>
                                    <p className="text-lg font-bold text-blue-700">
                                        {spectralSNR !== null ? 
                                            (isFinite(spectralSNR) ? `${spectralSNR.toFixed(2)} dB` : '∞ dB') : 
                                            'N/A'}
                                    </p>
                                    <p className="text-xs text-blue-600">
                                        Noise sum: {positiveEigenvalues.slice(selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Instructions */}
                    {selectedBoundary === null && (
                        <div className="text-center text-gray-500 text-sm mt-4">
                            <p>Click on any point in the eigenvalue plot to set the signal/noise boundary</p>
                            <p>Hover over points to see detailed values</p>
                        </div>
                    )}
                </div>
            );
        };

        // Keep backward compatibility - alias the old component name
        const EigenvalueSpectrumChart = SignalNoiseAnalysis;

        // Data Summary Bar Component
        const DataSummaryBar = ({ filename, statistics }) => {
            if (!statistics) return null;

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl mb-4 flex items-center gap-2">
                        <span className="text-blue-600">📊</span>
                        <span className="font-bold">Data Overview:</span> {filename}
                    </h2>
                    <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                        {/* Dimensions */}
                        <div className="bg-blue-50 p-4 rounded-lg">
                            <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                            <div className="text-2xl font-bold text-blue-900">{statistics.P} × {statistics.N}</div>
                            <div className="text-xs text-blue-600 mt-1">Features × Samples</div>
                        </div>

                        {/* Range */}
                        <div className="bg-green-50 p-4 rounded-lg">
                            <div className="text-sm text-green-600 font-medium">Range</div>
                            <div className="text-lg font-bold text-green-900">
                                [{formatSmallValue(statistics.min)}, {formatSmallValue(statistics.max)}]
                            </div>
                            <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                        </div>

                        {/* Mean */}
                        <div className="bg-purple-50 p-4 rounded-lg">
                            <div className="text-sm text-purple-600 font-medium">Global Mean</div>
                            <div className="text-lg font-bold text-purple-900">{formatSmallValue(statistics.mean)}</div>
                            <div className="text-xs text-purple-600 mt-1">All elements</div>
                        </div>

                        {/* Std Dev */}
                        <div className="bg-orange-50 p-4 rounded-lg">
                            <div className="text-sm text-orange-600 font-medium">Global Std Dev</div>
                            <div className="text-lg font-bold text-orange-900">{formatSmallValue(statistics.stdDev)}</div>
                            <div className="text-xs text-orange-600 mt-1">All elements</div>
                        </div>

                        {/* Frobenius Norm */}
                        <div className="bg-cyan-50 p-4 rounded-lg">
                            <div className="text-sm text-cyan-600 font-medium">Frobenius Norm</div>
                            <div className="text-lg font-bold text-cyan-900">
                                {statistics.frobeniusNorm?.toFixed(4)}
                            </div>
                            <div className="text-xs text-cyan-600 mt-1">
                                {Math.abs((statistics.frobeniusNorm ?? 0) - 1.0) < 0.01 ? '✓ Normalized' : 'Not normalized'}
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        // Analysis Parameters Display Component
        const AnalysisParametersDisplay = ({ parameters, title = "Analysis Configuration" }) => {
            if (!parameters) return null;
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-2xl font-bold text-gray-800 mb-4">{title}</h2>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                        {parameters.analysisType && (
                            <div>
                                <span className="text-gray-500">Analysis Type:</span>
                                <div className="font-medium text-gray-900 capitalize">
                                    {parameters.analysisType === 'efdr' ? 'eFDR Analysis' : 
                                     parameters.analysisType === 'alpha' ? 'N-Alpha Analysis' : 
                                     'Single Alpha'}
                                </div>
                            </div>
                        )}
                        {parameters.alpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.alpha0 !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Min:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha0.toFixed(6)}</div>
                            </div>
                        )}
                        {parameters.alphaMax !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Max:</span>
                                <div className="font-medium text-gray-900">{parameters.alphaMax.toFixed(6)}</div>
                            </div>
                        )}
                        {parameters.Nalpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Count:</span>
                                <div className="font-medium text-gray-900">{parameters.Nalpha}</div>
                            </div>
                        )}
                        {parameters.Nperm !== undefined && (
                            <div>
                                <span className="text-gray-500">Permutations:</span>
                                <div className="font-medium text-gray-900">{parameters.Nperm}</div>
                            </div>
                        )}
                        {parameters.nsupp !== undefined && (
                            <div>
                                <span className="text-gray-500">Support Size:</span>
                                <div className="font-medium text-gray-900">{parameters.nsupp}</div>
                            </div>
                        )}
                        {parameters.matrixSize && (
                            <div>
                                <span className="text-gray-500">Matrix Size:</span>
                                <div className="font-medium text-gray-900">{parameters.matrixSize}</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Alpha Sequence Results Display Component
        const AlphaSequenceResultsDisplay = ({ results, selectedIndex, onSelectAlpha, onNewAnalysis, onResetToOriginal, onRunSingleAlpha }) => {
            const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
            
            // Debug logging
            console.log('AlphaSequenceResultsDisplay rendering with results:', results);
            console.log('Has FDR?', results.hasFDR);
            console.log('First result eFDR:', results.results?.[0]?.eFDR);
            
            // Calculate detection gradients
            const resultsWithGradients = useMemo(() => {
                if (!results.results) {
                    console.error('No results.results array found!');
                    return [];
                }
                const data = results.results.map((r, i) => {
                    let gradient = 0;
                    if (i > 0) {
                        gradient = r.detections - results.results[i-1].detections;
                    }
                    return { ...r, gradient, index: i };
                });
                return data;
            }, [results]);
            
            // Sort function
            const sortedResults = useMemo(() => {
                if (!sortConfig.key) return resultsWithGradients;
                
                return [...resultsWithGradients].sort((a, b) => {
                    let aValue = a[sortConfig.key];
                    let bValue = b[sortConfig.key];
                    
                    if (aValue < bValue) {
                        return sortConfig.direction === 'asc' ? -1 : 1;
                    }
                    if (aValue > bValue) {
                        return sortConfig.direction === 'asc' ? 1 : -1;
                    }
                    return 0;
                });
            }, [resultsWithGradients, sortConfig]);
            
            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
                }));
            };
            
            // Export functionality for multi-alpha results
            const [showMultiExportMenu, setShowMultiExportMenu] = useState(false);
            const exportMenuRef = useRef(null);

            // Click-outside handler to close export menu
            useEffect(() => {
                const handleClickOutside = (event) => {
                    if (exportMenuRef.current && !exportMenuRef.current.contains(event.target)) {
                        setShowMultiExportMenu(false);
                    }
                };

                if (showMultiExportMenu) {
                    document.addEventListener('mousedown', handleClickOutside);
                    return () => document.removeEventListener('mousedown', handleClickOutside);
                }
            }, [showMultiExportMenu]);

            const handleExportMultiAlphaResults = () => {
                try {
                    console.log('🔄 Starting multi-alpha export...');
                    console.log('Results data:', results);
                    console.log('Results with gradients:', resultsWithGradients);
                    
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    const headers = results.hasFDR 
                        ? ['Alpha', 'Detections', 'eFDR_Percent', 'Sparsity_Percent', 'Detection_Gradient']
                        : ['Alpha', 'Detections', 'Sparsity_Percent', 'Detection_Gradient'];
                    
                    const rows = resultsWithGradients.map(r => {
                        console.log('Processing result row:', r);
                        console.log('Row properties:', {
                            alpha: r.alpha,
                            detections: r.detections,
                            eFDR: r.eFDR,
                            sparsity: r.sparsity,
                            gradient: r.gradient
                        });
                        
                        if (results.hasFDR) {
                            return [
                                (r.alpha ?? 0).toFixed(6),
                                r.detections ?? 0,
                                (r.eFDR ?? 0).toFixed(2),
                                (r.sparsity ?? 0).toFixed(2),
                                r.gradient ?? 0
                            ];
                        } else {
                            return [
                                (r.alpha ?? 0).toFixed(6),
                                r.detections ?? 0,
                                (r.sparsity ?? 0).toFixed(2),
                                r.gradient ?? 0
                            ];
                        }
                    });
                    
                    console.log('CSV headers:', headers);
                    console.log('CSV rows sample:', rows.slice(0, 3));
                    
                    const csvContent = Papa.unparse({ fields: headers, data: rows });
                    const filename = `SSVD1x_MultiAlpha_${results.hasFDR ? 'eFDR_' : ''}Results_${timestamp}.csv`;
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    saveAs(blob, filename);
                    console.log('✅ Multi-alpha results exported:', filename);
                    setShowMultiExportMenu(false);
                } catch (error) {
                    console.error('❌ Error exporting multi-alpha results:', error);
                    alert('Error exporting multi-alpha results: ' + error.message);
                }
            };

            const handleExportSelectedAlpha = () => {
                try {
                    console.log('🔄 Starting selected alpha export...');
                    console.log('Selected index:', selectedIndex);
                    console.log('Results with gradients length:', resultsWithGradients.length);
                    
                    if (selectedIndex === null || selectedIndex === undefined || !resultsWithGradients[selectedIndex]) {
                        alert('Please select an alpha value from the table first.');
                        return;
                    }
                    
                    const selectedResult = resultsWithGradients[selectedIndex];
                    console.log('Selected result:', selectedResult);
                    
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                    
                    const metadata = [
                        ['Parameter', 'Value'],
                        ['Export_Date', new Date().toISOString()],
                        ['Selected_Alpha', (selectedResult.alpha ?? 0).toFixed(6)],
                        ['Detections', selectedResult.detections ?? 0],
                        ['Sparsity_Percent', (selectedResult.sparsity ?? 0).toFixed(2)],
                        ['Detection_Gradient', selectedResult.gradient ?? 0],
                        ...(results.hasFDR ? [['eFDR_Percent', (selectedResult.eFDR ?? 0).toFixed(2)]] : [])
                    ];
                    
                    console.log('Metadata:', metadata);
                    
                    const csvContent = Papa.unparse(metadata);
                    const filename = `SSVD1x_Selected_Alpha_${selectedResult.alpha.toFixed(4)}_${timestamp}.csv`;
                    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
                    saveAs(blob, filename);
                    console.log('✅ Selected alpha exported:', filename);
                    setShowMultiExportMenu(false);
                } catch (error) {
                    console.error('❌ Error exporting selected alpha:', error);
                    alert('Error exporting selected alpha: ' + error.message);
                }
            };
            
            return (
                <div className="space-y-6">
                    {/* Analysis Parameters */}
                    <AnalysisParametersDisplay 
                        parameters={results.parameters}
                        title={results.analysisType === 'efdr' ? "eFDR Parameters" : "N-Alpha Configuration"}
                    />
                    
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <div>
                                <h2 className="text-2xl font-semibold text-gray-800">
                                    {results.analysisType === 'efdr' ? 'eFDR Table' : 'N-Alpha Table'}
                                </h2>
                                <p className="text-sm text-gray-600 mt-1">
                                    Analyzed {results.alphaValues.length} alpha values from {results.alphaValues[0].toFixed(6)} to {results.alphaValues[results.alphaValues.length - 1].toFixed(6)}
                                </p>
                            </div>
                            <div className="flex items-center gap-3">
                                {/* Back Button */}
                                <button
                                    onClick={onNewAnalysis}
                                    className="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                    title="Back to analysis selection"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                                    </svg>
                                    Back
                                </button>

                                {/* Reset Button */}
                                <button
                                    onClick={onResetToOriginal}
                                    className="bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                    title="Reset and upload new data"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    Reset
                                </button>

                                {/* Export Button */}
                                <div className="relative" ref={exportMenuRef}>
                                    <button
                                        onClick={() => setShowMultiExportMenu(!showMultiExportMenu)}
                                        className="bg-gradient-to-r from-green-600 to-blue-600 hover:from-green-700 hover:to-blue-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                        title="Export analysis results"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                        </svg>
                                        Export
                                        <svg className={`w-4 h-4 transition-transform ${showMultiExportMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </button>

                                    {showMultiExportMenu && (
                                        <div className="absolute right-0 mt-2 w-56 bg-white rounded-lg shadow-xl border border-gray-200 z-50">
                                            <div className="p-3 border-b border-gray-200">
                                                <h3 className="text-sm font-semibold text-gray-800">Export Multi-Alpha Results</h3>
                                                <p className="text-xs text-gray-600">{results.alphaValues.length} alpha values</p>
                                            </div>
                                            <div className="p-2 space-y-1">
                                                <button
                                                    onClick={handleExportMultiAlphaResults}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded-md flex items-center gap-2"
                                                >
                                                    <span className="text-blue-600">📊</span>
                                                    All Alpha Results (CSV)
                                                </button>
                                                <button
                                                    onClick={handleExportSelectedAlpha}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-green-50 rounded-md flex items-center gap-2"
                                                    disabled={selectedIndex === null}
                                                >
                                                    <span className="text-green-600">🎯</span>
                                                    Selected Alpha Only (CSV)
                                                </button>
                                                <button
                                                    onClick={() => {
                                                        exportChartsAsImages();
                                                        setShowMultiExportMenu(false);
                                                    }}
                                                    className="w-full text-left px-3 py-2 text-sm hover:bg-purple-50 rounded-md flex items-center gap-2"
                                                >
                                                    <span className="text-purple-600">📈</span>
                                                    Charts (PNG)
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                        </div>
                        
                        {/* Summary Statistics */}
                        {results.hasFDR && (
                            <div className="grid grid-cols-5 gap-4 mb-6">
                                <div className="bg-green-50 p-4 rounded-lg">
                                    <div className="text-sm text-green-600 font-medium">Max Detections</div>
                                    <div className="text-2xl font-bold text-green-900">
                                        {Math.max(...results.results.map(r => r.detections))}
                                    </div>
                                    <div className="text-xs text-green-600 mt-1">
                                        Across all alpha values
                                    </div>
                                </div>
                                <div className="bg-yellow-50 p-4 rounded-lg border border-yellow-200">
                                    <div className="text-sm text-yellow-700 font-medium">Min Detections</div>
                                    <div className="text-2xl font-bold text-yellow-900">
                                        {Math.min(...results.results.map(r => r.detections))}
                                    </div>
                                    <div className="text-xs text-yellow-600 mt-1">
                                        Across all alpha values
                                    </div>
                                </div>
                                <div className="bg-orange-50 p-4 rounded-lg">
                                    <div className="text-sm text-orange-600 font-medium">Permutations</div>
                                    <div className="text-2xl font-bold text-orange-900">
                                        {results.Nperm || 'N/A'}
                                    </div>
                                    <div className="text-xs text-orange-600 mt-1">
                                        Per alpha value
                                    </div>
                                </div>
                                <div className="bg-purple-50 p-4 rounded-lg">
                                    <div className="text-sm text-purple-600 font-medium">Total Runs</div>
                                    <div className="text-2xl font-bold text-purple-900">
                                        {results.fdrResults?.totalRuns || results.results.length}
                                    </div>
                                    <div className="text-xs text-purple-600 mt-1">
                                        {results.Nalpha} alphas × {(results.Nperm || 0) + 1} runs each
                                    </div>
                                </div>
                                <div className="bg-indigo-50 p-4 rounded-lg">
                                    <div className="text-sm text-indigo-600 font-medium">Total Runtime</div>
                                    <div className="text-2xl font-bold text-indigo-900">
                                        {results.elapsedTime || 'N/A'}
                                    </div>
                                    <div className="text-xs text-indigo-600 mt-1">
                                        Analysis duration
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Results Table */}
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-200">
                                <thead className="bg-gray-50">
                                    <tr>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('index')}
                                        >
                                            Index {sortConfig.key === 'index' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('alpha')}
                                        >
                                            Alpha {sortConfig.key === 'alpha' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('detections')}
                                        >
                                            Detections {sortConfig.key === 'detections' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('gradient')}
                                        >
                                            Detection Gradient {sortConfig.key === 'gradient' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        {results.hasFDR && (
                                            <th 
                                                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                                onClick={() => handleSort('eFDR')}
                                            >
                                                eFDR (%) {sortConfig.key === 'eFDR' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                            </th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody className="bg-white divide-y divide-gray-200">
                                    {sortedResults.map((result) => (
                                        <tr 
                                            key={result.index}
                                            className={`hover:bg-gray-50 cursor-pointer ${selectedIndex === result.index ? 'bg-blue-50 border-l-4 border-blue-500' : ''}`}
                                            onClick={() => {
                                                console.log('Row clicked, index:', result.index, 'alpha:', result.alpha);
                                                onSelectAlpha(result.index);

                                                // Automatically trigger single alpha analysis like SSVD1 app
                                                if (onRunSingleAlpha) {
                                                    console.log('Auto-triggering single alpha analysis for α =', result.alpha);
                                                    onRunSingleAlpha(result.alpha);
                                                }
                                            }}
                                        >
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {result.index + 1}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.alpha.toFixed(6)}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.detections}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <span className={`inline-flex items-center ${
                                                    result.gradient > 0 ? 'text-green-600' : 
                                                    result.gradient < 0 ? 'text-red-600' : 
                                                    'text-gray-600'
                                                }`}>
                                                    {result.gradient > 0 && '+'}{result.gradient}
                                                    {result.gradient > 0 && ' ↑'}
                                                    {result.gradient < 0 && ' ↓'}
                                                </span>
                                            </td>
                                            {results.hasFDR && (
                                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                    <span className={`font-medium ${
                                                        result.eFDR < 5 ? 'text-green-600' :
                                                        result.eFDR < 10 ? 'text-yellow-600' :
                                                        'text-red-600'
                                                    }`}>
                                                        {typeof result.eFDR === 'number' ? result.eFDR.toFixed(2) : 'N/A'}
                                                    </span>
                                                </td>
                                            )}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>

                        {/* Interactive Analysis Plots for Alpha Sequence Results */}
                        {results && results.results && results.results.length > 0 && (
                            <div className="mt-6 space-y-6">
                                {/* eFDR vs Alpha Plot */}
                                {results.hasFDR && (
                                    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                        <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                                        <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                            <FDRChart
                                                data={{
                                                    alphaValues: resultsWithGradients.map(r => r.alpha),
                                                    fdrValues: resultsWithGradients.map(r => r.eFDR || 0),
                                                    detectionCounts: resultsWithGradients.map(r => r.detections),
                                                    gradients: resultsWithGradients.map(r => r.gradient || 0),
                                                    hasFDR: results.hasFDR
                                                }} 
                                                selectedRowIndex={selectedIndex} 
                                                onRowSelect={(index) => {
                                                    onSelectAlpha(index);
                                                    if (onRunSingleAlpha && results.results[index]) {
                                                        onRunSingleAlpha(results.results[index].alpha);
                                                    }
                                                }} 
                                            />
                                        </div>
                                    </div>
                                )}

                                {/* Detections vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <DetectionsChart
                                            data={{
                                                alphaValues: resultsWithGradients.map(r => r.alpha),
                                                fdrValues: resultsWithGradients.map(r => r.eFDR || 0),
                                                detectionCounts: resultsWithGradients.map(r => r.detections),
                                                gradients: resultsWithGradients.map(r => r.gradient || 0),
                                                hasFDR: results.hasFDR
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>

                                {/* Detection Gradient vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <GradientChart
                                            data={{
                                                alphaValues: resultsWithGradients.map(r => r.alpha),
                                                fdrValues: resultsWithGradients.map(r => r.eFDR || 0),
                                                detectionCounts: resultsWithGradients.map(r => r.detections),
                                                gradients: resultsWithGradients.map(r => r.gradient || 0),
                                                hasFDR: results.hasFDR
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>
                                
                                {/* Selected Alpha Details - moved here after charts */}
                                {selectedIndex !== null && resultsWithGradients[selectedIndex] && (
                                    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                        <h3 className="font-medium text-gray-700 mb-2">Selected Alpha Details</h3>
                                        <div className="grid grid-cols-4 gap-4 text-sm">
                                            <div>
                                                <span className="text-gray-600">Index:</span>
                                                <span className="ml-2 font-medium">{selectedIndex + 1}</span>
                                            </div>
                                            <div>
                                                <span className="text-gray-600">Alpha:</span>
                                                <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].alpha.toFixed(6)}</span>
                                            </div>
                                            <div>
                                                <span className="text-gray-600">Detections:</span>
                                                <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].detections}</span>
                                            </div>
                                            {results.hasFDR && (
                                                <div>
                                                    <span className="text-gray-600">eFDR:</span>
                                                    <span className="ml-2 font-medium">{typeof resultsWithGradients[selectedIndex].eFDR === 'number' ? resultsWithGradients[selectedIndex].eFDR.toFixed(2) + '%' : 'N/A'}</span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Analysis Selection Steps Component
        const AnalysisSelectionSteps = ({ analysisStep, onStepSelect, onBackToReview, onReset }) => {
            if (!analysisStep) {
                // Step 1: Single vs Multi Alpha
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Analysis Type</h2>
                            <div className="flex items-center gap-3">
                                {/* Back Button */}
                                <button
                                    onClick={onBackToReview}
                                    className="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                    title="Back to data review"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                                    </svg>
                                    Back
                                </button>

                                {/* Reset Button */}
                                <button
                                    onClick={() => {
                                        if (confirm('Reset all data and return to file upload? This will clear all analysis results.')) {
                                            onReset();
                                        }
                                    }}
                                    className="bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                    title="Reset and upload new data"
                                >
                                    <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                    </svg>
                                    Reset
                                </button>
                            </div>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('single')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Single Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Run SSVD with one specific alpha value to get detailed results and visualizations
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('multi')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Multi-Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Test multiple alpha values systematically to find optimal sparsity parameters
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            if (analysisStep === 'multi') {
                // Step 2: Alpha Analysis vs eFDR Analysis
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Multi-Alpha Analysis Type</h2>
                            <div className="flex space-x-3">
                                <button
                                    onClick={() => onStepSelect(null)}
                                    className="px-4 py-2 border border-slate-300 text-slate-600 bg-slate-50 rounded-md hover:bg-blue-50 hover:border-blue-300 hover:text-blue-700 transition-colors"
                                >
                                    ← Back
                                </button>
                                <button
                                    onClick={() => {
                                        if (confirm('Reset all data and return to file upload? This will clear all analysis results.')) {
                                            onReset();
                                        }
                                    }}
                                    className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700 transition-colors"
                                >
                                    🔄 Reset
                                </button>
                            </div>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('alpha')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Without Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(Alpha Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Test alpha sequence without permutations - faster analysis for alpha path exploration
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('efdr')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-yellow-500 hover:bg-yellow-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">With Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(eFDR Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Include permutation testing for empirical False Discovery Rate analysis
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            return null; // This will be replaced by parameter collection UIs
        };

        // Matrix Data Review Component
        const MatrixDataReview = ({ matrix, matrixInfo, statistics, onProceedToAnalysis, onReset }) => {
            return (
                <div className="space-y-6">
                    {/* Basic Data Overview */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="mb-4">
                            <h2 className="text-2xl font-bold">Data Overview</h2>
                            <p className="text-sm text-gray-600 flex items-center gap-1 mt-1">
                                <span className="text-blue-600">📊</span>
                                Data: {matrixInfo.filename}
                            </p>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-5 gap-4">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                <div className="text-2xl font-bold text-blue-900">{statistics.P} × {statistics.N}</div>
                                <div className="text-xs text-blue-600 mt-1">Features × Samples</div>
                            </div>
                            <div className="bg-green-50 p-4 rounded-lg">
                                <div className="text-sm text-green-600 font-medium">Range</div>
                                <div className="text-lg font-bold text-green-900">[{formatSmallValue(statistics.min)}, {formatSmallValue(statistics.max)}]</div>
                                <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg">
                                <div className="text-sm text-purple-600 font-medium">Global Mean</div>
                                <div className="text-lg font-bold text-purple-900">{formatSmallValue(statistics.mean)}</div>
                                <div className="text-xs text-purple-600 mt-1">All elements</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg">
                                <div className="text-sm text-orange-600 font-medium">Global Std Dev</div>
                                <div className="text-lg font-bold text-orange-900">{formatSmallValue(statistics.stdDev)}</div>
                                <div className="text-xs text-orange-600 mt-1">All elements</div>
                            </div>
                            <div className="bg-cyan-50 p-4 rounded-lg">
                                <div className="text-sm text-cyan-600 font-medium">Frobenius Norm</div>
                                <div className="text-lg font-bold text-cyan-900">
                                    {statistics.frobeniusNorm?.toFixed(4)}
                                </div>
                                <div className="text-xs text-cyan-600 mt-1">
                                    {Math.abs((statistics.frobeniusNorm ?? 0) - 1.0) < 0.01 ? '✓ Normalized' : 'Not normalized'}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* Row Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Row Statistics (across samples)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.rowMeans} 
                                title="Row Means Distribution"
                                xLabel="Mean Value"
                                yLabel="Frequency"
                                bins={15}
                            />
                            <HistogramChart 
                                data={statistics.rowStdDevs}
                                title="Row Std Devs Distribution" 
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={15}
                            />
                        </div>
                    </div>

                    {/* Column Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Column Statistics (across features)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.columnMeans}
                                title="Column Means Distribution"
                                xLabel="Mean Value" 
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                            <HistogramChart 
                                data={statistics.columnStdDevs}
                                title="Column Std Devs Distribution"
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                        </div>
                    </div>

                    {/* Matrix Values Histogram */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Matrix Values Distribution</h2>
                        <MatrixHistogram 
                            matrixData={matrix}
                            title="Original Matrix Values"
                            color="rgba(59, 130, 246, 1)"
                            bins={64}
                        />
                    </div>


                    {/* Action Buttons */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <p className="text-gray-600 mb-4">
                            Review the statistics and histograms of the uploaded data matrix to verify that it has been properly preprocessed. When ready, click on "Proceed to Analysis" to select analysis type.
                        </p>
                        <div className="flex justify-between items-center">
                            <button
                                className="px-6 py-3 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                onClick={() => onReset()}
                                title="Reset and upload a new matrix"
                            >
                                Reset
                            </button>
                            <button
                                className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                                onClick={() => onProceedToAnalysis()}
                            >
                                Proceed to Analysis
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Data Preprocessing Section Component
        const DataPreprocessingSection = ({ 
            originalMatrix, 
            originalStatistics, 
            onPreprocessingComplete,
            onSkipPreprocessing,
            onProceedToAnalysis
        }) => {
            const [isProcessing, setIsProcessing] = useState(false);
            const [preprocessingResults, setPreprocessingResults] = useState(null);
            const [showPreprocessedStats, setShowPreprocessedStats] = useState(false);

            const handleApplyPreprocessing = async () => {
                setIsProcessing(true);
                
                // Small delay for UI responsiveness
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    // Apply preprocessing
                    const results = preprocessMatrix(originalMatrix);
                    
                    // Calculate statistics for preprocessed matrix
                    const preprocessedStats = calculateMatrixStatistics(results.preprocessedMatrix);
                    
                    // Calculate eigenvalues for preprocessed matrix
                    const preprocessedEigenvalues = calculateEigenvalueSpectrum(results.preprocessedMatrix);
                    
                    setPreprocessingResults({
                        ...results,
                        statistics: preprocessedStats,
                        eigenvalues: preprocessedEigenvalues
                    });
                    
                    setShowPreprocessedStats(true);
                    
                    // Notify parent component
                    onPreprocessingComplete(
                        results.preprocessedMatrix,
                        preprocessedStats,
                        preprocessedEigenvalues,
                        results
                    );
                } catch (error) {
                    console.error('Preprocessing failed:', error);
                    alert(`Preprocessing failed: ${error.message}`);
                } finally {
                    setIsProcessing(false);
                }
            };

            return (
                <div className="space-y-6">
                    {/* Preprocessing Control Panel */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Data Pre-Processing</h2>
                        
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <h3 className="font-semibold text-blue-900 mb-2">Pre-Processing Operations</h3>
                            <div className="space-y-2 text-sm text-blue-800">
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">1.</span>
                                    <div>
                                        <span className="font-semibold">Frobenius Normalization:</span>
                                        <span className="ml-2">Divide each matrix element by the Frobenius norm (||X||<sub>F</sub>)</span>
                                    </div>
                                </div>
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">2.</span>
                                    <div>
                                        <span className="font-semibold">Row Centering:</span>
                                        <span className="ml-2">Subtract row mean from each element to achieve zero-mean rows</span>
                                    </div>
                                </div>
                                <div className="mt-3 p-2 bg-white rounded border border-blue-300">
                                    <span className="font-mono text-xs">
                                        X<sub>processed</sub>[i,j] = (X[i,j] / ||X||<sub>F</sub>) - mean(row<sub>i</sub>)
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="flex gap-4">
                            <button
                                onClick={handleApplyPreprocessing}
                                disabled={isProcessing || preprocessingResults !== null}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isProcessing || preprocessingResults !== null
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isProcessing ? (
                                    <span className="flex items-center">
                                        <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>
                                        Processing...
                                    </span>
                                ) : preprocessingResults ? (
                                    '✓ Pre-Processing Applied'
                                ) : (
                                    'Apply Pre-Processing'
                                )}
                            </button>
                            
                            <button
                                onClick={onSkipPreprocessing}
                                disabled={isProcessing}
                                className="px-6 py-3 border border-gray-300 text-gray-700 rounded-md font-medium hover:bg-gray-50 transition-colors"
                            >
                                Skip Pre-Processing
                            </button>
                        </div>

                        {preprocessingResults && (
                            <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <h4 className="font-semibold text-green-900 mb-2">Pre-Processing Complete</h4>
                                <div className="grid grid-cols-2 gap-4 text-sm text-green-800">
                                    <div>
                                        <span className="font-medium">Original Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormOriginal.toFixed(4)}</span>
                                    </div>
                                    <div>
                                        <span className="font-medium">Processed Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormProcessed.toFixed(4)}</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Preprocessed Data Statistics */}
                    {showPreprocessedStats && preprocessingResults && (
                        <>
                            {/* Basic Data Overview */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-2xl font-bold mb-4">Preprocessed Data Overview</h2>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">
                                            {preprocessingResults.statistics.P} × {preprocessingResults.statistics.N}
                                        </div>
                                        <div className="text-xs text-blue-600 mt-1">Features × Samples</div>
                                    </div>
                                    <div className="bg-green-50 p-4 rounded-lg">
                                        <div className="text-sm text-green-600 font-medium">Range</div>
                                        <div className="text-lg font-bold text-green-900">
                                            [{preprocessingResults.statistics.min.toFixed(3)}, {preprocessingResults.statistics.max.toFixed(3)}]
                                        </div>
                                        <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">Global Mean</div>
                                        <div className="text-lg font-bold text-purple-900">
                                            {preprocessingResults.statistics.mean.toExponential(2)}
                                        </div>
                                        <div className="text-xs text-purple-600 mt-1">Should be ≈0</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Global Std Dev</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {preprocessingResults.statistics.stdDev.toFixed(4)}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">Normalized scale</div>
                                    </div>
                                </div>
                            </div>

                            {/* Row Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Row Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowMeans} 
                                        title="Row Means Distribution (should be ~0)"
                                        xLabel="Mean Value"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowStdDevs}
                                        title="Row Std Devs Distribution" 
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                </div>
                            </div>

                            {/* Column Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Column Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnMeans}
                                        title="Column Means Distribution"
                                        xLabel="Mean Value" 
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnStdDevs}
                                        title="Column Std Devs Distribution"
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                </div>
                            </div>

                            {/* Preprocessed Matrix Values Histogram */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Matrix Values Distribution</h2>
                                <MatrixHistogram 
                                    matrixData={preprocessingResults.preprocessedMatrix}
                                    title="Preprocessed Matrix Values"
                                    color="rgba(34, 197, 94, 1)"
                                    bins={64}
                                />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> After Frobenius normalization and row centering, the matrix values 
                                    should show a more centered distribution with normalized scale.</p>
                                </div>
                            </div>

                            {/* Eigenvalue Spectrum */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Eigenvalue Analysis</h2>
                                <SignalNoiseAnalysis eigenvalues={preprocessingResults.eigenvalues} />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> Preprocessing typically changes the eigenvalue spectrum. 
                                    The signal/noise boundary may be clearer after normalization and centering.</p>
                                </div>
                            </div>

                            {/* Continue Button */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessing Complete</h2>
                                <p className="text-gray-600 mb-4">
                                    Data has been successfully preprocessed. The Frobenius-normalized and row-centered matrix 
                                    will be used for all subsequent analyses.
                                </p>
                                <button
                                    className="px-6 py-3 bg-green-600 text-white rounded-md font-medium hover:bg-green-700 transition-colors"
                                    onClick={onProceedToAnalysis}
                                >
                                    ✓ Continue with Preprocessed Data
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        // Analysis Configuration Panel Component
        const AnalysisConfigurationPanel = ({ matrix, matrixInfo, analysisStep, isRunningAnalysis = false, onStartAnalysis, onCancel }) => {
            const [analysisMode, setAnalysisMode] = useState('single'); // 'single' or 'multi'
            const [analysisType, setAnalysisType] = useState('alpha'); // 'alpha' or 'efdr'
            const [singleAlpha, setSingleAlpha] = useState(null);
            const [singleAlphaText, setSingleAlphaText] = useState(''); // Separate text state - start blank
            const [Nalpha, setNalpha] = useState(35);
            const [minAlpha, setMinAlpha] = useState(0);
            const [alphaMaxMultiplier, setAlphaMaxMultiplier] = useState(0.75);
            const [Nperm, setNperm] = useState(25);
            const [sprcnt, setSprcnt] = useState(5); // Support percentage (default 5%)
            const [alphaMax, setAlphaMax] = useState(null);
            const [alphaMaxComponents, setAlphaMaxComponents] = useState(null); // Store calculation components
            const [isCalculating, setIsCalculating] = useState(false);
            
            // Calculate alphaMax components and set initial values
            useEffect(() => {
                if (matrixInfo && matrixInfo.alphaMax) {
                    // Calculate components for equation display
                    try {
                        const { u, s } = svd1Sync(matrix);
                        const maxAbsU1 = Math.max(...u.map(val => Math.abs(val)));
                        const baseAlphaMax = alphaMaxMultiplier * maxAbsU1 * s;
                        
                        // Store components for equation display
                        setAlphaMaxComponents((prev) => ({
                            multiplier: alphaMaxMultiplier, // Use current multiplier
                            maxAbsU1: maxAbsU1,
                            s: s,
                            calculated: alphaMaxMultiplier * maxAbsU1 * s // Recalculate with current multiplier
                        }));
                        
                        // Initialize alphaMax with calculated value if empty
                        if (alphaMax === null) {
                            const adjustedAlphaMax = matrixInfo.alphaMax * (alphaMaxMultiplier / 0.75);
                            setAlphaMax(adjustedAlphaMax);
                        }
                        
                        console.log(`AlphaMax components: multiplier=${alphaMaxMultiplier}, max(|u1|)=${maxAbsU1.toFixed(6)}, s=${s.toFixed(6)}, result=${baseAlphaMax.toFixed(6)}`);
                    } catch (error) {
                        console.error('Error calculating alphaMax components:', error);
                    }
                }
            }, [matrixInfo, matrix]); // Removed alphaMaxMultiplier and alphaMax to prevent overriding manual input

            // Separate effect to update equation components when multiplier changes
            useEffect(() => {
                if (alphaMaxComponents) {
                    setAlphaMaxComponents(prev => ({
                        ...prev,
                        multiplier: alphaMaxMultiplier,
                        calculated: alphaMaxMultiplier * prev.maxAbsU1 * prev.s
                    }));
                }
            }, [alphaMaxMultiplier]);
            
            const nsupp = useMemo(() => {
                // nsupp = 0.01 * sprcnt * P
                return Math.round(0.01 * sprcnt * (matrixInfo?.P || 1000));
            }, [sprcnt, matrixInfo]);
            
            const handleStartAnalysis = () => {
                if (analysisStep === 'single') {
                    // Single alpha analysis

                    // Validate alpha value
                    if (singleAlpha === null || singleAlpha === undefined) {
                        alert('Please enter an Alpha value.');
                        return;
                    }

                    if (singleAlpha < 0) {
                        alert('Alpha value must be ≥ 0.');
                        return;
                    }

                    if (alphaMax !== null && singleAlpha > alphaMax) {
                        const proceed = confirm(`Warning: Alpha value (${singleAlpha.toFixed(6)}) exceeds AlphaMax (${alphaMax.toFixed(6)}). This will likely result in 0 detections. Continue anyway?`);
                        if (!proceed) return;
                    }

                    const config = {
                        analysisMode: 'single',
                        alpha: singleAlpha,
                        alphaMax
                    };
                    console.log('Starting single alpha analysis with config:', config);
                    console.log('singleAlpha value:', singleAlpha);
                    onStartAnalysis(config);
                } else if (analysisStep === 'alpha' || analysisStep === 'efdr') {
                    // Multi-alpha analysis
                    if (!alphaMax || alphaMax === '') {
                        alert('Please enter a Maximum Alpha value.');
                        return;
                    }
                    
                    const config = {
                        analysisMode: 'multi',
                        analysisType: analysisStep, // Use analysisStep directly
                        Nalpha: Nalpha || 35,
                        alphaMax: alphaMax,
                        alphaMaxMultiplier,
                        alpha0: minAlpha || 0,
                        nsupp,
                        sprcnt,
                        ...(analysisStep === 'efdr' && { Nperm })
                    };
                    
                    onStartAnalysis(config);
                }
            };
            
            // Show summary view during eFDR analysis
            if (isRunningAnalysis && analysisStep === 'efdr') {
                return (
                    <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                        <h2 className="text-2xl font-bold text-gray-800 mb-4">eFDR Parameters</h2>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                            <div>
                                <span className="text-gray-500">Analysis Type:</span>
                                <div className="font-medium text-gray-900">eFDR Analysis</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Alpha Min:</span>
                                <div className="font-medium text-gray-900">{minAlpha.toFixed(6)}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Alpha Max:</span>
                                <div className="font-medium text-gray-900">{alphaMax?.toFixed(6) || 'N/A'}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">N Alpha:</span>
                                <div className="font-medium text-gray-900">{Nalpha}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Permutations:</span>
                                <div className="font-medium text-gray-900">{Nperm}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Support %:</span>
                                <div className="font-medium text-gray-900">{sprcnt}%</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Support Size:</span>
                                <div className="font-medium text-gray-900">{nsupp}</div>
                            </div>
                            <div>
                                <span className="text-gray-500">Matrix Size:</span>
                                <div className="font-medium text-gray-900">{matrixInfo?.P || '?'} × {matrixInfo?.N || '?'}</div>
                            </div>
                        </div>
                    </div>
                );
            }

            return (
                <div className="space-y-6">
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="border-b pb-4 mb-6">
                            <div className="flex justify-between items-center mb-2">
                                <h1 className="text-2xl font-bold text-gray-800">
                                    {analysisStep === 'single' ? 'Single-Alpha SSVD Analysis' :
                                     analysisStep === 'alpha' ? 'N-Alpha Analysis' :
                                     analysisStep === 'efdr' ? 'eFDR Analysis' : 'SSVD Analysis'}
                                </h1>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={onCancel}
                                        className="px-4 py-2 border border-slate-300 text-slate-600 bg-slate-50 rounded-md hover:bg-blue-50 hover:border-blue-300 hover:text-blue-700 transition-colors"
                                    >
                                        ← Back
                                    </button>
                                    <button
                                        onClick={() => window.location.reload()}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                                    >
                                        Reset
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        
                        {/* Single Alpha Configuration */}
                        {analysisStep === 'single' && (
                            <div className="mb-6 p-4 bg-blue-50 rounded-lg">
                                <h3 className="font-medium text-gray-700 mb-3">Single Alpha Parameters</h3>
                                <div className="grid grid-cols-2 gap-6">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Alpha Value (Sparsity Parameter)
                                        </label>
                                        <div className="space-y-2">
                                            <input
                                                type="text"
                                                value={singleAlphaText}
                                                onChange={(e) => {
                                                    const inputValue = e.target.value;
                                                    console.log('Alpha input raw value:', inputValue);
                                                    setSingleAlphaText(inputValue);
                                                    
                                                    // Try to parse as number
                                                    const numValue = parseFloat(inputValue);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        setSingleAlpha(numValue);
                                                    }
                                                }}
                                                onBlur={() => {
                                                    // On blur, ensure text matches the numeric value
                                                    if (singleAlpha !== null) {
                                                        setSingleAlphaText(singleAlpha.toString());
                                                    } else if (singleAlphaText === '') {
                                                        // Keep it blank if no value entered
                                                        setSingleAlphaText('');
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border-2 border-blue-300 rounded-md text-lg font-semibold focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
                                                placeholder="Enter alpha value"
                                            />
                                            <p className="text-xs text-gray-600 mt-2">
                                                Higher alpha ⟹ Greater sparsity (fewer detections)
                                            </p>
                                            {singleAlpha !== null && alphaMax !== null && singleAlpha > alphaMax && (
                                                <p className="text-xs text-red-600 mt-1 font-semibold">
                                                    ⚠️ Warning: Alpha value exceeds AlphaMax ({alphaMax.toFixed(6)})
                                                </p>
                                            )}
                                            {singleAlpha !== null && singleAlpha < 0 && (
                                                <p className="text-xs text-red-600 mt-1 font-semibold">
                                                    ⚠️ Warning: Alpha must be ≥ 0
                                                </p>
                                            )}
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Maximum Alpha (Zero Detection Threshold)
                                        </label>
                                        <input
                                            type="number"
                                            value={alphaMax === null ? '' : alphaMax}
                                            onChange={(e) => {
                                                console.log('Maximum Alpha input changed:', e.target.value);
                                                const value = e.target.value;
                                                if (value === '' || value === null) {
                                                    setAlphaMax(null);
                                                } else {
                                                    const numValue = parseFloat(value);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        console.log('Setting alphaMax to:', numValue);
                                                        setAlphaMax(numValue);
                                                    }
                                                }
                                            }}
                                            disabled={isCalculating}
                                            className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md disabled:bg-gray-100 disabled:text-gray-500"
                                            placeholder={isCalculating ? "Calculating..." : "Enter or calculate max alpha"}
                                        />
                                        <p className="text-xs text-gray-600 mt-2">
                                            Alpha values above this threshold are likely to result in zero detections
                                        </p>

                                        {/* Static Maximum Alpha equation display */}
                                        {alphaMaxComponents && (
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Default Maximum Alpha Calculation:</div>
                                                <div className="font-mono text-gray-600">
                                                    AlphaMax = AlphaMaxMultiplier × max(|U1|) × S1 = <span className="font-bold">0.75</span> × <span className="font-bold">{alphaMaxComponents.maxAbsU1.toFixed(4)}</span> × <span className="font-bold">{alphaMaxComponents.s.toFixed(4)}</span> = <span className="font-bold">{(0.75 * alphaMaxComponents.maxAbsU1 * alphaMaxComponents.s).toFixed(6)}</span>
                                                </div>
                                                <div className="text-gray-500 mt-1 text-xs">Input field above is fully editable - you can override this default value</div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Configuration */}
                        {(analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <>
                                {/* Alpha Sequence Configuration */}
                                <div className="grid grid-cols-2 gap-6 mb-1">
                                    {/* Upper left: Number of Alphas */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Number of Alphas (nAlpha)
                                        </label>
                                        <input
                                            type="number"
                                            min="5"
                                            max="75"
                                            value={Nalpha}
                                            onChange={(e) => {
                                                const value = e.target.value;
                                                setNalpha(value === '' ? '' : parseInt(value) || 35);
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Number of alpha values to test (5-75)
                                        </p>
                                    </div>
                                    
                                    {/* Upper right: Minimum Alpha */}
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Minimum Alpha (AlphaMin)
                                        </label>
                                        <input
                                            type="number"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={minAlpha}
                                            onChange={(e) => {
                                                const value = e.target.value;
                                                setMinAlpha(value === '' ? '' : parseFloat(value) || 0);
                                            }}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Starting alpha value (typically 0)
                                        </p>
                                    </div>
                                    
                                    {/* Lower left: Number of Permutations - for eFDR analysis */}
                                    {analysisStep === 'efdr' && (
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                                Number of Permutations (Nperm)
                                            </label>
                                            <input
                                                type="number"
                                                min="5"
                                                max="100"
                                                value={Nperm}
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    if (val === '') {
                                                        setNperm('');
                                                    } else {
                                                        const num = parseInt(val);
                                                        if (!isNaN(num)) {
                                                            setNperm(num);
                                                        }
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    console.log('Nperm onBlur triggered, current value:', e.target.value);
                                                    if (e.target.value === '' || parseInt(e.target.value) < 5) {
                                                        console.log('Nperm reset to 25 due to invalid value (< 5)');
                                                        setNperm(25);
                                                    } else if (parseInt(e.target.value) > 100) {
                                                        console.log('Nperm capped to 100');
                                                        setNperm(100);
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                                            />
                                        </div>
                                    )}
                                    
                                    {/* Lower right: Maximum Alpha */}
                                    <div className={analysisStep !== 'efdr' ? 'col-start-1' : ''}>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Maximum Alpha (AlphaMax)
                                        </label>
                                        <input
                                            type="number"
                                            value={alphaMax === null ? '' : alphaMax}
                                            onChange={(e) => {
                                                console.log('Maximum Alpha input changed:', e.target.value);
                                                const value = e.target.value;
                                                if (value === '' || value === null) {
                                                    setAlphaMax(null);
                                                } else {
                                                    const numValue = parseFloat(value);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        console.log('Setting alphaMax to:', numValue);
                                                        setAlphaMax(numValue);
                                                    }
                                                }
                                            }}
                                            disabled={isCalculating}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md disabled:bg-gray-100 disabled:text-gray-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                            placeholder={isCalculating ? "Calculating..." : "Enter or calculate max alpha"}
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Alpha values above this threshold are likely to result in zero detections
                                        </p>

                                        {/* Static Maximum Alpha equation display */}
                                        {alphaMaxComponents && (
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Default Maximum Alpha Calculation:</div>
                                                <div className="font-mono text-gray-600">
                                                    AlphaMax = AlphaMaxMultiplier × max(|U1|) × S1 = <span className="font-bold">0.75</span> × <span className="font-bold">{alphaMaxComponents.maxAbsU1.toFixed(4)}</span> × <span className="font-bold">{alphaMaxComponents.s.toFixed(4)}</span> = <span className="font-bold">{(0.75 * alphaMaxComponents.maxAbsU1 * alphaMaxComponents.s).toFixed(6)}</span>
                                                </div>
                                                <div className="text-gray-500 mt-1 text-xs">Input field above is fully editable - you can override this default value</div>
                                            </div>
                                        )}
                                    </div>
                                </div>
                                
                                {/* Expected Support Percentage - much closer to Nperm */}
                                {analysisStep === 'efdr' && (
                                    <div className="grid grid-cols-2 gap-6 -mt-16">
                                        <div>
                                            <label className="block text-sm font-medium text-gray-700 mb-2">
                                                Expected Support Percentage (sprcnt)
                                            </label>
                                            <input
                                                type="number"
                                                min="1"
                                                max="50"
                                                step="1"
                                                value={sprcnt}
                                                onChange={(e) => {
                                                    const val = e.target.value;
                                                    if (val === '') {
                                                        setSprcnt('');
                                                    } else {
                                                        const num = parseFloat(val);
                                                        if (!isNaN(num)) {
                                                            setSprcnt(num);
                                                        }
                                                    }
                                                }}
                                                onBlur={(e) => {
                                                    if (e.target.value === '' || parseFloat(e.target.value) < 1) {
                                                        setSprcnt(5);
                                                    } else if (parseFloat(e.target.value) > 50) {
                                                        setSprcnt(50);
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-yellow-500"
                                            />
                                            
                                            {/* Estimated Support Size display */}
                                            <div className="mt-2 p-2 bg-gray-50 rounded text-xs">
                                                <div className="font-medium text-gray-700 mb-1">Estimated Number of Detections (nsupp):</div>
                                                <div className="font-mono text-gray-600">
                                                    nsupp = 0.01 x sprcnt x P = 0.01 x {sprcnt} x {matrixInfo?.P || 'P'} = <span className="font-bold">{nsupp}</span>
                                                </div>
                                            </div>
                                        </div>
                                        <div></div>
                                    </div>
                                )}
                                
                                {/* eFDR Analysis Time Estimate */}
                                {analysisStep === 'efdr' && (
                                    <div className="mt-3 p-3 bg-yellow-100 border border-yellow-300 rounded-lg">
                                        <div className="flex items-start">
                                            <span className="text-lg mr-2 mt-0.5">⏱️</span>
                                            <div className="flex-1">
                                                <p className="text-sm font-semibold text-yellow-800">
                                                    Analysis Time Estimate
                                                </p>
                                                <p className="text-xs text-yellow-700 mt-1">
                                                    Will run <span className="font-bold">{Nalpha * (1 + Nperm)}</span> SSVD iterations
                                                    ({Nalpha} alphas × {1 + Nperm} runs each)
                                                </p>
                                                <p className="text-xs text-yellow-600 mt-1">
                                                    Estimated time: {Math.ceil(Nalpha * (1 + Nperm) * 0.5)} - {Math.ceil(Nalpha * (1 + Nperm) * 1.5)} seconds
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </>
                        )}
                        
                        {/* Action Buttons */}
                        <div className="flex justify-end mt-8">
                            <button
                                onClick={handleStartAnalysis}
                                disabled={isCalculating || ((analysisStep === 'alpha' || analysisStep === 'efdr') && (!alphaMax || alphaMax === '')) || (analysisStep === 'single' && (singleAlpha === null || singleAlpha === undefined))}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isCalculating || ((analysisStep === 'alpha' || analysisStep === 'efdr') && (!alphaMax || alphaMax === '')) || (analysisStep === 'single' && (singleAlpha === null || singleAlpha === undefined))
                                        ? 'bg-gray-400 text-gray-200 cursor-not-allowed' 
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isCalculating ? 'Calculating AlphaMax...' :
                                 analysisStep === 'single' ? 'Run Analysis' :
                                 analysisStep === 'efdr' ? 'Start eFDR Analysis' :
                                 'Start N-Alpha Analysis'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // Heatmap Chart Component - Clustered solution submatrix using Canvas with dendrograms
        const HeatmapChart = ({ ssvdResults, matrix, analysisMode }) => {
            const canvasRef = React.useRef(null);
            const rowDendrogramRef = React.useRef(null);
            const colDendrogramRef = React.useRef(null);
            const [isRendering, setIsRendering] = React.useState(false);

            if (!ssvdResults || !matrix || !ssvdResults.detectedIndices || ssvdResults.detectedIndices.length === 0) {
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h3 className="text-lg font-semibold mb-4">Solution Submatrix Heatmap</h3>
                        <div className="flex items-center justify-center h-40 text-gray-500">
                            No detections found - heatmap not available
                        </div>
                    </div>
                );
            }

            const detectedIndices = ssvdResults.detectedIndices;
            const Q = detectedIndices.length; // 191 detections
            const N = matrix[0].length;       // 368 samples
            
            // Canvas dimensions - reduced for compact display
            const minHeight = 150; // Reduced minimum height
            const minWidth = 400;  // Reduced minimum width

            // Dendrogram dimensions
            const rowDendrogramWidth = 80;  // Width for row dendrogram on left
            const colDendrogramHeight = 60; // Height for column dendrogram on top

            // Calculate dimensions - smaller overall size
            const canvasWidth = Math.max(minWidth, Math.min(800, N * 2));   // Min 400px, Max 800px, 2px per sample
            const canvasHeight = Math.max(minHeight, Math.min(300, Q * 2)); // Min 150px, Max 300px, 2px per detection
            const cellWidth = canvasWidth / N;
            const cellHeight = canvasHeight / Q;

            // Extract full submatrix for all detections x samples
            const submatrix = detectedIndices.map(rowIdx => matrix[rowIdx]);

            // Calculate z-scores for color mapping
            const zScoredMatrix = submatrix.map(row => {
                const mean = row.reduce((sum, val) => sum + val, 0) / row.length;
                const variance = row.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / row.length;
                const std = Math.sqrt(variance);
                return row.map(val => std > 0 ? (val - mean) / std : 0);
            });

            // Simple hierarchical clustering using correlation distance with dendrogram info
            const clusterRows = (matrix) => {
                const n = matrix.length;
                const correlations = [];

                // Calculate pairwise correlations
                for (let i = 0; i < n; i++) {
                    correlations[i] = [];
                    for (let j = 0; j < n; j++) {
                        if (i === j) {
                            correlations[i][j] = 1;
                        } else {
                            const r1 = matrix[i];
                            const r2 = matrix[j];
                            const mean1 = r1.reduce((a, b) => a + b, 0) / r1.length;
                            const mean2 = r2.reduce((a, b) => a + b, 0) / r2.length;
                            let num = 0, den1 = 0, den2 = 0;
                            for (let k = 0; k < r1.length; k++) {
                                num += (r1[k] - mean1) * (r2[k] - mean2);
                                den1 += (r1[k] - mean1) ** 2;
                                den2 += (r2[k] - mean2) ** 2;
                            }
                            correlations[i][j] = den1 * den2 > 0 ? num / Math.sqrt(den1 * den2) : 0;
                        }
                    }
                }

                // Greedy ordering based on correlations with merge tracking
                const ordered = [0];
                const remaining = Array.from({length: n}, (_, i) => i).slice(1);
                const merges = []; // Track merge order and distances

                while (remaining.length > 0) {
                    const last = ordered[ordered.length - 1];
                    let bestIdx = 0;
                    let bestCorr = -2;

                    for (let i = 0; i < remaining.length; i++) {
                        const corr = correlations[last][remaining[i]];
                        if (corr > bestCorr) {
                            bestCorr = corr;
                            bestIdx = i;
                        }
                    }

                    const nextItem = remaining[bestIdx];
                    merges.push({
                        index: ordered.length,
                        item: nextItem,
                        distance: 1 - bestCorr // Convert correlation to distance
                    });

                    ordered.push(nextItem);
                    remaining.splice(bestIdx, 1);
                }

                return { ordered, merges };
            };

            // Cluster rows and columns
            const rowCluster = clusterRows(zScoredMatrix);
            const transposed = zScoredMatrix[0].map((_, colIdx) => zScoredMatrix.map(row => row[colIdx]));
            const colCluster = clusterRows(transposed);

            // Reorder matrix based on clustering
            const clusteredMatrix = rowCluster.ordered.map(i => colCluster.ordered.map(j => zScoredMatrix[i][j]));
            
            // Color mapping function for Canvas (returns RGB array)
            const getColorRGB = (zScore) => {
                const clampedZ = Math.max(-3, Math.min(3, zScore));
                const normalized = (clampedZ + 3) / 6; // 0 to 1

                if (normalized < 0.5) {
                    // Blue to white
                    const intensity = normalized * 2;
                    const val = Math.round(255 * (1 - intensity * 0.5));
                    return [val, val, 255];
                } else {
                    // White to red
                    const intensity = (normalized - 0.5) * 2;
                    const val = Math.round(255 * (1 - intensity * 0.5));
                    return [255, val, val];
                }
            };

            // Canvas rendering effect
            React.useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                setIsRendering(true);
                const ctx = canvas.getContext('2d');
                canvas.width = canvasWidth;
                canvas.height = canvasHeight;

                // Create ImageData for efficient pixel manipulation
                const imageData = ctx.createImageData(canvasWidth, canvasHeight);
                const data = imageData.data;

                // Render each cell as pixels using clustered matrix
                for (let rowIdx = 0; rowIdx < Q; rowIdx++) {
                    for (let colIdx = 0; colIdx < N; colIdx++) {
                        const zScore = clusteredMatrix[rowIdx][colIdx];
                        const [r, g, b] = getColorRGB(zScore);

                        // Calculate pixel coordinates
                        const startX = Math.floor(colIdx * cellWidth);
                        const endX = Math.floor((colIdx + 1) * cellWidth);
                        const startY = Math.floor(rowIdx * cellHeight);
                        const endY = Math.floor((rowIdx + 1) * cellHeight);

                        // Fill the cell area
                        for (let y = startY; y < endY; y++) {
                            for (let x = startX; x < endX; x++) {
                                const pixelIndex = (y * canvasWidth + x) * 4;
                                data[pixelIndex] = r;     // Red
                                data[pixelIndex + 1] = g; // Green
                                data[pixelIndex + 2] = b; // Blue
                                data[pixelIndex + 3] = 255; // Alpha
                            }
                        }
                    }
                }

                // Draw the image data to canvas
                ctx.putImageData(imageData, 0, 0);
                setIsRendering(false);
            }, [detectedIndices, matrix]);

            // Render row dendrogram (left side)
            React.useEffect(() => {
                const canvas = rowDendrogramRef.current;
                if (!canvas || !rowCluster.merges) return;

                const ctx = canvas.getContext('2d');
                canvas.width = rowDendrogramWidth;
                canvas.height = canvasHeight;

                ctx.clearRect(0, 0, rowDendrogramWidth, canvasHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;

                // Draw dendrogram from merges
                const maxDist = Math.max(...rowCluster.merges.map(m => m.distance), 0.01);

                rowCluster.merges.forEach((merge, idx) => {
                    const y = (merge.index + 0.5) * cellHeight;
                    const prevY = idx > 0 ? (merge.index - 0.5) * cellHeight : y;
                    const x = rowDendrogramWidth - (merge.distance / maxDist) * (rowDendrogramWidth - 10);

                    // Draw horizontal line to merge point
                    ctx.beginPath();
                    ctx.moveTo(rowDendrogramWidth - 5, y);
                    ctx.lineTo(x, y);
                    ctx.stroke();

                    // Draw vertical connector if not first
                    if (idx > 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, prevY);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }
                });
            }, [rowCluster, canvasHeight, cellHeight]);

            // Render column dendrogram (top)
            React.useEffect(() => {
                const canvas = colDendrogramRef.current;
                if (!canvas || !colCluster.merges) return;

                const ctx = canvas.getContext('2d');
                canvas.width = canvasWidth;
                canvas.height = colDendrogramHeight;

                ctx.clearRect(0, 0, canvasWidth, colDendrogramHeight);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 1;

                // Draw dendrogram from merges
                const maxDist = Math.max(...colCluster.merges.map(m => m.distance), 0.01);

                colCluster.merges.forEach((merge, idx) => {
                    const x = (merge.index + 0.5) * cellWidth;
                    const prevX = idx > 0 ? (merge.index - 0.5) * cellWidth : x;
                    const y = colDendrogramHeight - (merge.distance / maxDist) * (colDendrogramHeight - 10);

                    // Draw vertical line to merge point
                    ctx.beginPath();
                    ctx.moveTo(x, colDendrogramHeight - 5);
                    ctx.lineTo(x, y);
                    ctx.stroke();

                    // Draw horizontal connector if not first
                    if (idx > 0) {
                        ctx.beginPath();
                        ctx.moveTo(prevX, y);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }
                });
            }, [colCluster, canvasWidth, cellWidth]);

            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4 text-center">
                        Clustered Heatmap of Solution Submatrix ({Q} detections x {N} samples)
                    </h3>

                    {isRendering && (
                        <div className="flex items-center justify-center py-8 text-blue-600">
                            <div className="animate-pulse">Rendering heatmap...</div>
                        </div>
                    )}

                    <div className="flex justify-center">
                        <div style={{ display: 'inline-block' }}>
                            {/* Column dendrogram on top */}
                            <div style={{ marginLeft: `${rowDendrogramWidth}px`, marginBottom: '0' }}>
                                <canvas
                                    ref={colDendrogramRef}
                                    style={{
                                        display: 'block',
                                        border: '1px solid #e5e7eb',
                                        borderBottom: 'none',
                                        backgroundColor: 'white'
                                    }}
                                />
                            </div>

                            {/* Row dendrogram and heatmap side by side */}
                            <div style={{ display: 'flex' }}>
                                {/* Row dendrogram on left */}
                                <canvas
                                    ref={rowDendrogramRef}
                                    style={{
                                        display: 'block',
                                        border: '1px solid #e5e7eb',
                                        borderRight: 'none',
                                        backgroundColor: 'white'
                                    }}
                                />

                                {/* Main heatmap */}
                                <canvas
                                    ref={canvasRef}
                                    data-chart-type="heatmap-clustered"
                                    style={{
                                        display: 'block',
                                        border: '1px solid #e5e7eb',
                                        backgroundColor: 'white'
                                    }}
                                />
                            </div>
                        </div>
                    </div>

                    <div className="mt-4 text-sm text-gray-600 text-center">
                        <div>Blue = Below average, Red = Above average (Z-score normalized, hierarchically clustered)</div>
                        <div>Dendrograms show hierarchical clustering structure (rows: left, columns: top)</div>
                    </div>
                </div>
            );
        };

        // ===================================================================
        // COMPREHENSIVE EXPORT SYSTEM - EXPORT_SYSTEM_v1.0_SSVD1X
        // ===================================================================

        // CSV Export Functions
        const exportDetectedRowsCSV = (results, matrix, matrixInfo) => {
            if (!results || !results.detectedIndices || results.detectedIndices.length === 0) {
                alert('No detections found for this alpha value.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const alpha = results.alpha || 0;

            // Create header row: Row_Index, Variable_Name, U_Value, then sample columns
            const headers = ['Row_Index', 'Variable_Name', 'U_Value'];
            for (let i = 0; i < matrix[0].length; i++) {
                headers.push(`Sample_${i + 1}`);
            }

            // Create detected rows data
            const rows = results.detectedIndices.map(idx => {
                const oneBasedIdx = idx + 1;
                const varName = matrixInfo?.rowHeaders?.[idx] || `Variable_${oneBasedIdx}`;
                const uValue = results.u[idx];
                const row = [oneBasedIdx, varName, uValue.toFixed(6)];
                
                // Add sample values
                matrix[idx].forEach(val => {
                    row.push(val.toFixed(6));
                });
                return row;
            });

            const csvContent = Papa.unparse({
                fields: headers,
                data: rows
            });

            const filename = `SSVD1x_DetectedRows_Alpha${alpha.toFixed(4)}_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log(`✅ Detected rows exported (${results.detectedIndices.length} rows):`, filename);
        };

        const exportAnalysisParametersCSV = (results, matrixInfo, analysisParams) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

            const metadata = [
                ['Parameter', 'Value'],
                ['Analysis Date', new Date().toISOString()],
                ['Matrix Dimensions (P x N)', `${matrixInfo?.P || matrixInfo?.rows || 'N/A'} x ${matrixInfo?.N || matrixInfo?.cols || 'N/A'}`],
                ['Alpha Value', results.alpha.toFixed(6)],
                ['Detections Count', results.detections],
                ['Sparsity (%)', results.sparsity],
                ['Iterations', results.iterations],
                ['Converged', results.converged ? 'Yes' : 'No'],
                ['Singular Value (S1)', results.s.toFixed(6)],
                ...(analysisParams ? Object.entries(analysisParams).map(([k, v]) => [k, v]) : [])
            ];

            const csvContent = Papa.unparse(metadata);
            const filename = `SSVD1x_Analysis_Parameters_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log('✅ Analysis parameters exported:', filename);
        };

        const exportV1ScoresCSV = (results, matrixInfo) => {
            if (!results || !results.v || results.v.length === 0) {
                alert('No V1 scores available. Please run analysis first.');
                return;
            }

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const alpha = results.alpha || 0;

            // Create header row: Sample_Index, Sample_Name, V1_Score
            const headers = ['Sample_Index', 'Sample_Name', 'V1_Score'];

            // Create V1 scores data
            const rows = results.v.map((score, idx) => {
                const oneBasedIdx = idx + 1;
                const sampleName = matrixInfo?.colHeaders?.[idx] || `Sample_${oneBasedIdx}`;
                return [oneBasedIdx, sampleName, score.toFixed(6)];
            });

            const csvContent = Papa.unparse({
                fields: headers,
                data: rows
            });

            const filename = `SSVD1x_V1_Scores_Alpha${alpha.toFixed(4)}_${timestamp}.csv`;
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            saveAs(blob, filename);
            console.log(`✅ V1 scores exported (${results.v.length} samples):`, filename);
        };

        // Chart Export Functions - PNG ONLY with proper SVG handling
        const exportChartsAsImages = async () => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const canvasCharts = document.querySelectorAll('canvas');
            const svgCharts = document.querySelectorAll('svg');

            console.log(`📊 Found ${canvasCharts.length} canvas charts and ${svgCharts.length} SVG charts for export`);

            if (canvasCharts.length === 0 && svgCharts.length === 0) {
                alert('No charts available to export. Please run analysis first.');
                return;
            }

            // Check if clustered heatmap exists and export it as composite
            const clusteredHeatmap = document.querySelector('canvas[data-chart-type="heatmap-clustered"]');
            if (clusteredHeatmap) {
                console.log('📊 Exporting clustered heatmap as composite...');
                await exportClusteredHeatmapComposite();
            }

            // Export Canvas charts (Chart.js) as PNG, excluding clustered heatmap components
            canvasCharts.forEach((canvas, index) => {
                try {
                    const chartType = canvas.getAttribute('data-chart-type');

                    // Skip clustered heatmap and its dendrograms (they're exported as composite)
                    if (chartType === 'heatmap-clustered') {
                        console.log('⏭️ Skipping clustered heatmap (exported as composite)');
                        return;
                    }

                    // Skip dendrograms by checking if they're siblings of the clustered heatmap
                    const clusteredHeatmapInContainer = canvas.parentElement?.querySelector('canvas[data-chart-type="heatmap-clustered"]');
                    const isInClusteredHeatmapContainer = !!clusteredHeatmapInContainer;

                    // Also check if it's in the same container structure as clustered heatmap
                    const container = canvas.closest('.bg-white');
                    const hasClusteredHeatmap = container?.querySelector('canvas[data-chart-type="heatmap-clustered"]');

                    if (isInClusteredHeatmapContainer || (hasClusteredHeatmap && !chartType)) {
                        console.log('⏭️ Skipping dendrogram (part of composite)');
                        return;
                    }

                    const chartContainer = canvas.closest('.bg-white, .chart-container');
                    const titleElement = chartContainer ? chartContainer.querySelector('h3, h4, h5') : null;
                    let chartTitle = titleElement ? titleElement.textContent.trim() : `Chart_${index + 1}`;

                    // Add sorted identifier based on data attribute
                    if (chartType === 'v1-sorted') {
                        chartTitle = chartTitle.replace('V1 Analysis', 'V1_Sorted_Scores');
                    } else if (chartType === 'v1-original') {
                        chartTitle = chartTitle.replace('V1 Analysis', 'V1_Original_Order');
                    } else if (chartType === 'heatmap-sorted') {
                        // Extract dimensions from title like "32 detections × 100 samples"
                        const dimensionMatch = chartTitle.match(/(\d+)\s+detections.*?(\d+)\s+samples/);
                        if (dimensionMatch) {
                            const detections = dimensionMatch[1];
                            const samples = dimensionMatch[2];
                            chartTitle = `Solution_Submatrix_Sorted_Heatmap_${detections}_detections_${samples}_samples`;
                        } else {
                            chartTitle = 'Solution_Submatrix_Sorted_Heatmap';
                        }
                    } else if (chartType === 'heatmap-original') {
                        // Extract dimensions from title like "32 detections × 100 samples"
                        const dimensionMatch = chartTitle.match(/(\d+)\s+detections.*?(\d+)\s+samples/);
                        if (dimensionMatch) {
                            const detections = dimensionMatch[1];
                            const samples = dimensionMatch[2];
                            chartTitle = `Solution_Submatrix_Heatmap_${detections}_detections_${samples}_samples`;
                        } else {
                            chartTitle = 'Solution_Submatrix_Heatmap';
                        }
                    }

                    const cleanTitle = chartTitle.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_');
                    const filename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                    
                    // Create canvas with white background
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    
                    tempCtx.fillStyle = 'white';
                    tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    tempCtx.drawImage(canvas, 0, 0);
                    
                    tempCanvas.toBlob(blob => {
                        if (blob) {
                            saveAs(blob, filename);
                            console.log('✅ Canvas chart exported as PNG:', filename);
                        }
                    }, 'image/png', 1.0);
                } catch (error) {
                    console.error('Error exporting canvas chart:', error);
                }
            });

            // Export only relevant SVG charts (filter out small legends and decorative elements)
            const relevantSVGs = Array.from(svgCharts).filter(svg => {
                const width = parseInt(svg.getAttribute('width') || svg.viewBox?.baseVal?.width || 0);
                const height = parseInt(svg.getAttribute('height') || svg.viewBox?.baseVal?.height || 0);
                const rect = svg.getBoundingClientRect();
                
                // Filter out small SVGs (likely legends or icons)
                const minSize = 100; // Minimum size in pixels
                const isLargeEnough = (width > minSize || rect.width > minSize) && 
                                      (height > minSize || rect.height > minSize);
                
                // Check if it's inside a chart container
                const container = svg.closest('.bg-white, .chart-container');
                const hasTitle = container ? container.querySelector('h3, h4, h5') : false;
                
                console.log('SVG filter check:', { 
                    width, height, 
                    rectWidth: rect.width, rectHeight: rect.height,
                    isLargeEnough, hasTitle,
                    container: container?.className
                });
                
                return isLargeEnough && hasTitle;
            });
            
            console.log(`📊 Filtered to ${relevantSVGs.length} relevant SVG charts for export`);

            // Export filtered SVG charts as PNG
            relevantSVGs.forEach((svg, index) => {
                try {
                    const chartContainer = svg.closest('.bg-white, .chart-container');
                    const titleElement = chartContainer ? chartContainer.querySelector('h3, h4, h5') : null;
                    const chartTitle = titleElement ? titleElement.textContent.trim() : `SVG_Chart_${index + 1}`;
                    
                    const cleanTitle = chartTitle.replace(/[^a-zA-Z0-9\s-]/g, '').replace(/\s+/g, '_');
                    
                    // Get actual SVG dimensions
                    const svgRect = svg.getBoundingClientRect();
                    const width = Math.max(svgRect.width, 600);
                    const height = Math.max(svgRect.height, 400);
                    
                    // Clone and prepare SVG for export
                    const svgClone = svg.cloneNode(true);
                    svgClone.setAttribute('width', width);
                    svgClone.setAttribute('height', height);
                    
                    // Add white background if not present
                    if (!svgClone.querySelector('rect.background')) {
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bgRect.setAttribute('width', '100%');
                        bgRect.setAttribute('height', '100%');
                        bgRect.setAttribute('fill', 'white');
                        svgClone.insertBefore(bgRect, svgClone.firstChild);
                    }
                    
                    const svgData = new XMLSerializer().serializeToString(svgClone);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const svgUrl = URL.createObjectURL(svgBlob);
                    
                    const img = new Image();
                    img.width = width;
                    img.height = height;
                    
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        
                        // White background
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw the SVG image
                        ctx.drawImage(img, 0, 0, width, height);
                        
                        canvas.toBlob(blob => {
                            if (blob) {
                                const pngFilename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                                saveAs(blob, pngFilename);
                                console.log('✅ SVG chart exported as PNG:', pngFilename);
                            }
                            URL.revokeObjectURL(svgUrl);
                        }, 'image/png', 1.0);
                    };
                    
                    img.onerror = (e) => {
                        console.error('Failed to convert SVG to PNG for:', cleanTitle, e);
                        URL.revokeObjectURL(svgUrl);
                        
                        // Fallback: Try with base64 encoding
                        try {
                            const base64Url = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
                            const fallbackImg = new Image();
                            fallbackImg.onload = () => {
                                const canvas = document.createElement('canvas');
                                canvas.width = width;
                                canvas.height = height;
                                const ctx = canvas.getContext('2d');
                                ctx.fillStyle = 'white';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(fallbackImg, 0, 0);
                                
                                canvas.toBlob(blob => {
                                    if (blob) {
                                        const pngFilename = `SSVD1x_${cleanTitle}_${timestamp}.png`;
                                        saveAs(blob, pngFilename);
                                        console.log('✅ SVG chart exported as PNG (fallback):', pngFilename);
                                    }
                                }, 'image/png', 1.0);
                            };
                            fallbackImg.src = base64Url;
                        } catch (fallbackError) {
                            console.error('Fallback also failed:', fallbackError);
                        }
                    };
                    
                    img.src = svgUrl;
                } catch (error) {
                    console.error('Error exporting SVG chart:', error);
                }
            });
        };

        // Export Clustered Heatmap with Dendrograms as Single Composite Image
        const exportClusteredHeatmapComposite = async () => {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

                // Find the three canvases
                const heatmapCanvas = document.querySelector('canvas[data-chart-type="heatmap-clustered"]');
                const rowDendrogramCanvas = heatmapCanvas?.previousElementSibling;
                const colDendrogramCanvas = heatmapCanvas?.parentElement?.previousElementSibling?.querySelector('canvas');

                if (!heatmapCanvas) {
                    alert('No clustered heatmap found. Please run clustering first.');
                    return;
                }

                console.log('📊 Found clustered heatmap components:', {
                    heatmap: !!heatmapCanvas,
                    rowDendrogram: !!rowDendrogramCanvas,
                    colDendrogram: !!colDendrogramCanvas
                });

                // Get dimensions
                const heatmapWidth = heatmapCanvas.width;
                const heatmapHeight = heatmapCanvas.height;
                const rowDendrogramWidth = rowDendrogramCanvas ? rowDendrogramCanvas.width : 0;
                const colDendrogramHeight = colDendrogramCanvas ? colDendrogramCanvas.height : 0;

                // Calculate composite canvas dimensions
                const compositeWidth = rowDendrogramWidth + heatmapWidth;
                const compositeHeight = colDendrogramHeight + heatmapHeight;

                // Create composite canvas
                const compositeCanvas = document.createElement('canvas');
                compositeCanvas.width = compositeWidth;
                compositeCanvas.height = compositeHeight;
                const ctx = compositeCanvas.getContext('2d');

                // Fill with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, compositeWidth, compositeHeight);

                // Draw column dendrogram at top-right (if exists)
                if (colDendrogramCanvas) {
                    ctx.drawImage(
                        colDendrogramCanvas,
                        rowDendrogramWidth,  // x position (offset by row dendrogram width)
                        0,                   // y position (top)
                        colDendrogramCanvas.width,
                        colDendrogramHeight
                    );
                }

                // Draw row dendrogram at left-bottom (if exists)
                if (rowDendrogramCanvas) {
                    ctx.drawImage(
                        rowDendrogramCanvas,
                        0,                   // x position (left)
                        colDendrogramHeight, // y position (offset by column dendrogram height)
                        rowDendrogramWidth,
                        rowDendrogramCanvas.height
                    );
                }

                // Draw main heatmap at bottom-right
                ctx.drawImage(
                    heatmapCanvas,
                    rowDendrogramWidth,  // x position (offset by row dendrogram width)
                    colDendrogramHeight, // y position (offset by column dendrogram height)
                    heatmapWidth,
                    heatmapHeight
                );

                // Export as PNG
                compositeCanvas.toBlob(blob => {
                    if (blob) {
                        // Extract dimensions from title for filename
                        const heatmapContainer = heatmapCanvas.closest('.bg-white');
                        const titleElement = heatmapContainer?.querySelector('h3');
                        let filename = `SSVD1x_Clustered_Heatmap_Composite_${timestamp}.png`;

                        if (titleElement) {
                            const dimensionMatch = titleElement.textContent.match(/(\d+)\s+detections.*?(\d+)\s+samples/);
                            if (dimensionMatch) {
                                const detections = dimensionMatch[1];
                                const samples = dimensionMatch[2];
                                filename = `SSVD1x_Clustered_Heatmap_Composite_${detections}x${samples}_${timestamp}.png`;
                            }
                        }

                        saveAs(blob, filename);
                        console.log('✅ Clustered heatmap composite exported:', filename);
                    }
                }, 'image/png', 1.0);

            } catch (error) {
                console.error('Error exporting clustered heatmap composite:', error);
                alert('Error exporting clustered heatmap composite: ' + error.message);
            }
        };

        // JSON Export Functions
        const exportAnalysisStateJSON = (results, matrix, matrixInfo, analysisParams) => {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);

            const analysisState = {
                exportInfo: {
                    timestamp: new Date().toISOString(),
                    version: 'SSVD1x_v2.0',
                    exportType: 'complete_analysis_state'
                },
                summary: {
                    matrixDimensions: `${matrixInfo?.P || matrixInfo?.rows || 0} × ${matrixInfo?.N || matrixInfo?.cols || 0}`,
                    alpha: results.alpha,
                    detections: results.detections,
                    sparsityPercent: results.sparsity,
                    converged: results.converged,
                    eFDR: analysisParams?.eFDR ? `${(analysisParams.eFDR.eFDR * 100).toFixed(2)}%` : 'not calculated',
                    eFDRQuality: analysisParams?.eFDR ? (
                        analysisParams.eFDR.eFDR <= 0.05 ? 'excellent (≤5%)' :
                        analysisParams.eFDR.eFDR <= 0.10 ? 'acceptable (≤10%)' : 'high (>10%)'
                    ) : 'N/A'
                },
                matrixInfo: {
                    dimensions: {
                        rows: matrixInfo?.P || matrixInfo?.rows || 0,
                        cols: matrixInfo?.N || matrixInfo?.cols || 0
                    },
                    rowHeaders: matrixInfo.rowHeaders,
                    colHeaders: matrixInfo.colHeaders,
                    filename: matrixInfo.filename
                },
                analysisResults: {
                    alpha: results.alpha,
                    detections: results.detections,
                    sparsity: results.sparsity,
                    iterations: results.iterations,
                    converged: results.converged,
                    singularValue: results.s,
                    detectedIndices: results.detectedIndices,
                    errors: results.errors || [],
                    sparsityHistory: results.sparsityHistory || []
                },
                analysisParameters: analysisParams || {},
                eFDRValidation: analysisParams?.eFDR ? {
                    eFDR: analysisParams.eFDR.eFDR,
                    pi0: analysisParams.eFDR.pi0,
                    nsupp: analysisParams.eFDR.nsupp,
                    Nperm: analysisParams.eFDR.Nperm,
                    avgPermDetections: analysisParams.eFDR.avgPermDetections,
                    originalDetections: analysisParams.eFDR.originalDetections,
                    interpretation: `${(analysisParams.eFDR.eFDR * 100).toFixed(2)}% expected false discoveries`,
                    quality: analysisParams.eFDR.eFDR <= 0.05 ? 'excellent' :
                             analysisParams.eFDR.eFDR <= 0.10 ? 'acceptable' : 'high'
                } : null
            };

            const jsonContent = JSON.stringify(analysisState, null, 2);
            const filename = `SSVD1x_Analysis_State_${timestamp}.json`;
            const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8;' });
            saveAs(blob, filename);
            console.log('✅ Complete analysis state exported:', filename);
        };

        // PDF Report Generation with improved formatting
        const generatePDFReport = async (results, matrix, matrixInfo, analysisParams) => {
            try {
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF();
                
                const P = matrixInfo?.P || matrixInfo?.rows || 0;
                const N = matrixInfo?.N || matrixInfo?.cols || 0;

                // Page 1: Title and Executive Summary
                pdf.setFontSize(24);
                pdf.setFont(undefined, 'bold');
                pdf.text('SSVD1x Analysis Report', 105, 30, { align: 'center' });
                
                pdf.setFontSize(10);
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(100);
                pdf.text('Sparse Singular Value Decomposition Analysis', 105, 40, { align: 'center' });
                
                // Report metadata box
                pdf.setDrawColor(200);
                pdf.setFillColor(245, 245, 245);
                pdf.rect(15, 50, 180, 30, 'FD');
                
                pdf.setTextColor(0);
                pdf.setFontSize(10);
                pdf.text(`Generated: ${new Date().toLocaleString()}`, 20, 60);
                pdf.text(`File: ${matrixInfo?.filename || 'User Upload'}`, 20, 67);
                pdf.text(`Matrix Dimensions: ${P} × ${N} (P×N)`, 20, 74);
                
                // Analysis Results Section
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Analysis Parameters', 20, 95);
                
                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(11);
                
                // Two-column layout for parameters
                const leftCol = 25;
                const rightCol = 110;
                let yPos = 105;
                
                // Left column
                pdf.text(`Alpha Value:`, leftCol, yPos);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.alpha.toFixed(6)}`, leftCol + 35, yPos);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Detections:`, leftCol, yPos + 8);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.detections} / ${P} (${((results.detections/P)*100).toFixed(1)}%)`, leftCol + 35, yPos + 8);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Sparsity:`, leftCol, yPos + 16);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.sparsity || 0}% non-zero`, leftCol + 35, yPos + 16);
                pdf.setFont(undefined, 'normal');
                
                // Right column
                pdf.text(`Iterations:`, rightCol, yPos);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.iterations || 'N/A'}`, rightCol + 35, yPos);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Converged:`, rightCol, yPos + 8);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.converged ? 'Yes' : 'No'}`, rightCol + 35, yPos + 8);
                pdf.setFont(undefined, 'normal');
                
                pdf.text(`Singular Value:`, rightCol, yPos + 16);
                pdf.setFont(undefined, 'bold');
                pdf.text(`${results.s.toFixed(4)}`, rightCol + 35, yPos + 16);
                pdf.setFont(undefined, 'normal');

                // Update yPos after Analysis Parameters section
                yPos += 24; // Move past the 3 rows of parameters (16 + 8 spacing)

                // eFDR Validation Section (if available)
                // Check both analysisParams.eFDR (permutation-based) and results.eFDR (from N-alpha)
                const eFDRData = analysisParams?.eFDR;
                const haseFDR = eFDRData || results.eFDR !== undefined;

                if (haseFDR) {
                    yPos += 30;

                    pdf.setFontSize(16);
                    pdf.setFont(undefined, 'bold');
                    pdf.setTextColor(138, 43, 226); // Purple color for eFDR
                    pdf.text('Statistical Significance (eFDR)', 20, yPos);

                    pdf.setFont(undefined, 'normal');
                    pdf.setTextColor(0);
                    pdf.setFontSize(11);

                    yPos += 10;

                    // eFDR value with quality indicator
                    pdf.text(`eFDR:`, leftCol, yPos);
                    pdf.setFont(undefined, 'bold');

                    // Handle both formats: eFDRData (from permutations) or results.eFDR (from N-alpha, already percentage)
                    let eFDRpercent, quality, eFDRfraction;
                    if (eFDRData) {
                        // Permutation-based: eFDRData.eFDR is a fraction (0-1)
                        eFDRfraction = eFDRData.eFDR;
                        eFDRpercent = (eFDRfraction * 100).toFixed(2);
                        quality = eFDRfraction <= 0.05 ? '(Excellent)' : eFDRfraction <= 0.10 ? '(Acceptable)' : '(High)';
                    } else {
                        // N-alpha based: results.eFDR is already a percentage
                        eFDRpercent = results.eFDR.toFixed(2);
                        eFDRfraction = results.eFDR / 100;
                        quality = eFDRfraction <= 0.05 ? '(Excellent)' : eFDRfraction <= 0.10 ? '(Acceptable)' : '(High)';
                    }

                    pdf.text(`${eFDRpercent}% ${quality}`, leftCol + 35, yPos);
                    pdf.setFont(undefined, 'normal');

                    // Parameters (only if from permutation-based analysis)
                    if (eFDRData) {
                        pdf.text(`pi0:`, leftCol, yPos + 8);
                        pdf.setFont(undefined, 'bold');
                        pdf.text(`${eFDRData.pi0.toFixed(4)}`, leftCol + 35, yPos + 8);
                        pdf.setFont(undefined, 'normal');

                        pdf.text(`Permutations:`, rightCol, yPos);
                        pdf.setFont(undefined, 'bold');
                        pdf.text(`${eFDRData.Nperm}`, rightCol + 35, yPos);
                        pdf.setFont(undefined, 'normal');

                        pdf.text(`Expected Support:`, rightCol, yPos + 8);
                        pdf.setFont(undefined, 'bold');
                        pdf.text(`${eFDRData.nsupp}`, rightCol + 35, yPos + 8);
                        pdf.setFont(undefined, 'normal');

                        // Interpretation
                        yPos += 20;
                        pdf.setFontSize(10);
                        const expectedFP = (eFDRData.eFDR * eFDRData.originalDetections).toFixed(1);
                        pdf.text(`Interpretation: Approximately ${expectedFP} of ${eFDRData.originalDetections} detected features`, 25, yPos);
                        pdf.text(`are expected to be false discoveries.`, 25, yPos + 6);
                        yPos += 10; // Add spacing after interpretation
                        pdf.text(`Source: eFDR estimation based on ${eFDRData.Nperm} permutations`, 25, yPos);
                        yPos += 6; // Line spacing
                    } else {
                        yPos += 8;
                        pdf.setFontSize(10);
                        pdf.text(`Source: N-alpha analysis with multi-alpha eFDR estimation`, 25, yPos);
                        yPos += 6; // Line spacing
                    }

                    yPos += 15; // Add space after eFDR section
                }

                // Experiment Description Section
                yPos += 10; // Add spacing before Analysis Overview
                pdf.setFontSize(16);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Analysis Overview', 20, yPos);

                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(10);

                // Experiment description text
                yPos += 10;
                const descText = [
                    `This SSVD analysis was performed on a ${P} × ${N} data matrix to identify sparse patterns`,
                    `in the first singular vector using L1 regularization with alpha = ${results.alpha.toFixed(4)}.`,
                    '',
                    `The algorithm detected ${results.detections} variables (${((results.detections/P)*100).toFixed(1)}% of total)`,
                    `that contribute to the primary singular vector pattern with singular value ${results.s.toFixed(2)}.`
                ];

                descText.forEach(line => {
                    if (line) {
                        pdf.text(line, 20, yPos);
                    }
                    yPos += 6;
                });

                // Analysis Method Box
                yPos += 10; // Add spacing before Method Details
                pdf.setFontSize(14);
                pdf.setFont(undefined, 'bold');
                pdf.setTextColor(0, 102, 204);
                pdf.text('Method Details', 20, yPos);

                pdf.setFont(undefined, 'normal');
                pdf.setTextColor(0);
                pdf.setFontSize(9);

                // Method info box
                yPos += 5; // Small gap before box
                pdf.setFillColor(245, 250, 255);
                pdf.rect(15, yPos, 180, 45, 'FD');

                let methodY = yPos + 8;
                pdf.text('Algorithm: Sparse SVD Rank-1 (SSVD-R1) with iterative soft thresholding', 20, methodY);
                methodY += 7;
                pdf.text(`Regularization: L1 penalty with alpha = ${results.alpha.toFixed(6)}`, 20, methodY);
                methodY += 7;
                pdf.text(`Convergence: ${results.converged ? 'Yes' : 'No'} (${results.iterations} iterations)`, 20, methodY);
                methodY += 7;
                pdf.text(`Detection Threshold: |U| > 1e-8`, 20, methodY);
                methodY += 7;
                pdf.text(`Analysis Mode: ${analysisParams?.analysisType || 'Single Alpha'}`, 20, methodY);
                
                // Add a note about visualizations
                if (results.detections > 0) {
                    methodY += 10;
                    pdf.setFont(undefined, 'italic');
                    pdf.setFontSize(8);
                    pdf.setTextColor(100);
                    pdf.text('Note: Export charts separately for U1/V1 plots and solution submatrix heatmap visualizations.', 20, methodY);
                }

                const filename = `SSVD1x_Report_${timestamp}.pdf`;
                pdf.save(filename);
                console.log('✅ PDF report generated:', filename);
            } catch (error) {
                console.error('Error generating PDF report:', error);
                alert('Error generating PDF report. Please try again.');
            }
        };

        // Unified Export Function
        const exportAllFormats = async (results, matrix, matrixInfo, analysisParams) => {
            try {
                console.log('📦 Starting comprehensive export...');

                // Export CSVs
                exportDetectedRowsCSV(results, matrix, matrixInfo);
                setTimeout(() => exportV1ScoresCSV(results, matrixInfo), 200);
                setTimeout(() => exportAnalysisParametersCSV(results, matrixInfo, analysisParams), 400);

                // Export JSON
                setTimeout(() => exportAnalysisStateJSON(results, matrix, matrixInfo, analysisParams), 600);
                
                // Export Charts
                setTimeout(() => exportChartsAsImages(), 800);

                // Export PDF
                setTimeout(() => generatePDFReport(results, matrix, matrixInfo, analysisParams), 1000);
                
                console.log('📦 All exports initiated successfully');
            } catch (error) {
                console.error('Error in comprehensive export:', error);
                alert('Error during export process. Some files may not have been generated.');
            }
        };

        // SSVD Results Display Components
        const SSVDResultsDisplay = ({ results, matrixInfo, matrix, onResetToOriginal, onRerunWithAlpha, onBack, selectedAlphaeFDR }) => {
            if (!results) return null;

            // Defensive check: ensure results has required properties
            if (!results.u || !Array.isArray(results.u)) {
                console.error('SSVDResultsDisplay: Invalid results object - missing u vector', results);
                return (
                    <div className="bg-red-50 border border-red-200 rounded-lg p-4 mt-6">
                        <h3 className="text-red-800 font-medium mb-2">Display Error</h3>
                        <p className="text-red-700 text-sm">
                            The analysis results are incomplete or corrupted. Please run the analysis again.
                        </p>
                        <button
                            onClick={onNewAnalysis}
                            className="mt-3 bg-red-600 text-white px-4 py-2 rounded-lg text-sm hover:bg-red-700"
                        >
                            Run New Analysis
                        </button>
                    </div>
                );
            }
            
            // Export UI state
            const [showExportMenu, setShowExportMenu] = useState(false);
            
            // Individual export handlers that use the new comprehensive functions
            const handleExportDetectedRows = () => {
                console.log('Export Detected Rows clicked. Results:', results, 'Matrix:', matrix?.length, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportDetectedRowsCSV(results, matrix, matrixInfo);
                setShowExportMenu(false);
            };

            const handleExportV1Scores = () => {
                console.log('Export V1 Scores clicked. Results:', results, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportV1ScoresCSV(results, matrixInfo);
                setShowExportMenu(false);
            };

            const handleExportParameters = () => {
                console.log('Export Parameters clicked. Results:', results, 'MatrixInfo:', matrixInfo);
                if (!results) {
                    alert('No results available. Please run analysis first.');
                    return;
                }
                exportAnalysisParametersCSV(results, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            const handleExportCharts = async () => {
                try {
                    await exportChartsAsImages();
                    setShowExportMenu(false);
                } catch (error) {
                    console.error('Export charts failed:', error);
                    alert('Failed to export charts: ' + error.message);
                }
            };
            
            const handleExportJSON = () => {
                exportAnalysisStateJSON(results, matrix, matrixInfo, { alpha: results.alpha, eFDR: selectedAlphaeFDR });
                setShowExportMenu(false);
            };
            
            const handleExportPDF = () => {
                // Pass selectedAlphaeFDR directly as the eFDR parameter
                const analysisParams = {
                    alpha: results.alpha,
                    analysisType: results.parameters?.analysisType || 'single'
                };
                // Only add eFDR if it exists
                if (selectedAlphaeFDR) {
                    analysisParams.eFDR = selectedAlphaeFDR;
                }
                generatePDFReport(results, matrix, matrixInfo, analysisParams);
                setShowExportMenu(false);
            };
            
            const handleExportAll = () => {
                exportAllFormats(results, matrix, matrixInfo, { alpha: results.alpha });
                setShowExportMenu(false);
            };
            
            return (
                <div className="space-y-6 mt-6">
                    {/* Summary Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="mb-4 flex justify-between items-center">
                            <h2 className="text-xl font-semibold">
                                {results.fromAnalysisStep === 'nalpha' ? 'Summary of Results for Selected Alpha' : 'Summary of Results'}
                            </h2>
                            <div className="flex items-center gap-3">
                                {/* Back Button - show for N-alpha and eFDR analysis */}
                                {(results.fromAnalysisStep === 'nalpha' || results.fromAnalysisStep === 'efdr') && onBack && (
                                    <button
                                        onClick={onBack}
                                        className="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                        title={results.fromAnalysisStep === 'nalpha' ? 'Back to N-alpha results table' : 'Back to eFDR results'}
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                                        </svg>
                                        Back
                                    </button>
                                )}

                                {/* Reset Button - show for N-alpha and eFDR analysis only (single-alpha has Reset at top) */}
                                {(results.fromAnalysisStep === 'nalpha' || results.fromAnalysisStep === 'efdr') && (
                                    <button
                                        onClick={onResetToOriginal}
                                        className="bg-gradient-to-r from-gray-500 to-gray-600 hover:from-gray-600 hover:to-gray-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                        title="Reset and upload new data"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
                                        </svg>
                                        Reset
                                    </button>
                                )}

                                {/* Export Button */}
                                <div className="relative">
                                    <button
                                        onClick={() => setShowExportMenu(!showExportMenu)}
                                        data-export-button
                                        className="bg-gradient-to-r from-green-600 to-blue-600 hover:from-green-700 hover:to-blue-700 text-white px-4 py-2 rounded-lg font-medium text-sm flex items-center gap-2 transition-colors"
                                        title="Export analysis results in multiple formats"
                                    >
                                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" />
                                        </svg>
                                        Export
                                        <svg className={`w-4 h-4 transition-transform ${showExportMenu ? 'rotate-180' : ''}`} fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M19 9l-7 7-7-7" />
                                        </svg>
                                    </button>

                            {showExportMenu && (
                                <div className="absolute right-0 mt-2 w-64 bg-white rounded-lg shadow-xl border border-gray-200 z-50">
                                    <div className="p-3 border-b border-gray-200">
                                        <h3 className="text-sm font-semibold text-gray-800">Export Options</h3>
                                        <p className="text-xs text-gray-600">Alpha = {results?.alpha?.toFixed(4) || 'N/A'}</p>
                                    </div>
                                    <div className="p-2 space-y-1">
                                        <button
                                            onClick={handleExportDetectedRows}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-blue-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-blue-600">📊</span>
                                            Detected Rows (CSV)
                                        </button>
                                        <button
                                            onClick={handleExportV1Scores}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-indigo-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-indigo-600">📉</span>
                                            V1 Scores (CSV)
                                        </button>
                                        <button
                                            onClick={handleExportParameters}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-green-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-green-600">⚙️</span>
                                            Analysis Parameters (CSV)
                                        </button>
                                        <button
                                            onClick={handleExportCharts}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-purple-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-purple-600">📈</span>
                                            Charts (PNG)
                                        </button>
                                        <button
                                            onClick={handleExportJSON}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-orange-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-orange-600">🔢</span>
                                            Complete State (JSON)
                                        </button>
                                        <button
                                            onClick={handleExportPDF}
                                            className="w-full text-left px-3 py-2 text-sm hover:bg-red-50 rounded-md flex items-center gap-2"
                                        >
                                            <span className="text-red-600">📄</span>
                                            Report (PDF)
                                        </button>
                                        <div className="border-t border-gray-200 pt-2 mt-2">
                                            <button
                                                onClick={handleExportAll}
                                                className="w-full text-left px-3 py-2 text-sm bg-gradient-to-r from-green-50 to-blue-50 hover:from-green-100 hover:to-blue-100 rounded-md flex items-center gap-2 font-medium"
                                            >
                                                <span className="text-indigo-600">📦</span>
                                                Export All Formats
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            )}
                                </div>
                            </div>
                        </div>
                        <div className={`grid grid-cols-1 ${results.eFDR !== undefined ? 'md:grid-cols-5' : 'md:grid-cols-4'} gap-4 mb-6`}>
                            <div className="bg-blue-50 p-4 rounded-lg cursor-help transition-all hover:shadow-md" title="L1 regularization parameter controlling sparsity level. Higher values = more sparsity.">
                                <div className="text-sm text-blue-600 font-medium">Alpha Value</div>
                                <div className="text-2xl font-bold text-blue-900">{results.alpha.toFixed(4)}</div>
                                <div className="text-xs text-blue-600">sparsity parameter</div>
                            </div>
                            {results.eFDR !== undefined && (
                                <div className="bg-yellow-50 p-4 rounded-lg cursor-help transition-all hover:shadow-md" title="Empirical False Discovery Rate: estimated proportion of false positives among detections. Lower is better.">
                                    <div className="text-sm text-yellow-600 font-medium">eFDR</div>
                                    <div className="text-2xl font-bold text-yellow-900">{results.eFDR.toFixed(2)}%</div>
                                    <div className="text-xs text-yellow-600">false discovery rate</div>
                                </div>
                            )}
                            <div className="bg-green-50 p-4 rounded-lg cursor-help transition-all hover:shadow-md" title="Number of variables with non-zero loadings identified as containing signal.">
                                <div className="text-sm text-green-600 font-medium">Detections</div>
                                <div className="text-2xl font-bold text-green-900">{results.detections}</div>
                                <div className="text-xs text-green-600">out of {results.u.length}</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg cursor-help transition-all hover:shadow-md" title="Percentage of variables with non-zero loadings in the sparse solution.">
                                <div className="text-sm text-purple-600 font-medium">Sparsity</div>
                                <div className="text-2xl font-bold text-purple-900">{results.sparsity}%</div>
                                <div className="text-xs text-purple-600">non-zero loadings</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg cursor-help transition-all hover:shadow-md" title="Number of iterations required for the SSVD algorithm to converge or reach maximum limit.">
                                <div className="text-sm text-orange-600 font-medium">Iterations</div>
                                <div className="text-2xl font-bold text-orange-900">{results.iterations || 'N/A'}</div>
                                <div className="text-xs text-orange-600">{results.converged ? 'Converged' : 'Max iterations reached'}</div>
                            </div>
                        </div>
                    </div>
                    
                    {/* U1 Vector Visualization */}
                    <U1VectorPlot u={results.u} alpha={results.alpha} detectedIndices={results.detectedIndices} />
                    
                    {/* V1 Vector Visualization */}
                    <V1VectorPlot v={results.v} s={results.s} />
                    
                    {/* Solution Submatrix Heatmap */}
                    <HeatmapChart ssvdResults={results} matrix={matrix} analysisMode={results.fromAnalysisStep || 'single'} />
                </div>
            );
        };
        
        // U1 Vector Scatter Plot Component
        const U1VectorPlot = ({ u, alpha, detectedIndices }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || !u) return;
                
                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                
                // Prepare data for scatter plot
                const data = u.map((val, idx) => ({
                    x: idx + 1,
                    y: val
                }));
                
                // Separate detected and undetected points using stored indices
                const detectedSet = new Set(detectedIndices || []);
                const detectedPoints = data.filter(p => detectedSet.has(p.x - 1)); // Convert back to 0-based for comparison
                const undetectedPoints = data.filter(p => !detectedSet.has(p.x - 1));
                
                chartRef.current = new Chart(canvasRef.current, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: `Detected (${detectedPoints.length})`,
                                data: detectedPoints,
                                backgroundColor: 'rgba(34, 197, 94, 0.6)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                pointRadius: 4
                            },
                            {
                                label: `Undetected (${undetectedPoints.length})`,
                                data: undetectedPoints,
                                backgroundColor: 'rgba(156, 163, 175, 0.3)',
                                borderColor: 'rgba(156, 163, 175, 0.5)',
                                pointRadius: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `U1 Vector - Sparse Biomarker Detection (α = ${alpha.toFixed(4)})`
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Row Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'U1 Value'
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [u, alpha]);
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Sparse Left-Singular Vector U1</h3>
                    <div className="h-80">
                        <canvas ref={canvasRef}></canvas>
                    </div>
                </div>
            );
        };
        
        // V1 Vector Line Plot Component - Enhanced with sorted scores
        const V1VectorPlot = ({ v, s }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            const canvasRef2 = useRef(null);
            const chartRef2 = useRef(null);

            // Create sorted version of V1 with indices
            const sortedV1Data = useMemo(() => {
                if (!v) return null;
                // Create array of {value, originalIndex} pairs
                const indexed = v.map((value, idx) => ({ value, originalIndex: idx }));
                // Sort by value (ascending)
                const sorted = [...indexed].sort((a, b) => a.value - b.value);
                return {
                    sortedValues: sorted.map(item => item.value),
                    sortedIndices: sorted.map(item => item.originalIndex),
                    originalIndices: sorted.map((_, idx) => idx + 1) // 1-based for display
                };
            }, [v]);

            // Original V1 plot
            useEffect(() => {
                if (!canvasRef.current || !v) return;

                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }

                chartRef.current = new Chart(canvasRef.current, {
                    type: 'line',
                    data: {
                        labels: v.map((_, idx) => idx + 1),
                        datasets: [{
                            label: `V1 Vector (σ = ${s.toFixed(4)})`,
                            data: v,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Dense Right-Singular Vector V1 (Original Order)'
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Sample Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'V1 Value'
                                }
                            }
                        }
                    }
                });

                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [v, s]);

            // Sorted V1 plot with quartile lines
            useEffect(() => {
                if (!canvasRef2.current || !sortedV1Data) return;

                // Destroy existing chart
                if (chartRef2.current) {
                    chartRef2.current.destroy();
                }

                // Calculate quartile positions
                const n = sortedV1Data.sortedValues.length;
                const q1Position = Math.floor(n * 0.25);
                const q2Position = Math.floor(n * 0.50);
                const q3Position = Math.floor(n * 0.75);

                // Store quartile positions globally for heatmap use
                if (window) {
                    window.v1QuartilePositions = {
                        q1: q1Position,
                        q2: q2Position,
                        q3: q3Position,
                        total: n
                    };
                }

                chartRef2.current = new Chart(canvasRef2.current, {
                    type: 'line',
                    data: {
                        labels: sortedV1Data.originalIndices,
                        datasets: [{
                            label: `Sorted V1 Scores (σ = ${s.toFixed(4)})`,
                            data: sortedV1Data.sortedValues,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'V1 Scores Sorted (Ascending) with Quartiles'
                            },
                            legend: {
                                display: true
                            },
                            tooltip: {
                                callbacks: {
                                    afterLabel: function(context) {
                                        if (sortedV1Data && sortedV1Data.sortedIndices && sortedV1Data.sortedIndices.length > context.dataIndex) {
                                            const originalIdx = sortedV1Data.sortedIndices[context.dataIndex];
                                            return `Original Index: ${originalIdx + 1}`;
                                        }
                                        return '';
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Rank (Sorted Position)'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'V1 Score'
                                }
                            }
                        }
                    },
                    plugins: [{
                        afterDraw: function(chart) {
                            const ctx = chart.ctx;
                            const chartArea = chart.chartArea;

                            // Calculate quartile positions on the chart
                            const xScale = chart.scales.x;
                            const yScale = chart.scales.y;

                            const q1X = xScale.getPixelForValue(q1Position);
                            const q2X = xScale.getPixelForValue(q2Position);
                            const q3X = xScale.getPixelForValue(q3Position);

                            // Draw quartile lines
                            ctx.save();
                            ctx.setLineDash([5, 5]);
                            ctx.lineWidth = 2;
                            ctx.globalAlpha = 0.7;

                            // Q1 line (pink)
                            ctx.strokeStyle = 'rgba(220, 38, 127, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q1X, chartArea.top);
                            ctx.lineTo(q1X, chartArea.bottom);
                            ctx.stroke();

                            // Q2 line (purple)
                            ctx.strokeStyle = 'rgba(147, 51, 234, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q2X, chartArea.top);
                            ctx.lineTo(q2X, chartArea.bottom);
                            ctx.stroke();

                            // Q3 line (blue)
                            ctx.strokeStyle = 'rgba(59, 130, 246, 1)';
                            ctx.beginPath();
                            ctx.moveTo(q3X, chartArea.top);
                            ctx.lineTo(q3X, chartArea.bottom);
                            ctx.stroke();

                            ctx.restore();
                        }
                    }]
                });

                return () => {
                    if (chartRef2.current) {
                        chartRef2.current.destroy();
                    }
                };
            }, [sortedV1Data, s]);

            // Export sorted indices for use by heatmap
            useEffect(() => {
                if (sortedV1Data && window) {
                    window.v1SortedIndices = sortedV1Data.sortedIndices;
                }
            }, [sortedV1Data]);

            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Dense Right-Singular Vector V1 Analysis</h3>
                    <div className="h-80 mb-6">
                        <canvas ref={canvasRef} data-chart-type="v1-original"></canvas>
                    </div>
                    <div className="h-80">
                        <canvas ref={canvasRef2} data-chart-type="v1-sorted"></canvas>
                    </div>
                </div>
            );
        };
        
        const App = () => {
            // Original data state
            const [originalMatrix, setOriginalMatrix] = useState(null);
            const [originalMatrixInfo, setOriginalMatrixInfo] = useState(null);
            const [originalStatistics, setOriginalStatistics] = useState(null);
            const [originalEigenvalues, setOriginalEigenvalues] = useState(null);
            
            // Working data state (can be original or preprocessed)
            const [matrix, setMatrix] = useState(null);
            const [matrixInfo, setMatrixInfo] = useState(null);
            const [statistics, setStatistics] = useState(null);
            const [eigenvalues, setEigenvalues] = useState(null);
            
            // Processing state
            // Preprocessing state removed
            
            // Analysis state
            const [fdrResults, setFDRResults] = useState(null);
            const [selectedAlpha, setSelectedAlpha] = useState(null);
            const [ssvdResults, setSSVDResults] = useState(null);
            const [showAnalysisPanel, setShowAnalysisPanel] = useState(false);
            const [analysisStep, setAnalysisStep] = useState(null); // null, 'single', 'multi', 'alpha', 'efdr'

            const handleDataLoaded = (newMatrix, newMatrixInfo) => {
                // Calculate SVD once for this matrix
                console.log('Calculating initial SVD for matrix...');
                const svdResult = svd1Sync(newMatrix);
                
                // Calculate alphaMax using the SVD result
                console.log('Calculating alphaMax from SVD...');
                const maxAbsU1 = Math.max(...svdResult.u.map(val => Math.abs(val)));
                const calculatedAlphaMax = 0.75 * maxAbsU1 * svdResult.s;
                
                // Add SVD results and alphaMax to matrixInfo
                const enrichedMatrixInfo = {
                    ...newMatrixInfo,
                    alphaMax: calculatedAlphaMax,
                    initialSVD: svdResult  // Cache the SVD for reuse
                };
                
                // Store both as original and working data
                setOriginalMatrix(newMatrix);
                setOriginalMatrixInfo(enrichedMatrixInfo);
                setMatrix(newMatrix);
                setMatrixInfo(enrichedMatrixInfo);
                
                // Calculate statistics for data review
                console.log('Calculating matrix statistics...');
                const stats = calculateMatrixStatistics(newMatrix);
                setOriginalStatistics(stats);
                setStatistics(stats);
                
                // Eigenvalue computation moved to external preprocessing
                console.log('Skipping eigenvalue computation for large matrix performance');
                setOriginalEigenvalues([]);
                setEigenvalues([]);
                
                console.log(`Data loaded: ${enrichedMatrixInfo.P}×${enrichedMatrixInfo.N} matrix, alphaMax: ${calculatedAlphaMax.toFixed(6)}`);
            };

            const resetData = () => {
                console.log('Reset button clicked - clearing all data and results');
                
                // Reset original data
                setOriginalMatrix(null);
                setOriginalMatrixInfo(null);
                setOriginalStatistics(null);
                setOriginalEigenvalues(null);
                
                // Reset working data
                setMatrix(null);
                setMatrixInfo(null);
                setStatistics(null);
                setEigenvalues(null);
                
                // Reset ALL analysis state and results
                setFDRResults(null);
                setSelectedAlpha(null);
                setSSVDResults(null);
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                // Scroll to top to show upload page
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                console.log('All data and results cleared - returning to upload page');
            };
            
            const handleProceedToAnalysis = () => {
                // Clear any analysis results and start stepped selection
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setAnalysisStep(null); // Start at step 1: Single vs Multi
                setShowAnalysisPanel(true);
                
                // Smooth scroll to analysis section
                setTimeout(() => {
                    window.scrollTo({
                        top: document.documentElement.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
            };
            
            const handleAnalysisStepSelect = (step) => {
                setAnalysisStep(step);
            };
            
            const handleBackToDataReview = () => {
                setShowAnalysisPanel(false);
                setAnalysisStep(null);
            };
            
            
            const handleResetToOriginalData = () => {
                // Reset to original data
                setMatrix(originalMatrix);
                setMatrixInfo(originalMatrixInfo);
                setStatistics(originalStatistics);
                setEigenvalues(originalEigenvalues);
                
                // Clear ALL analysis results and go back to data review
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setFDRResults(null);
                setSelectedAlpha(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                console.log('Reset to original data for analysis');
            };
            
            const handleRerunWithAlpha = async (newAlpha) => {
                try {
                    console.log(`Re-running SSVD with alpha=${newAlpha}`);
                    const results = await runSingleAlphaAnalysis(newAlpha);
                    setAnalysisResults(results);
                    console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity`);
                } catch (error) {
                    console.error('Re-run failed:', error);
                    alert(`Failed to re-run analysis: ${error.message}`);
                }
            };
            
            const handleCancelAnalysis = () => {
                setShowAnalysisPanel(false);
            };
            
            const [isRunningAnalysis, setIsRunningAnalysis] = useState(false);
            const [analysisProgress, setAnalysisProgress] = useState({ current: 0, total: 0, message: '' });
            const [isAnalysisCancelled, setIsAnalysisCancelled] = useState(false);
            const isAnalysisCancelledRef = useRef(false); // Use ref for immediate access in async callbacks
            const [analysisResults, setAnalysisResults] = useState(null);
            const [alphaSequenceResults, setAlphaSequenceResults] = useState(null);
            const [selectedAlphaIndex, setSelectedAlphaIndex] = useState(null);

            // eFDR calculation state - simplified state machine
            const [eFDRState, seteFDRState] = useState('idle'); // 'idle', 'running', 'complete'
            const [eFDRParameters, seteFDRParameters] = useState({ Nperm: 25 });
            const [selectedAlphaeFDR, setSelectedAlphaeFDR] = useState(null);

            // Ref for auto-scrolling to progress indicator
            const progressIndicatorRef = useRef(null);
            
            const runSingleAlphaAnalysis = async (alpha) => {
                console.log(`Running SSVD with alpha=${alpha}, using cached SVD: ${matrixInfo?.initialSVD ? 'yes' : 'no'}`);
                console.log(`SSVD Parameters: maxIter=1000, tolerance=0.001`);
                const startTime = performance.now();
                const results = await SSVDR1Algorithm({
                    matrix: matrix,
                    alpha: alpha,
                    maxIter: 1000,
                    tolerance: 0.001,
                    initialSVD: matrixInfo?.initialSVD  // Pass cached SVD
                });
                const endTime = performance.now();
                const elapsedSeconds = (endTime - startTime) / 1000;
                console.log(`SSVD completed in ${elapsedSeconds.toFixed(2)}s with ${results.iterations} iterations`);

                // Format elapsed time for display
                const formatElapsedTime = (seconds) => {
                    if (seconds < 60) {
                        return `${seconds.toFixed(1)}s`;
                    } else if (seconds < 3600) {
                        const minutes = Math.floor(seconds / 60);
                        const remainingSeconds = Math.floor(seconds % 60);
                        return `${minutes}m ${remainingSeconds}s`;
                    } else {
                        const hours = Math.floor(seconds / 3600);
                        const minutes = Math.floor((seconds % 3600) / 60);
                        return `${hours}h ${minutes}m`;
                    }
                };
                const elapsedTimeFormatted = formatElapsedTime(elapsedSeconds);
                
                // Calculate detected indices and summary statistics
                const detectedIndices = [];
                results.u.forEach((val, idx) => {
                    if (Math.abs(val) > 1e-8) {
                        detectedIndices.push(idx);
                    }
                });
                const detections = detectedIndices.length;
                // Sparsity = percentage of non-zero loadings in u1
                const sparsity = (detections / matrix.length * 100).toFixed(1);
                
                return {
                    mode: 'single',
                    alpha: alpha,
                    u: results.u,
                    v: results.v,
                    s: results.s,
                    detections: detections,
                    detectedIndices: detectedIndices,
                    sparsity: sparsity,
                    iterations: results.iterations,
                    converged: results.converged,
                    convergenceInfo: results.convergenceInfo,
                    elapsedTime: elapsedTimeFormatted,
                    fromAnalysisStep: 'single',
                    parameters: {
                        analysisType: 'single',
                        alpha: alpha,
                        matrixSize: `${matrix.length} × ${matrix[0].length}`
                    }
                };
            };

            const handleRunSingleAlphaeFDR = async (nsupp) => {
                if (!nsupp || !analysisResults) return;

                console.log('Starting single-alpha eFDR calculation...');
                console.log('Alpha:', analysisResults.alpha);
                console.log('Original detections:', analysisResults.nonZeroIndices?.length || analysisResults.detectedIndices?.length);
                console.log('nsupp:', nsupp);
                console.log('Nperm:', eFDRParameters.Nperm);

                setSelectedAlphaeFDR(null); // Clear previous results
                seteFDRState('running'); // State machine transition: idle → running
                setIsRunningAnalysis(true);
                setIsAnalysisCancelled(false);
                isAnalysisCancelledRef.current = false; // Reset ref for new analysis

                // Initialize progress with known total
                const Nperm = eFDRParameters.Nperm || 25;
                setAnalysisProgress({ current: 0, total: Nperm, message: 'Initializing eFDR analysis...' });

                // Auto-scroll to progress section after brief delay
                setTimeout(() => {
                    const progressElement = document.querySelector('[data-efdr-progress]');
                    if (progressElement) {
                        progressElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 200);

                try {
                    // Use cached detection count from N-alpha analysis
                    const originalDetections = analysisResults.nonZeroIndices?.length || analysisResults.detectedIndices?.length || 0;

                    const result = await runPermutationsForAlpha({
                        matrix: matrix,
                        alpha: analysisResults.alpha,
                        originalDetections: originalDetections,
                        Nperm: Nperm,
                        nsupp: nsupp,
                        onProgress: (current, total, message) => {
                            console.log(`📊 Progress update: ${current}/${total} - ${message}`);
                            setAnalysisProgress({ current, total, message });
                        },
                        isCancelled: () => isAnalysisCancelledRef.current // Use ref for immediate access
                    });

                    setSelectedAlphaeFDR(result);

                    // Update analysisResults with eFDR value (as percentage for consistency with N-alpha mode)
                    setAnalysisResults(prev => ({
                        ...prev,
                        eFDR: result.eFDR * 100  // Convert fraction to percentage
                    }));

                    seteFDRState('complete'); // State machine transition: running → complete
                    console.log('✅ eFDR calculated:', result);

                    // Auto-scroll to eFDR results after a brief delay for rendering
                    setTimeout(() => {
                        const eFDRElement = document.querySelector('[data-efdr-results]');
                        if (eFDRElement) {
                            eFDRElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        }
                    }, 300);
                } catch (error) {
                    // Check if cancelled - if so, suppress ALL error messages
                    if (isAnalysisCancelledRef.current) {
                        console.log('🛑 eFDR calculation was cancelled - suppressing error:', error.message);
                    } else {
                        // Only show alert for real errors, not cancellation
                        console.error('❌ eFDR calculation failed:', error);
                        if (!error.message.includes('cancelled')) {
                            alert('eFDR calculation failed: ' + error.message);
                        }
                    }
                    seteFDRState('idle'); // State machine transition: running → idle (on error)
                } finally {
                    setIsRunningAnalysis(false);
                    setAnalysisProgress({ current: 0, total: 0, message: '' });
                }
            };

            const handleStartAnalysis = async (config) => {
                console.log('Starting analysis with config:', config);
                console.log('🔄 Setting isRunningAnalysis to TRUE');
                setIsRunningAnalysis(true);
                setIsAnalysisCancelled(false);
                isAnalysisCancelledRef.current = false; // Reset ref for new analysis
                setAnalysisProgress({ current: 0, total: 0, message: 'Initializing analysis...' });
                // Keep panel visible for single alpha (combined view), keep visible for multi-alpha during analysis
                // Note: Multi-alpha analysis should show configuration panel during analysis
                if (config.analysisMode !== 'single' && config.analysisMode !== 'multi') {
                    setShowAnalysisPanel(false);
                }

                // Track total analysis start time for accurate ETA calculations
                const analysisStartTime = Date.now();

                // Small delay to ensure UI renders before starting intensive computation
                await new Promise(resolve => setTimeout(resolve, 100));

                // Auto-scroll to progress indicator for N-alpha and eFDR analysis only
                if (config.analysisMode === 'multi' && (config.analysisType === 'alpha' || config.analysisType === 'efdr')) {
                    setTimeout(() => {
                        if (progressIndicatorRef.current) {
                            progressIndicatorRef.current.scrollIntoView({
                                behavior: 'smooth',
                                block: 'center'
                            });
                        }
                    }, 200); // Give time for UI to render
                }
                
                try {
                    if (config.analysisMode === 'single') {
                        // Single alpha analysis
                        const results = await runSingleAlphaAnalysis(config.alpha);
                        setAnalysisResults(results);
                        console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity, ${results.iterations} iterations`);
                        console.log('🔍 DEBUG - analysisResults properties:', {
                            mode: results.mode,
                            fromAnalysisStep: results.fromAnalysisStep,
                            alpha: results.alpha,
                            detections: results.detections,
                            hasDetectedIndices: !!results.detectedIndices
                        });
                    } else if (config.analysisMode === 'multi') {
                        // Multi-alpha analysis
                        const alphaValues = [];
                        const results = [];

                        // Branch based on analysis type
                        if (config.analysisType === 'efdr') {
                            console.log('Running eFDR analysis with permutation testing...');
                            // Don't set initial total - let worker provide it
                            console.log(`Expected total runs: ${config.Nalpha} × (1 + ${config.Nperm}) = ${config.Nalpha * (1 + config.Nperm)}`);
                        } else {
                            // For pure N-Alpha analysis, run separate alpha sequence

                            // Generate alpha sequence
                            for (let i = 0; i < config.Nalpha; i++) {
                                const alpha = config.alpha0 + (config.alphaMax - config.alpha0) * i / (config.Nalpha - 1);
                                alphaValues.push(alpha);
                            }

                            // Set initial progress for N-Alpha phase only
                            setAnalysisProgress({ current: 0, total: config.Nalpha, message: 'Starting alpha sequence analysis...' });

                            // Track alpha sequence progress separately
                            let alphaSequenceCompleted = 0;

                            // Run SSVD for each alpha
                        for (let i = 0; i < alphaValues.length; i++) {
                            // Check for cancellation using ref for immediate access
                            if (isAnalysisCancelledRef.current) {
                                console.log('🛑 N-Alpha analysis cancelled by user');
                                return;
                            }
                            
                            const alpha = alphaValues[i];
                            console.log(`Running SSVD ${i+1}/${alphaValues.length}: alpha=${alpha.toFixed(4)}`);
                            
                            alphaSequenceCompleted = i + 1;
                            setAnalysisProgress({
                                current: alphaSequenceCompleted,
                                total: config.Nalpha,
                                message: `Alpha ${i + 1}/${alphaValues.length}: α=${alpha.toFixed(4)}`
                            });
                            
                            // Small delay to make progress visible - but only update UI every few iterations
                            if (i === 0 || i === alphaValues.length - 1 || i % 3 === 0) {
                                await new Promise(resolve => setTimeout(resolve, 50));
                            }
                            
                            const result = await SSVDR1Algorithm({
                                matrix: matrix,
                                alpha: alpha,
                                maxIter: 1000,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                tolerance: 0.001
                            });
                            
                            // Calculate detected indices and count
                            const detectedIndices = [];
                            result.u.forEach((val, idx) => {
                                if (Math.abs(val) > 1e-8) {
                                    detectedIndices.push(idx);
                                }
                            });
                            const detections = detectedIndices.length;
                            
                            // Calculate sparsity percentage (percentage of non-zero loadings in u1)
                            const sparsity = (detections / matrix.length * 100).toFixed(1);
                            
                            results.push({
                                index: i,  // Use 0-based indexing for consistency
                                alpha: alpha,
                                detections: detections,
                                detectedIndices: detectedIndices,
                                sparsity: parseFloat(sparsity), // Store as number
                                iterations: result.iterations,
                                converged: result.converged,
                                u: result.u,
                                v: result.v,
                                s: result.s
                            });
                        }

                        // Calculate detection gradients (simple difference, not rate)
                        for (let i = 0; i < results.length; i++) {
                            if (i === 0) {
                                results[i].gradient = 0;
                            } else {
                                results[i].gradient = results[i].detections - results[i-1].detections;
                            }
                        }

                        // Don't set results yet if we're doing eFDR analysis
                        if (config.analysisType === 'alpha') {
                            // Alpha-only analysis - set results immediately
                            setAlphaSequenceResults({
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    matrixSize: `${matrix.length} × ${matrix[0].length}`
                                }
                            });
                        }
                        }

                        // Run eFDR analysis (either standalone or after N-Alpha sequence)
                        if (config.analysisType === 'efdr') {
                            console.log('Running eFDR analysis...');
                            // Start keep-alive system and progress sync for long-running eFDR analysis
                            startKeepAlive();
                            startProgressSync();

                            // Expose setAnalysisProgress globally for background sync
                            window.setProgress = (progress) => setAnalysisProgress(progress);

                            const fdrResults = await runFDRAnalysisEnhanced({
                                matrix: matrix,
                                alpha0: config.alpha0,
                                alphaMax: config.alphaMax,
                                Nalpha: config.Nalpha,
                                Nperm: config.Nperm,
                                nsupp: config.nsupp,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                isCancelled: () => isAnalysisCancelledRef.current,  // Pass cancellation check using ref
                                onProgress: (current, total, message) => {
                                    // Use Web Worker progress directly for eFDR phase
                                    console.log(`eFDR Progress: current=${current}, workerTotal=${total}`);

                                    // Update progress - always update final, throttle intermediate
                                    const shouldUpdate = (current === total) || (current % 2 === 0) || (current === 1);

                                    if (shouldUpdate) {
                                        console.log(`📊 Updating UI progress: ${current}/${total} (${Math.round(current/total * 100)}%)`);
                                        setAnalysisProgress({
                                            current: current,
                                            total: total,
                                            message: `eFDR: ${message}`
                                        });
                                    }
                                    console.log(`FDR Progress: ${current}/${total} - ${message}`);
                                    // Save progress periodically for large analyses
                                    if (current % 5 === 0) {
                                        saveFDRProgress({
                                            current: current,
                                            total: total,
                                            message: `eFDR: ${message}`,
                                            config
                                        });
                                    }
                                }
                            });
                            
                            console.log('FDR Results received:', fdrResults);

                            // Check if analysis was cancelled
                            if (fdrResults.cancelled || isAnalysisCancelledRef.current) {
                                console.log('🛑 eFDR analysis was cancelled - skipping all result processing');
                                return;
                            }

                            console.log('FDR Values:', fdrResults.fdrValues);
                            console.log('FDR Results structure:', Object.keys(fdrResults));

                            // Force progress to 100% immediately when results received
                            const finalTotal = fdrResults.totalRuns || (config.Nalpha * (1 + config.Nperm));
                            console.log(`🎯 Forcing progress to 100%: ${finalTotal}/${finalTotal}`);
                            setAnalysisProgress({
                                current: finalTotal,
                                total: finalTotal,
                                message: 'Analysis complete - preparing results...'
                            });

                            // Wait for progress bar to render at 100%
                            await new Promise(resolve => setTimeout(resolve, 1000));

                            if (!fdrResults.fdrValues) {
                                // Check if cancelled before showing error
                                if (isAnalysisCancelledRef.current) {
                                    console.log('🛑 eFDR analysis was cancelled - no FDR values expected');
                                    return;
                                }
                                console.error('ERROR: fdrResults.fdrValues is undefined!');
                                console.error('Available keys:', Object.keys(fdrResults));
                                alert('eFDR analysis failed: No FDR values returned');
                                return;
                            }

                            // Check if cancelled before processing results
                            if (isAnalysisCancelledRef.current) {
                                console.log('🛑 eFDR analysis was cancelled - skipping results processing');
                                return;
                            }

                            // When running eFDR directly, build results array from FDR results
                            if (results.length === 0 && fdrResults.results) {
                                // Generate alpha values if not already done
                                if (alphaValues.length === 0) {
                                    for (let i = 0; i < config.Nalpha; i++) {
                                        const alpha = config.alpha0 + (config.alphaMax - config.alpha0) * i / (config.Nalpha - 1);
                                        alphaValues.push(alpha);
                                    }
                                }

                                // Build results array from FDR results
                                for (let i = 0; i < fdrResults.results.length; i++) {
                                    const fdrResult = fdrResults.results[i];
                                    results.push({
                                        alpha: fdrResult.alpha,
                                        detectedIndices: [], // Will be populated if needed
                                        detectionCount: fdrResult.detectionCount || 0,
                                        detections: fdrResult.detectionCount || 0,
                                        sparsity: (1 - (fdrResult.detectionCount || 0) / matrix.length) * 100,
                                        gradient: fdrResult.gradient || 0,
                                        eFDR: fdrResults.fdrValues[i] ?? 100,
                                        permutationDetections: fdrResult.permutationDetections || 0
                                    });
                                }
                            } else {
                                // Merge FDR results with existing alpha results
                                for (let i = 0; i < results.length; i++) {
                                    results[i].eFDR = fdrResults.fdrValues[i] ?? 100;  // Default to 100% if undefined
                                    console.log(`Result ${i}: alpha=${results[i].alpha}, eFDR=${results[i].eFDR}`);
                                }
                            }
                            
                            console.log('Updating state with eFDR results...');
                            console.log('Final results array length:', results.length);
                            console.log('Sample result with eFDR:', results[0]);
                            
                            const finalResultsObject = {
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,  // This now includes eFDR values
                                hasFDR: true,
                                fdrResults: fdrResults,
                                Nperm: config.Nperm,  // Add Nperm for display
                                totalRuns: fdrResults.totalRuns,
                                pi0: fdrResults.pi0,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    Nperm: config.Nperm,
                                    nsupp: config.nsupp,
                                    matrixSize: `${matrix.length} × ${matrix[0].length}`
                                }
                            };
                            
                            // Capture elapsed time before clearing progress
                            const progressData = loadFDRProgress();
                            const elapsedTime = progressData?.elapsedTimeFormatted || null;

                            // Add elapsed time to results
                            finalResultsObject.elapsedTime = elapsedTime;

                            console.log('Setting final results object:', finalResultsObject);

                            // Results display already delayed by 1 second above
                            setAlphaSequenceResults(finalResultsObject);
                            console.log('✅ eFDR state update complete');
                        }

                        console.log(`🎉 Alpha sequence complete: ${config.Nalpha} values tested`);
                        clearFDRProgress(true); // Clear saved progress and report final time

                        // Delay clearing progress to allow final 100% to be shown
                        setTimeout(() => {
                            setAnalysisProgress({ current: 0, total: 0, message: '' });
                        }, 1000);
                    }
                } catch (error) {
                    // Only show error if not cancelled AND not a typical cancellation error
                    const isCancellationError = isAnalysisCancelledRef.current ||
                                               error.message?.includes('cancelled') ||
                                               error.message?.includes('undefined') ||
                                               error.message?.includes('Cannot read properties');

                    if (!isCancellationError) {
                        console.error('Analysis error:', error);
                        alert(`Analysis failed: ${error.message}`);
                    } else {
                        console.log('🛑 Analysis was cancelled or interrupted - suppressing error:', error.message);
                    }
                    // Clear progress immediately on error
                    setAnalysisProgress({ current: 0, total: 0, message: '' });
                } finally {
                    console.log('✅ Setting isRunningAnalysis to FALSE');
                    setIsRunningAnalysis(false);
                    setIsAnalysisCancelled(false);
                    // Progress clearing moved to success path with delay
                    stopKeepAlive(); // Stop keep-alive system
                    stopProgressSync(); // Stop progress sync system
                    window.setProgress = null; // Clean up global reference
                    // Force UI refresh to clear any stuck progress indicators
                    setTimeout(() => {
                        setIsRunningAnalysis(false);
                    }, 100);
                }
            };

            const cancelAnalysis = () => {
                console.log('🛑 User requested analysis cancellation');
                setIsAnalysisCancelled(true);
                setAnalysisProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            // Debug logging
            useEffect(() => {
                console.log('App State:', {
                    hasOriginalMatrix: !!originalMatrix,
                    hasOriginalStats: !!originalStatistics,
                    hasOriginalEigenvalues: !!originalEigenvalues,
                    showAnalysisPanel,
                    isRunningAnalysis
                });
            }, [originalMatrix, originalStatistics, originalStatistics, showAnalysisPanel, isRunningAnalysis]);
            
            return (
                <div className="min-h-screen bg-gray-50">
                    {/* VERSION INDICATOR - Always visible */}
                    <div style={{
                        position: 'fixed',
                        top: 0,
                        left: 0,
                        right: 0,
                        backgroundColor: '#f59e0b',
                        color: 'white',
                        padding: '8px',
                        textAlign: 'center',
                        fontWeight: 'bold',
                        zIndex: 9999,
                        fontSize: '14px'
                    }}>
                        🐛 DEBUG BUILD e1e0dad - eFDR for Single-Alpha (Remove after testing)
                    </div>
                    <div style={{height: '40px'}}></div> {/* Spacer for fixed header */}
                    {/* Main Content */}
                    <div className="max-w-7xl mx-auto px-6 py-8">
                        {/* CSV Upload Component */}
                        {!originalMatrix && <CSVUploader onDataLoaded={handleDataLoaded} />}

                        {/* Matrix Data Review - Show only when no analysis results exist */}
                        {originalMatrix && originalStatistics && !showAnalysisPanel && !analysisResults && !alphaSequenceResults && (
                            <MatrixDataReview
                                matrix={originalMatrix}
                                matrixInfo={originalMatrixInfo}
                                statistics={originalStatistics}
                                onProceedToAnalysis={handleProceedToAnalysis}
                                onReset={resetData}
                            />
                        )}
                        
                        
                        {/* N-Alpha Analysis Title (when viewing single-alpha results) */}
                        {analysisResults && analysisResults.mode === 'single' && analysisResults.fromAnalysisStep === 'nalpha' && (
                            <div className="bg-gradient-to-r from-blue-600 to-indigo-700 rounded-lg shadow-lg p-6 text-white mb-6">
                                <div className="flex justify-between items-center">
                                    <div>
                                        <h1 className="text-3xl font-bold mb-2">N-Alpha Analysis (cont.)</h1>
                                        <p className="text-blue-100 text-sm">
                                            Results for selected alpha value from N-alpha table
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}

                        {/* Data Summary Bar */}
                        {matrix && matrixInfo && showAnalysisPanel && statistics && (
                            <DataSummaryBar
                                filename={matrixInfo.filename}
                                statistics={statistics}
                            />
                        )}

                        {/* Analysis Selection Steps */}
                        {matrix && matrixInfo && showAnalysisPanel && !isRunningAnalysis && !analysisResults && !alphaSequenceResults && (
                            <AnalysisSelectionSteps
                                analysisStep={analysisStep}
                                onStepSelect={handleAnalysisStepSelect}
                                onBackToReview={handleBackToDataReview}
                                onReset={resetData}
                            />
                        )}
                        
                        {/* Parameter Configuration for Selected Analysis Type */}
                        {matrix && matrixInfo && showAnalysisPanel && analysisStep === 'single' && (
                            <>
                                <AnalysisConfigurationPanel
                                    matrix={matrix}
                                    matrixInfo={matrixInfo}
                                    analysisStep={analysisStep}
                                    onStartAnalysis={handleStartAnalysis}
                                    onCancel={() => {
                                        setAnalysisStep(null);  // Go back to main Choose Analysis Type page
                                        setAnalysisResults(null);
                                        setAlphaSequenceResults(null);
                                    }}
                                />
                                {/* Show progress when running single-alpha */}
                                {isRunningAnalysis && (
                                    <div className="bg-white rounded-lg shadow-md p-6 mt-6">
                                        <div className="flex flex-col items-center justify-center">
                                            <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                            <p className="text-gray-600">Running SSVD Analysis...</p>
                                        </div>
                                    </div>
                                )}
                                {/* Show results when not running */}
                                {!isRunningAnalysis && analysisResults && analysisResults.mode === 'single' && (
                                    <SSVDResultsDisplay
                                        results={analysisResults}
                                        matrixInfo={matrixInfo}
                                        matrix={matrix}
                                        onBack={analysisResults.fromAnalysisStep === 'efdr' ? () => {
                                            // Back to eFDR results table
                                            console.log('⬅️ Back to eFDR results');
                                            setAnalysisResults(null);
                                        } : undefined}
                                        onNewAnalysis={() => {
                                            setAnalysisResults(null);
                                        }}
                                        onResetToOriginal={resetData}
                                        onRerunWithAlpha={handleRerunWithAlpha}
                                        selectedAlphaeFDR={selectedAlphaeFDR}
                                    />
                                )}
                            </>
                        )}
                        
                        {/* Multi-alpha configuration - keep visible during N-Alpha and eFDR analysis */}
                        {matrix && matrixInfo && showAnalysisPanel && (!isRunningAnalysis || analysisStep === 'efdr' || analysisStep === 'alpha') && !analysisResults && !alphaSequenceResults && (analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <AnalysisConfigurationPanel
                                matrix={matrix}
                                matrixInfo={matrixInfo}
                                analysisStep={analysisStep}
                                isRunningAnalysis={isRunningAnalysis && (analysisStep === 'efdr' || analysisStep === 'alpha')}
                                onStartAnalysis={handleStartAnalysis}
                                onCancel={() => setAnalysisStep('multi')}  // Go back to Multi-Alpha Analysis Type page
                            />
                        )}
                        
                        {/* Analysis Running Indicator - for multi-alpha only */}
                        {isRunningAnalysis && analysisStep !== 'single' && !analysisResults && (
                            <div ref={progressIndicatorRef} className="bg-white rounded-lg shadow-md p-8">
                                <div className="flex flex-col items-center justify-center">
                                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                    <h3 className="text-lg font-semibold text-gray-700 mb-4">
                                        {analysisStep === 'efdr' ? 'Running eFDR Analysis' : 'Running N-Alpha Analysis'}
                                    </h3>
                                    {console.log('🎯 PROGRESS BAR RENDERING:', { isRunningAnalysis, analysisProgress })}
                                    
                                    {/* Enhanced Progress Bar with System Monitoring */}
                                    {analysisProgress.total > 0 && (
                                        <div className="w-full max-w-2xl mb-4">
                                            <div className="flex justify-between text-sm text-gray-600 mb-2">
                                                <span>Progress: {analysisProgress.current}/{analysisProgress.total}</span>
                                                <div className="flex space-x-4">
                                                    <span>{Math.round((analysisProgress.current / analysisProgress.total) * 100)}%</span>
                                                    {(() => {
                                                        const stored = loadFDRProgress();
                                                        return stored ? (
                                                            <div className="flex space-x-3">
                                                                {stored.elapsedTimeFormatted && (
                                                                    <span className="text-green-600">Elapsed: {stored.elapsedTimeFormatted}</span>
                                                                )}
                                                                {stored.estimatedTimeRemaining && (
                                                                    <span className="text-blue-600">ETA: {stored.estimatedTimeRemaining}</span>
                                                                )}
                                                            </div>
                                                        ) : null;
                                                    })()}
                                                </div>
                                            </div>
                                            <div className="w-full bg-gray-200 rounded-full h-3">
                                                <div
                                                    className={`h-3 rounded-full transition-all duration-1000 ease-in-out ${
                                                        analysisStep === 'efdr' ? 'bg-yellow-600' : 'bg-indigo-600'
                                                    }`}
                                                    style={{ width: `${Math.min((analysisProgress.current / analysisProgress.total) * 100, 100)}%` }}
                                                ></div>
                                            </div>

                                            {/* System Resource Monitoring */}
                                            {(() => {
                                                const resources = getSystemResources();
                                                return (
                                                    <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                                        <div className="grid grid-cols-2 gap-4 text-xs">
                                                            <div>
                                                                <div className="font-medium text-blue-700 mb-1">System Resources</div>
                                                                {resources.memory.used && (
                                                                    <div className="flex justify-between text-blue-600">
                                                                        <span>Memory:</span>
                                                                        <span>{resources.memory.used}MB / {resources.memory.limit}MB</span>
                                                                    </div>
                                                                )}
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>CPU Cores:</span>
                                                                    <span>{resources.browser.hardwareConcurrency}</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Browser:</span>
                                                                    <span>{resources.browser.userAgent}</span>
                                                                </div>
                                                            </div>
                                                            <div>
                                                                <div className="font-medium text-blue-700 mb-1">Performance</div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Web Worker:</span>
                                                                    <span className="text-green-600">✓ Active</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Tab Throttling:</span>
                                                                    <span className="text-green-600">✓ Protected</span>
                                                                </div>
                                                                <div className="flex justify-between text-blue-600">
                                                                    <span>Progress Sync:</span>
                                                                    <span className="text-green-600">✓ Background</span>
                                                                </div>
                                                                {(() => {
                                                                    const stored = loadFDRProgress();
                                                                    if (stored && stored.elapsedTimeFormatted) {
                                                                        return (
                                                                            <div className="flex justify-between text-blue-600 border-t border-blue-200 pt-1 mt-1">
                                                                                <span>Runtime:</span>
                                                                                <span className="text-green-600">{stored.elapsedTimeFormatted}</span>
                                                                            </div>
                                                                        );
                                                                    }
                                                                    return null;
                                                                })()}
                                                            </div>
                                                        </div>
                                                        <div className="mt-2 text-xs text-blue-500 text-center">
                                                            💡 Analysis continues at full speed even when tab is in background
                                                        </div>
                                                    </div>
                                                );
                                            })()}
                                        </div>
                                    )}

                                    <div className="w-full max-w-2xl">
                                        <p className="text-sm font-medium text-gray-700 text-center mb-2">
                                            {analysisProgress.message || 'Initializing analysis...'}
                                        </p>
                                        {analysisStep === 'efdr' && analysisProgress.message && analysisProgress.message.includes('Permutation') && (
                                            <p className="text-xs text-gray-500 text-center">
                                                Running permutations to estimate false discovery rate
                                            </p>
                                        )}
                                        {analysisStep === 'efdr' && analysisProgress.message && analysisProgress.message.includes('Original run') && (
                                            <p className="text-xs text-gray-500 text-center">
                                                Computing sparse solution for original matrix
                                            </p>
                                        )}

                                        {/* Cancel Button with Confirmation */}
                                        {(analysisStep === 'efdr' || analysisStep === 'alpha') && (
                                        <div className="flex justify-center mt-4">
                                            <button
                                                onClick={() => {
                                                    const analysisType = analysisStep === 'efdr' ? 'eFDR' : 'N-Alpha';
                                                    console.log(`🛑 User clicked Cancel - stopping ${analysisType} analysis`);
                                                    setIsAnalysisCancelled(true);
                                                    isAnalysisCancelledRef.current = true; // Set ref immediately for N-Alpha loop
                                                    setAnalysisProgress(prev => ({
                                                        ...prev,
                                                        message: 'Cancelling analysis...'
                                                    }));
                                                    // IMMEDIATE termination - don't wait for anything
                                                    console.log('🛑 EMERGENCY STOP - Terminating everything immediately');

                                                    // 1. Kill worker instantly
                                                    if (fdrWorker) {
                                                        fdrWorker.terminate();
                                                        fdrWorker = null;
                                                    }

                                                    // 2. Clear all promises
                                                    workerPromises.clear();

                                                    // 3. Reset UI immediately
                                                    setIsRunningAnalysis(false);
                                                    setIsAnalysisCancelled(false);
                                                    setAnalysisProgress({ current: 0, total: 0, message: '' });

                                                    // 4. Stop all background systems
                                                    try {
                                                        if (typeof stopKeepAlive === 'function') stopKeepAlive();
                                                        if (typeof stopProgressSync === 'function') stopProgressSync();
                                                        if (window.setProgress) window.setProgress = null;
                                                    } catch (e) { /* ignore */ }
                                                }}
                                                className={`px-6 py-2 rounded-md font-medium transition-colors ${
                                                    isAnalysisCancelled
                                                        ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                                                        : 'bg-red-600 text-white hover:bg-red-700'
                                                }`}
                                                disabled={isAnalysisCancelled}
                                            >
                                                {isAnalysisCancelled ? 'Cancelling...' : 'Cancel Analysis'}
                                            </button>
                                        </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Results Table */}
                        {originalMatrix && alphaSequenceResults && (
                            <>
                                {!analysisResults && (
                                <AlphaSequenceResultsDisplay 
                                    results={alphaSequenceResults}
                                    selectedIndex={selectedAlphaIndex}
                                    onSelectAlpha={(index) => {
                                        setSelectedAlphaIndex(index);
                                    }}
                                    onRunSingleAlpha={async (alpha) => {
                                        // Check if we have pre-computed results for this alpha
                                        const preComputed = alphaSequenceResults?.results?.find(r => Math.abs(r.alpha - alpha) < 1e-10);
                                        if (preComputed) {

                                            // Validate that essential properties exist
                                            if (!preComputed.u || !Array.isArray(preComputed.u)) {
                                                console.error('❌ Pre-computed result missing u vector, falling back to fresh analysis');
                                            } else {
                                                const singleResult = {
                                                    mode: 'single',
                                                    fromAnalysisStep: alphaSequenceResults.analysisType === 'efdr' ? 'efdr' : 'nalpha',  // Track source
                                                    alpha: preComputed.alpha,
                                                    eFDR: preComputed.eFDR,  // Include eFDR if available
                                                    u: preComputed.u,
                                                    v: preComputed.v || [],
                                                    s: preComputed.s || 0,
                                                    detections: preComputed.detections || 0,
                                                    detectedIndices: preComputed.detectedIndices || [],
                                                    sparsity: preComputed.sparsity?.toString() || '0',
                                                    iterations: preComputed.iterations || 0,
                                                    converged: preComputed.converged || false,
                                                    parameters: {
                                                        analysisType: 'single',
                                                        alpha: preComputed.alpha,
                                                        matrixSize: `${matrix.length} × ${matrix[0].length}`
                                                    }
                                                };
                                                // Reset eFDR state when new alpha selected
                                                setSelectedAlphaeFDR(null);
                                                seteFDRState('idle');
                                                setAnalysisResults(singleResult);
                                                console.log('✅ Single-alpha results set:', singleResult);
                                                console.log('State check:', {
                                                    eFDRState: 'idle',
                                                    isRunningAnalysis: false,
                                                    mode: singleResult.mode,
                                                    fromAnalysisStep: singleResult.fromAnalysisStep
                                                });
                                                return;
                                            }
                                        }

                                        // Fallback to running analysis if no pre-computed result found
                                        console.log('❌ No pre-computed result found, running SSVD for α =', alpha);
                                        try {
                                            // Reset eFDR state when new alpha selected
                                            setSelectedAlphaeFDR(null);
                                            setIsRunningAnalysis(true);
                                            const singleResults = await runSingleAlphaAnalysis(alpha);
                                            singleResults.fromAnalysisStep = alphaSequenceResults.analysisType === 'efdr' ? 'efdr' : 'nalpha';
                                            // Copy eFDR from pre-computed if available
                                            if (preComputed && preComputed.eFDR !== undefined) {
                                                singleResults.eFDR = preComputed.eFDR;
                                            }
                                            setAnalysisResults(singleResults);
                                            console.log('Single alpha analysis complete:', singleResults);
                                        } catch (error) {
                                            console.error('Single alpha analysis failed:', error);
                                            alert(`Analysis failed: ${error.message}`);
                                        } finally {
                                            setIsRunningAnalysis(false);
                                        }
                                    }}
                                    onNewAnalysis={() => {
                                        // Clear ALL analysis results to go back to parameter selection
                                        setAlphaSequenceResults(null);
                                        setSelectedAlphaIndex(null);
                                        setAnalysisResults(null);
                                        setFDRResults(null);
                                        setSelectedAlpha(null);
                                        setShowAnalysisPanel(true);
                                    }}
                                    onResetToOriginal={resetData}
                                />
                                )}

                                {/* Show progress indicator when running SSVD from N-alpha table (NOT eFDR) */}
                                {isRunningAnalysis && eFDRState !== 'running' && (
                                    <div className="bg-white rounded-lg shadow-md p-6 mt-6">
                                        <div className="flex flex-col items-center justify-center">
                                            <h3 className="text-lg font-semibold text-gray-700 mb-4">
                                                Running SSVD Analysis
                                            </h3>

                                            {/* Progress Bar */}
                                            {analysisProgress?.total > 0 && (
                                                <div className="w-full max-w-2xl mb-4">
                                                    <div className="flex justify-between text-sm text-gray-600 mb-2">
                                                        <span>Progress: {analysisProgress.current}/{analysisProgress.total}</span>
                                                        <span>{Math.round((analysisProgress.current / analysisProgress.total) * 100)}%</span>
                                                    </div>
                                                    <div className="w-full bg-gray-200 rounded-full h-3">
                                                        <div
                                                            className="h-3 rounded-full transition-all duration-500 ease-in-out bg-indigo-600"
                                                            style={{ width: `${Math.min((analysisProgress.current / analysisProgress.total) * 100, 100)}%` }}
                                                        ></div>
                                                    </div>
                                                </div>
                                            )}

                                            <p className="text-sm text-gray-600 text-center">
                                                {analysisProgress?.message || 'Initializing analysis...'}
                                            </p>
                                        </div>
                                    </div>
                                )}
                                
                                {/* Show single-alpha results when selected from N-alpha table */}
                                {analysisResults && analysisResults.mode === 'single' && (
                                    <SSVDResultsDisplay
                                            results={analysisResults}
                                            matrixInfo={matrixInfo}
                                            matrix={matrix}
                                            onBack={() => {
                                            // Back to N-alpha table - clear single-alpha state only
                                            console.log('⬅️ Back to N-alpha results table');
                                            setAnalysisResults(null);
                                            setSelectedAlphaeFDR(null);
                                            seteFDRState('idle');
                                            setSelectedAlphaIndex(null);
                                            // Keep alphaSequenceResults so table shows!
                                        }}
                                        onResetToOriginal={resetData}
                                        onRerunWithAlpha={handleRerunWithAlpha}
                                        selectedAlphaeFDR={selectedAlphaeFDR}
                                    />
                                )}

                                {/* eFDR Section - Inline Design with State Machine */}
                                {/* DEBUG PANEL - VISIBLE ON SCREEN */}
                                {analysisResults && (
                                    <div className="bg-yellow-100 border-2 border-yellow-500 rounded-lg p-4 mb-6">
                                        <h3 className="text-lg font-bold text-yellow-900 mb-2">🐛 DEBUG INFO (Remove after testing)</h3>
                                        <div className="text-sm text-yellow-900 space-y-1 font-mono">
                                            <div>mode: <strong>{analysisResults.mode || 'undefined'}</strong></div>
                                            <div>fromAnalysisStep: <strong>{analysisResults.fromAnalysisStep || 'undefined'}</strong></div>
                                            <div>alpha: <strong>{analysisResults.alpha || 'undefined'}</strong></div>
                                            <div>detections: <strong>{analysisResults.detections || analysisResults.detectedIndices?.length || 0}</strong></div>
                                            <div>shouldShoweFDR: <strong>{String(analysisResults.mode === 'single' && (analysisResults.fromAnalysisStep === 'nalpha' || analysisResults.fromAnalysisStep === 'single'))}</strong></div>
                                        </div>
                                    </div>
                                )}
                                {analysisResults && analysisResults.mode === 'single' && (analysisResults.fromAnalysisStep === 'nalpha' || analysisResults.fromAnalysisStep === 'single') && (
                                    <div className="bg-white rounded-lg shadow-md p-8 mb-6" data-efdr-section>
                                        <h2 className="text-2xl font-bold text-gray-800 mb-3">
                                            📊 Compute eFDR for Selected Alpha
                                        </h2>
                                        <p className="text-gray-600 mb-6">
                                            Calculate empirical False Discovery Rate for α = {analysisResults.alpha.toFixed(6)} using permutation testing.
                                        </p>

                                        {/* State: idle - Show parameter inputs */}
                                        {eFDRState === 'idle' && (
                                            <div className="space-y-6">
                                                {/* Info panel showing actual detections that will be used */}
                                                <div className="bg-blue-50 border border-blue-200 p-4 rounded-lg">
                                                    <h4 className="text-sm font-semibold text-blue-800 mb-2">Analysis Configuration</h4>
                                                    <div className="space-y-2 text-sm text-blue-700">
                                                        <p>
                                                            <strong>Alpha (α):</strong> {analysisResults.alpha.toFixed(6)}
                                                        </p>
                                                        <p>
                                                            <strong>Actual Detections:</strong> {analysisResults.nonZeroIndices?.length || analysisResults.detectedIndices?.length || 0} features
                                                        </p>
                                                        <p className="text-xs mt-2 italic">
                                                            eFDR will be calculated using the actual number of detections at this alpha value.
                                                        </p>
                                                    </div>
                                                </div>

                                                {/* Nperm input */}
                                                <div>
                                                    <label className="block text-sm font-medium text-gray-700 mb-2">
                                                        Number of Permutations (Nperm)
                                                    </label>
                                                    <input
                                                        type="number"
                                                        min="10"
                                                        max="1000"
                                                        step="1"
                                                        value={eFDRParameters.Nperm ?? 25}
                                                        onChange={(e) => {
                                                            const val = e.target.value;
                                                            seteFDRParameters({...eFDRParameters, Nperm: val === '' ? '' : parseInt(val)});
                                                        }}
                                                        className="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500"
                                                    />
                                                    <p className="text-xs text-gray-500 mt-1">
                                                        More permutations provide better estimates but take longer (default: 25)
                                                    </p>
                                                </div>

                                                {/* Calculate button */}
                                                <div className="pt-4 flex justify-center">
                                                    <button
                                                        onClick={() => {
                                                            const nsupp = analysisResults.nonZeroIndices?.length || analysisResults.detectedIndices?.length || 0;
                                                            handleRunSingleAlphaeFDR(nsupp);
                                                        }}
                                                        disabled={false}
                                                        className="w-1/2 px-6 py-3 font-semibold rounded-lg transition-all duration-200 shadow-md bg-gradient-to-r from-purple-500 to-indigo-600 text-white hover:from-purple-600 hover:to-indigo-700"
                                                    >
                                                        Calculate eFDR
                                                    </button>
                                                </div>
                                            </div>
                                        )}

                                        {/* State: running - Show progress */}
                                        {eFDRState === 'running' && (
                                            <div className="space-y-4" data-efdr-progress>
                                                {/* Parameter Summary */}
                                                <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
                                                    <h4 className="text-sm font-semibold text-purple-800 mb-2">Analysis Parameters</h4>
                                                    <div className="grid grid-cols-2 gap-3 text-sm">
                                                        <div>
                                                            <span className="text-purple-600 font-medium">Alpha (α):</span>
                                                            <span className="text-gray-700 ml-2">{analysisResults.alpha?.toFixed(6)}</span>
                                                        </div>
                                                        <div>
                                                            <span className="text-purple-600 font-medium">Actual Detections:</span>
                                                            <span className="text-gray-700 ml-2">{analysisResults.nonZeroIndices?.length || analysisResults.detectedIndices?.length || 0}</span>
                                                        </div>
                                                        <div>
                                                            <span className="text-purple-600 font-medium">Permutations:</span>
                                                            <span className="text-gray-700 ml-2">{eFDRParameters.Nperm || 25}</span>
                                                        </div>
                                                    </div>
                                                </div>

                                                {/* Progress Bar */}
                                                {analysisProgress?.total > 0 && (
                                                    <div className="w-full">
                                                        <div className="flex justify-between text-sm text-gray-600 mb-2">
                                                            <span>{analysisProgress.message || 'Processing...'}</span>
                                                            <span>{Math.round((analysisProgress.current / analysisProgress.total) * 100)}%</span>
                                                        </div>
                                                        <div className="w-full bg-gray-200 rounded-full h-3">
                                                            <div
                                                                className="h-3 rounded-full transition-all duration-500 ease-in-out bg-purple-600"
                                                                style={{ width: `${Math.min((analysisProgress.current / analysisProgress.total) * 100, 100)}%` }}
                                                            ></div>
                                                        </div>
                                                    </div>
                                                )}

                                                {/* Cancel button */}
                                                <div className="flex justify-center">
                                                    <button
                                                        onClick={() => {
                                                            console.log('🛑 User clicked Cancel - stopping eFDR calculation');
                                                            setIsAnalysisCancelled(true);
                                                            isAnalysisCancelledRef.current = true; // Set ref immediately for async callbacks
                                                            setIsRunningAnalysis(false);
                                                            seteFDRState('idle');
                                                            setAnalysisProgress({ current: 0, total: 0, message: '' });
                                                        }}
                                                        className="px-6 py-2 bg-red-500 text-white font-semibold rounded-lg hover:bg-red-600 transition-all duration-200 shadow-md"
                                                    >
                                                        Cancel Analysis
                                                    </button>
                                                </div>
                                            </div>
                                        )}

                                        {/* State: complete - Show results */}
                                        {eFDRState === 'complete' && selectedAlphaeFDR && (
                                            <div data-efdr-results>
                                        <h3 className="text-lg font-semibold text-gray-800 mb-4">
                                            ✅ eFDR Results for α = {analysisResults.alpha.toFixed(6)}
                                        </h3>

                                        <div className="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                            {/* eFDR value card */}
                                            <div className={`p-4 rounded-lg ${
                                                selectedAlphaeFDR.eFDR <= 0.05 ? 'bg-green-50' :
                                                selectedAlphaeFDR.eFDR <= 0.10 ? 'bg-yellow-50' :
                                                'bg-red-50'
                                            }`}>
                                                <div className={`text-sm font-medium mb-1 ${
                                                    selectedAlphaeFDR.eFDR <= 0.05 ? 'text-green-600' :
                                                    selectedAlphaeFDR.eFDR <= 0.10 ? 'text-yellow-600' :
                                                    'text-red-600'
                                                }`}>
                                                    Empirical FDR (eFDR)
                                                </div>
                                                <div className={`text-3xl font-bold ${
                                                    selectedAlphaeFDR.eFDR <= 0.05 ? 'text-green-900' :
                                                    selectedAlphaeFDR.eFDR <= 0.10 ? 'text-yellow-900' :
                                                    'text-red-900'
                                                }`}>
                                                    {(selectedAlphaeFDR.eFDR * 100).toFixed(2)}%
                                                </div>
                                                <div className={`text-xs mt-1 ${
                                                    selectedAlphaeFDR.eFDR <= 0.05 ? 'text-green-600' :
                                                    selectedAlphaeFDR.eFDR <= 0.10 ? 'text-yellow-600' :
                                                    'text-red-600'
                                                }`}>
                                                    {selectedAlphaeFDR.eFDR <= 0.05 ? '✓ Excellent (≤5%)' :
                                                     selectedAlphaeFDR.eFDR <= 0.10 ? '⚠ Acceptable (≤10%)' :
                                                     '⚠ High (>10%)'}
                                                </div>
                                            </div>

                                            {/* Detection count card */}
                                            <div className="bg-blue-50 p-4 rounded-lg">
                                                <div className="text-sm text-blue-600 font-medium mb-1">
                                                    Detections at This Alpha
                                                </div>
                                                <div className="text-3xl font-bold text-blue-900">
                                                    {selectedAlphaeFDR.originalDetections}
                                                </div>
                                                <div className="text-xs text-blue-600 mt-1">
                                                    out of {matrixInfo.P} total features
                                                </div>
                                            </div>
                                        </div>

                                        {/* Parameter summary */}
                                        <div className="bg-gray-50 p-4 rounded-lg space-y-2">
                                            <h4 className="text-sm font-semibold text-gray-700 mb-2">Analysis Parameters</h4>
                                            <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                                                <div>
                                                    <span className="text-gray-600">π₀:</span>
                                                    <span className="font-semibold text-gray-900 ml-1">
                                                        {selectedAlphaeFDR.pi0.toFixed(4)}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-600">nsupp:</span>
                                                    <span className="font-semibold text-gray-900 ml-1">
                                                        {selectedAlphaeFDR.nsupp}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-600">Nperm:</span>
                                                    <span className="font-semibold text-gray-900 ml-1">
                                                        {selectedAlphaeFDR.Nperm}
                                                    </span>
                                                </div>
                                                <div>
                                                    <span className="text-gray-600">Alpha:</span>
                                                    <span className="font-semibold text-gray-900 ml-1">
                                                        {selectedAlphaeFDR.alpha.toFixed(6)}
                                                    </span>
                                                </div>
                                            </div>
                                        </div>

                                        {/* Interpretation guide */}
                                        <div className="mt-4 p-3 bg-blue-50 rounded-lg border border-blue-200">
                                            <p className="text-sm text-blue-800">
                                                <strong>Interpretation:</strong> An eFDR of {(selectedAlphaeFDR.eFDR * 100).toFixed(2)}%
                                                means approximately {(selectedAlphaeFDR.eFDR * selectedAlphaeFDR.originalDetections).toFixed(1)}{' '}
                                                of the {selectedAlphaeFDR.originalDetections} detected features are expected to be false discoveries.
                                            </p>
                                        </div>

                                        {/* Recalculate button */}
                                        <div className="mt-4 pt-4 border-t border-gray-200">
                                            <button
                                                onClick={() => {
                                                    setSelectedAlphaeFDR(null);
                                                    seteFDRState('idle'); // State machine transition: complete → idle
                                                }}
                                                className="px-4 py-2 text-sm bg-gray-100 text-gray-700 font-medium rounded-lg hover:bg-gray-200 transition-all duration-200"
                                            >
                                                Recalculate with Different Parameters
                                            </button>
                                        </div>
                                    </div>
                                        )}
                                    </div>
                                )}
                            </>
                        )}

                        {/* Old Matrix Information (temporary during transition) */}
                        {matrixInfo && !statistics && (
                            <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Matrix Information</h2>
                                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">{matrixInfo.P} × {matrixInfo.N}</div>
                                        <div className="text-xs text-blue-600 mt-1">
                                            {matrixInfo.rowHeaders ? `${matrixInfo.P} features` : `P=${matrixInfo.P}`} × {matrixInfo.columnHeaders ? `${matrixInfo.N} samples` : `N=${matrixInfo.N}`}
                                        </div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">File</div>
                                        <div className="text-lg font-bold text-purple-900 truncate">{matrixInfo.filename}</div>
                                        <div className="text-xs text-purple-600 mt-1">{(matrixInfo.fileSize / 1024).toFixed(1)} KB</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Format</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Gene Expression' : 
                                             matrixInfo.hasHeaders ? 'With Headers' : 'Pure Numeric'}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Row & column headers' :
                                             matrixInfo.rowHeaders ? 'Row headers detected' :
                                             matrixInfo.columnHeaders ? 'Column headers detected' :
                                             'No headers detected'}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Show sample headers if available */}
                                {(matrixInfo.rowHeaders || matrixInfo.columnHeaders) && (
                                    <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                                        <div className="text-sm text-gray-600">
                                            {matrixInfo.rowHeaders && (
                                                <div className="mb-2">
                                                    <span className="font-medium">Sample features: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.rowHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.rowHeaders.length > 5 && ` ... (${matrixInfo.rowHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                            {matrixInfo.columnHeaders && (
                                                <div>
                                                    <span className="font-medium">Sample names: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.columnHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.columnHeaders.length > 5 && ` ... (${matrixInfo.columnHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* FDR Analysis Panel - Only shown when user proceeds to analysis */}
                        {/* This will be implemented in Phase 4 */}

                        {/* Phase 3: FDR Results Display */}
                        {originalMatrix && fdrResults && <FDRResultsDisplay 
                            results={fdrResults} 
                            onAlphaSelected={setSelectedAlpha} 
                            selectedAlpha={selectedAlpha}
                            onRunSingleAlpha={async (alpha) => {
                                // Check if we have pre-computed results for this alpha from eFDR
                                const preComputed = alphaSequenceResults?.results?.find(r => Math.abs(r.alpha - alpha) < 1e-10);
                                if (preComputed) {

                                    // Validate that essential properties exist
                                    if (!preComputed.u || !Array.isArray(preComputed.u)) {
                                        console.error('❌ Pre-computed result missing u vector, falling back to fresh analysis');
                                    } else {
                                        const singleResult = {
                                            mode: 'single',
                                            alpha: preComputed.alpha,
                                            eFDR: preComputed.eFDR,  // Include eFDR if available
                                            u: preComputed.u,
                                            v: preComputed.v || [],
                                            s: preComputed.s || 0,
                                            detections: preComputed.detections || 0,
                                            detectedIndices: preComputed.detectedIndices || [],
                                            sparsity: preComputed.sparsity?.toString() || '0',
                                            iterations: preComputed.iterations || 0,
                                            converged: preComputed.converged || false,
                                            fromAnalysisStep: 'efdr',  // Track it's from eFDR analysis
                                            parameters: {
                                                analysisType: 'single',
                                                alpha: preComputed.alpha,
                                                matrixSize: `${matrix.length} × ${matrix[0].length}`
                                            }
                                        };
                                        setAnalysisResults(singleResult);
                                        return;
                                    }
                                }

                                // Fallback to running analysis if no pre-computed result found
                                console.log('❌ No pre-computed result found, running SSVD for α =', alpha);
                                try {
                                    setIsRunningAnalysis(true);
                                    const singleResults = await runSingleAlphaAnalysis(alpha);
                                    singleResults.fromAnalysisStep = 'efdr';  // Track it's from eFDR analysis
                                    setAnalysisResults(singleResults);
                                    console.log('✅ SSVD analysis complete:', singleResults);
                                } catch (error) {
                                    console.error('❌ SSVD analysis failed:', error);
                                    alert(`Analysis failed: ${error.message}`);
                                } finally {
                                    setIsRunningAnalysis(false);
                                }
                            }}
                        />}
                    </div>
                </div>
            );
        };

        // Render the application
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>