<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net; img-src 'self' data: blob:; script-src 'self' 'unsafe-inline' 'unsafe-eval' https://unpkg.com https://cdnjs.cloudflare.com https://cdn.tailwindcss.com https://cdn.jsdelivr.net;">
    <title>SSVD1x - CSV Matrix Analysis - v2.0 Fixed SVD</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
        }
        .chart-container {
            background: linear-gradient(90deg, #f8fafc 0%, #f1f5f9 100%);
        }
    </style>
</head>

<body class="min-h-screen bg-gray-50">
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useMemo, useEffect, useRef, createContext, useContext } = React;

        // ===================================================================
        // CORE ALGORITHMS COPIED FROM SSVD1 (PHASE 1)
        // ===================================================================

        // -------------------------------------------------------------------
        // 1. CORE MATRIX OPERATIONS
        // -------------------------------------------------------------------

        const matrixMultiply = function matrixMultiply(A, B) {
            if (!A.length || !B.length || A[0].length !== B.length) {
                throw new Error('Invalid matrix dimensions for multiplication');
            }
            const result = Array(A.length).fill().map(() => Array(B[0].length).fill(0));
            for (let i = 0; i < A.length; i++) {
                for (let j = 0; j < B[0].length; j++) {
                    for (let k = 0; k < B.length; k++) {
                        result[i][j] += A[i][k] * B[k][j];
                    }
                }
            }
            return result;
        };

        const transpose = function transpose(matrix) {
            if (!matrix.length || !matrix[0].length) return [];
            return matrix[0].map((_, i) => matrix.map(row => row[i]));
        };

        const norm = function norm(vector) {
            return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
        };

        // -------------------------------------------------------------------
        // 2. STATISTICAL UTILITIES
        // -------------------------------------------------------------------

        const generateGaussianNoise = function generateGaussianNoise(variance) {
            const u1 = Math.random(), u2 = Math.random();
            const z0 = Math.sqrt(-2.0 * Math.log(u1)) * Math.cos(2.0 * Math.PI * u2);
            return z0 * Math.sqrt(variance);
        };

        const calculateMean = function calculateMean(array) {
            return array.reduce((sum, val) => sum + val, 0) / array.length;
        };

        const calculateVariance = function calculateVariance(array, mean = null) {
            const m = mean !== null ? mean : calculateMean(array);
            return array.reduce((sum, val) => sum + Math.pow(val - m, 2), 0) / array.length;
        };

        // -------------------------------------------------------------------
        // 3. MATRIX ROW PERMUTATION
        // -------------------------------------------------------------------

        const permuteMatrixRows = function permuteMatrixRows(matrix, fixedPattern = null) {
            if (fixedPattern) {
                // Use provided permutation pattern
                return fixedPattern.map(idx => matrix[idx]);
            }
            // Original random permutation of columns within each row
            const permuted = matrix.map(row => [...row]);
            for (let i = 0; i < permuted.length; i++) {
                for (let j = permuted[i].length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [permuted[i][j], permuted[i][k]] = [permuted[i][k], permuted[i][j]];
                }
            }
            return permuted;
        };

        // -------------------------------------------------------------------
        // 4. SOFT THRESHOLDING
        // -------------------------------------------------------------------

        const softThreshold = function softThreshold(x, alpha) {
            return Math.sign(x) * Math.max(Math.abs(x) - alpha, 0);
        };

        const calculateSparsity = function calculateSparsity(vector) {
            const nonZeros = vector.filter(x => Math.abs(x) > 1e-10).length;
            return vector.length > 0 ? (vector.length - nonZeros) / vector.length : 0;
        };

        // -------------------------------------------------------------------
        // 5. SVD IMPLEMENTATION (POWER ITERATION)
        // -------------------------------------------------------------------
        
        // SVD_v2.1_VALIDATED: Power iteration implementation with convergence criteria
        const simpleSVD = function simpleSVD(X) {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            const P = X.length;
            const N = X[0].length;

            // Use power iteration to find dominant singular vectors
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = norm(v);
            v = v.map(x => x / vNorm);
            let u = Array(P).fill(0);
            let prevSingularValue = 0;

            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 50; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += X[i][j] * v[j];
                    }
                }

                // Normalize u and get singular value
                const uNormValue = norm(u);
                if (uNormValue === 0) break;
                u = u.map(x => x / uNormValue);

                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += X[i][j] * u[i];
                    }
                }

                // Normalize v and get singular value
                vNorm = norm(v);
                if (vNorm === 0) break;
                v = v.map(x => x / vNorm);

                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-8) {
                    break;
                }
                prevSingularValue = vNorm;
            }

            // Final singular value computation
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * X[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };

        const svd1Sync = simpleSVD;
        const svd1 = async function(X) {
            await new Promise(resolve => setTimeout(resolve, 0));
            return simpleSVD(X);
        };
        
        // COMPUTE_ALL_SV_v2.0_NUMERICALLY_STABLE: Direct SVD decomposition for all singular values
        const computeAllSingularValues = (X) => {
            if (!X.length || !X[0].length) {
                throw new Error('Empty matrix provided to SVD');
            }
            
            const P = X.length;
            const N = X[0].length;
            const numSingularValues = Math.min(P, N);
            
            console.log('Computing all singular values via direct SVD decomposition...');
            console.log(`Matrix dimensions: ${P} x ${N}, computing ${numSingularValues} singular values`);
            
            const singularValues = [];
            
            // Create working copy of matrix
            let workingMatrix = X.map(row => [...row]);
            
            // Use deflation to extract all singular values one by one
            for (let k = 0; k < numSingularValues; k++) {
                // Use power iteration to find dominant singular value
                const svdResult = performSingleSVD(workingMatrix);
                
                if (svdResult.s < 1e-12) {
                    console.log(`Singular value ${k+1} is effectively zero (${svdResult.s.toExponential(3)}), stopping deflation`);
                    // Fill remaining with zeros
                    for (let j = k; j < numSingularValues; j++) {
                        singularValues.push(0);
                    }
                    break;
                }
                
                singularValues.push(svdResult.s);
                
                // Deflate: subtract rank-1 approximation σ * u * v^T
                if (k < numSingularValues - 1) {
                    const currentP = workingMatrix.length;
                    const currentN = workingMatrix[0].length;
                    
                    for (let i = 0; i < currentP; i++) {
                        for (let j = 0; j < currentN; j++) {
                            workingMatrix[i][j] -= svdResult.s * svdResult.u[i] * svdResult.v[j];
                        }
                    }
                }
                
                if (k % 10 === 0 || k < 5) {
                    console.log(`Singular value ${k+1}: ${svdResult.s.toFixed(6)}`);
                }
            }
            
            // Sort in descending order
            singularValues.sort((a, b) => b - a);
            
            console.log(`Computed ${singularValues.length} singular values`);
            console.log('Largest 10 singular values:', singularValues.slice(0, 10).map(s => s.toFixed(6)));
            console.log('Singular value range:', singularValues[0]?.toFixed(6), 'to', singularValues[singularValues.length-1]?.toFixed(6));
            
            return singularValues;
        };
        
        // Perform single SVD to get dominant singular triplet (u, σ, v)
        const performSingleSVD = (matrix) => {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Initialize random right singular vector
            let v = Array(N).fill(0).map(() => Math.random() - 0.5);
            let vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
            v = v.map(x => x / vNorm);
            
            let u = Array(P).fill(0);
            let prevSingularValue = 0;
            
            // Power iteration: alternately compute u = X*v and v = X^T*u
            for (let iter = 0; iter < 100; iter++) {
                // u = X * v
                for (let i = 0; i < P; i++) {
                    u[i] = 0;
                    for (let j = 0; j < N; j++) {
                        u[i] += matrix[i][j] * v[j];
                    }
                }
                
                // Normalize u and get singular value estimate
                const uNorm = Math.sqrt(u.reduce((sum, x) => sum + x * x, 0));
                if (uNorm < 1e-15) break;
                u = u.map(x => x / uNorm);
                
                // v = X^T * u  
                for (let j = 0; j < N; j++) {
                    v[j] = 0;
                    for (let i = 0; i < P; i++) {
                        v[j] += matrix[i][j] * u[i];
                    }
                }
                
                // Normalize v and get singular value
                vNorm = Math.sqrt(v.reduce((sum, x) => sum + x * x, 0));
                if (vNorm < 1e-15) break;
                v = v.map(x => x / vNorm);
                
                // Check convergence
                if (Math.abs(vNorm - prevSingularValue) < 1e-10) {
                    break;
                }
                prevSingularValue = vNorm;
            }
            
            // Final singular value computation: σ = u^T * X * v
            let s = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    s += u[i] * matrix[i][j] * v[j];
                }
            }
            s = Math.abs(s);
            
            return { u, s, v };
        };
        
        // Improved eigenvalue computation using iterative methods for symmetric matrices
        const computeEigenvalues = (A) => {
            const n = A.length;
            console.log('Computing eigenvalues using improved method for', n, 'x', n, 'matrix');
            
            const trace = A.reduce((sum, row, i) => sum + row[i], 0);
            console.log('Matrix trace:', trace.toFixed(2));
            
            // Use deflation method with power iteration for better accuracy
            const eigenvalues = [];
            let workingMatrix = A.map(row => [...row]);
            
            for (let k = 0; k < n; k++) {
                const eigenvalue = powerIterationEigenvalue(workingMatrix);
                
                if (eigenvalue < 1e-10) {
                    // Fill remaining with small positive values
                    const remaining = n - eigenvalues.length;
                    for (let i = 0; i < remaining; i++) {
                        eigenvalues.push(Math.max(1e-12, eigenvalue * Math.random()));
                    }
                    break;
                }
                
                eigenvalues.push(eigenvalue);
                
                // Deflate matrix by removing the contribution of this eigenvalue
                // Find corresponding eigenvector and deflate
                const eigenvector = powerIterationEigenvector(workingMatrix);
                
                // Deflate: A := A - λ * v * v^T
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        workingMatrix[i][j] -= eigenvalue * eigenvector[i] * eigenvector[j];
                    }
                }
                
                if (k % 10 === 0) {
                    console.log(`Computed eigenvalue ${k+1}: ${eigenvalue.toFixed(2)}`);
                }
            }
            
            console.log('Computed', eigenvalues.length, 'eigenvalues, largest =', eigenvalues[0]?.toFixed(2));
            console.log('Eigenvalue range:', Math.min(...eigenvalues).toFixed(2), 'to', Math.max(...eigenvalues).toFixed(2));
            
            return eigenvalues.sort((a, b) => b - a);
        };
        
        // Power iteration for largest eigenvalue of symmetric matrix
        const powerIterationEigenvalue = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            let lambda = 0;
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Compute eigenvalue estimate v^T * A * v
                const newLambda = v.reduce((sum, vi, i) => sum + vi * Av[i], 0);
                
                // Check convergence
                if (Math.abs(newLambda - lambda) < 1e-12) {
                    lambda = newLambda;
                    break;
                }
                lambda = newLambda;
                
                // Update v for next iteration
                v = Av;
            }
            
            return lambda;
        };
        
        // Power iteration for eigenvector corresponding to largest eigenvalue
        const powerIterationEigenvector = (A) => {
            const n = A.length;
            let v = Array(n).fill(0).map(() => Math.random() - 0.5);
            
            for (let iter = 0; iter < 100; iter++) {
                // Normalize v
                const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
                if (norm < 1e-15) break;
                v = v.map(x => x / norm);
                
                // Compute A * v
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += A[i][j] * v[j];
                    }
                }
                
                // Update v for next iteration
                v = Av;
            }
            
            // Final normalization
            const norm = Math.sqrt(v.reduce((sum, x) => sum + x*x, 0));
            if (norm > 1e-15) {
                v = v.map(x => x / norm);
            }
            
            return v;
        };
        
        // Wrapper function to compute eigenvalues (σ²) from singular values (σ) 
        const fullSVD = (matrix) => {
            // Step 1: Compute all singular values via direct SVD
            const singularValues = computeAllSingularValues(matrix);
            
            // Step 2: Square them to get eigenvalues (σ²)
            const eigenvalues = singularValues.map(sigma => sigma * sigma);
            
            console.log('Converted singular values to eigenvalues:');
            console.log('Singular values (σ):', singularValues.slice(0, 5).map(s => s.toFixed(2)));
            console.log('Eigenvalues (σ²):', eigenvalues.slice(0, 5).map(e => e.toFixed(2)));
            
            return eigenvalues;
        };

        // -------------------------------------------------------------------
        // 6. CALCULATE ALPHA MAX
        // -------------------------------------------------------------------
        
        // ALPHAMAX_v1.2_VALIDATED: Sparsity parameter upper bound calculation
        const calculateAlphaMax = function(matrix, alphaMaxMultiplier = 0.75) {
            if (!matrix || !matrix.length) {
                return 1.0;
            }
            
            try {
                const { u, s } = svd1Sync(matrix);
                const maxAbsU1 = Math.max(...u.map(val => Math.abs(val)));
                const result = alphaMaxMultiplier * maxAbsU1 * s;
                return result;
            } catch (error) {
                console.error('AlphaMax calculation failed:', error);
                return 1.0;
            }
        };

        // -------------------------------------------------------------------
        // 7. SSVD-R1 ALGORITHM
        // -------------------------------------------------------------------
        
        // SSVD-R1_v1.3_VALIDATED: Sparse SVD with I/O specifications
        const SSVDR1Algorithm = async function({ matrix, alpha, maxIter = 5000, tolerance = 0.0001, onProgress = null, initialSVD = null }) {
            if (!matrix || !matrix.length || !matrix[0].length) {
                throw new Error('Invalid matrix provided');
            }

            if (Math.abs(alpha) < 1e-10) {
                console.log(`Alpha ${alpha} treated as 0, returning simple approximation`);
                
                const P = matrix.length;
                const N = matrix[0].length;
                let u = matrix.map(row => row[0] || 0);
                let uNorm = norm(u);
                if (uNorm > 0) {
                    u = u.map(x => x / uNorm);
                } else {
                    u = Array(P).fill(0);
                    u[0] = 1; // fallback
                }

                const v = Array(N).fill(1 / Math.sqrt(N));
                const s = Math.abs(u.reduce((sum, uVal, i) => 
                    sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0));
                const nonZeros = u.filter(val => Math.abs(val) > 1e-10).length;
                const sparsity = (P - nonZeros) / P;
                
                return {
                    u, s, v,
                    iterations: 0,
                    converged: true,
                    errors: [0],
                    sparsityHistory: [sparsity],
                    singularValues: [s]
                };
            }

            // Use cached SVD if provided, otherwise calculate it
            const svdResult = initialSVD || await svd1(matrix);
            const { u: u0, s: s0, v: v0 } = svdResult;
            let u = [...u0];
            let v = [...v0];
            let uPrev = [...u0];
            let aPrev = matrixMultiply(u0.map(x => [x * s0]), [v0]);
            
            let iterCount = 0;
            let error = 1;
            const errors = [];
            const sparsityHistory = [];
            const singularValues = [];
            const adaptiveTolerance = alpha < 0.01 ? Math.max(tolerance, alpha * 0.1) : tolerance;

            while (error > adaptiveTolerance && iterCount < maxIter) {
                iterCount++;
                
                const XT = transpose(matrix);
                v = XT.map(row => row.reduce((sum, val, idx) => sum + val * u[idx], 0));
                let vNorm = norm(v);
                if (vNorm > 0) {
                    v = v.map(x => x / vNorm);
                }

                u = matrix.map(row => row.reduce((sum, val, idx) => sum + val * v[idx], 0));
                u = u.map(x => Math.sign(x) * Math.max(Math.abs(x) - alpha, 0));
                let uNorm = norm(u);
                if (uNorm > 0) {
                    u = u.map(x => x / uNorm);
                }

                const sval = u.reduce((sum, uVal, i) => 
                    sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0);
                const nonZeros = u.filter(val => Math.abs(val) > 1e-10).length;
                const sparsity = (u.length - nonZeros) / u.length;
                sparsityHistory.push(sparsity);
                singularValues.push(Math.abs(sval));

                const a = matrixMultiply(u.map(x => [x * Math.abs(sval)]), [v]);
                error = 0;
                for (let i = 0; i < a.length; i++) {
                    for (let j = 0; j < a[0].length; j++) {
                        const diff = a[i][j] - aPrev[i][j];
                        error += diff * diff;
                    }
                }
                error = Math.sqrt(error);
                errors.push(error);

                if (isNaN(error) || !isFinite(error)) {
                    console.warn('Numerical instability detected');
                    break;
                }

                if (alpha < 0.05 && iterCount > 100 && error < adaptiveTolerance * 2) {
                    console.log(`Early convergence for small alpha ${alpha} at iteration ${iterCount}`);
                    break;
                }

                uPrev = [...u];
                aPrev = a.map(row => [...row]);

                // Yield control back to browser every 50 iterations
                if (iterCount % 50 === 0) {
                    if (onProgress) {
                        onProgress(iterCount, maxIter, error);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }

            const finalS = Math.abs(u.reduce((sum, uVal, i) => 
                sum + uVal * matrix[i].reduce((s2, xVal, j) => s2 + xVal * v[j], 0), 0));

            return {
                u, s: finalS, v,
                iterations: iterCount,
                converged: error <= adaptiveTolerance,
                errors,
                sparsityHistory,
                singularValues
            };
        };

        // -------------------------------------------------------------------
        // 8. FDR ANALYSIS
        // -------------------------------------------------------------------
        
        // Fixed permutation pattern generation for reproducible testing
        const generateFixedPermutations = function(Nperm, matrixRows) {
            const patterns = [];
            for (let i = 0; i < Nperm; i++) {
                const indices = Array.from({length: matrixRows}, (_, i) => i);
                // Fisher-Yates shuffle with fixed sequence
                for (let j = indices.length - 1; j > 0; j--) {
                    const k = Math.floor(Math.random() * (j + 1));
                    [indices[j], indices[k]] = [indices[k], indices[j]];
                }
                patterns.push(indices);
            }
            return patterns;
        };
        
        // Store/retrieve patterns for A/B testing
        const savePermutationPatterns = function(patterns) {
            localStorage.setItem('ssvd1x_fixed_permutations', JSON.stringify(patterns));
        };
        
        const loadPermutationPatterns = function() {
            const stored = localStorage.getItem('ssvd1x_fixed_permutations');
            return stored ? JSON.parse(stored) : null;
        };
        
        // FDR_ANALYSIS_v2.0_VALIDATED: Empirical False Discovery Rate with permutation testing
        const runFDRAnalysis = async function({ matrix, alpha0, alphaMax, Nalpha, Nperm, nsupp, onProgress, initialSVD = null, isCancelled = () => false, useFixedPermutations = false }) {
            const P = matrix.length;
            const pi0 = (P - nsupp) / P;
            
            // Load or generate fixed permutation patterns if requested
            let fixedPatterns = null;
            if (useFixedPermutations) {
                fixedPatterns = loadPermutationPatterns();
                if (!fixedPatterns || fixedPatterns.length < Nperm) {
                    console.log('Generating fixed permutation patterns...');
                    fixedPatterns = generateFixedPermutations(Nperm, P);
                    savePermutationPatterns(fixedPatterns);
                    console.log(`Generated and saved ${Nperm} fixed permutation patterns`);
                } else {
                    console.log(`Using ${Nperm} fixed permutation patterns from storage`);
                }
            }
            
            const alphaValues = [];
            for (let i = 0; i < Nalpha; i++) {
                const alpha = alpha0 + (alphaMax - alpha0) * i / (Nalpha - 1);
                alphaValues.push(alpha);
            }

            const results = [];
            let totalProgress = 0;
            const totalRuns = Nalpha * (1 + Nperm);

            for (let alphaIdx = 0; alphaIdx < alphaValues.length; alphaIdx++) {
                // Check for cancellation before processing each alpha
                if (isCancelled()) {
                    console.log('FDR analysis cancelled by user');
                    return {
                        alphaValues: alphaValues.slice(0, alphaIdx),
                        fdrValues: results.map(r => r.eFDR),
                        detectionCounts: results.map(r => r.detectionCount),
                        gradients: results.map(r => r.gradient),
                        results,
                        pi0,
                        totalRuns,
                        cancelled: true
                    };
                }
                
                const alpha = alphaValues[alphaIdx];
                
                try {
                    console.log(`Starting original SSVD for alpha ${alphaIdx + 1}/${Nalpha}: ${alpha.toFixed(6)}`);
                    
                    // Run SSVD on original matrix with optimized parameters
                    const alphaRatio = alpha / alphaMax;
                    
                    // For ORIGINAL matrix: Give small alphas the iterations they need
                    const adaptiveMaxIterOrig = 
                        alphaRatio < 0.05 ? 2000 :     // Very small: many iterations
                        alphaRatio < 0.2 ? 1000 :       // Small: standard
                        alphaRatio < 0.5 ? 500 :        // Medium: fewer
                        alphaRatio < 0.75 ? 200 :       // Large: fast
                        100;                            // Near alphaMax: very fast
                    
                    const adaptiveToleranceOrig = 
                        alphaRatio < 0.2 ? 0.0001 :     // Tight for small alphas
                        alphaRatio < 0.5 ? 0.001 :      
                        0.01;                           // Looser for large alphas
                    
                    const originalResult = await SSVDR1Algorithm({
                        matrix, 
                        alpha,
                        maxIter: adaptiveMaxIterOrig,   // Use adaptive
                        tolerance: adaptiveToleranceOrig,  // Use adaptive
                        initialSVD   // Pass the cached SVD for original matrix
                    });
                    const originalDetections = originalResult.u.filter(val => Math.abs(val) > 1e-10).length;
                    
                    console.log(`Original SSVD completed for alpha ${alpha.toFixed(6)}: ${originalDetections} detections, ${originalResult.iterations} iterations`);
                    
                    // Early termination: If solution becomes all zeros, all higher alphas will also be zero
                    if (originalDetections === 0 && alphaIdx > 0) {
                        console.log(`Early termination: Zero detections at alpha ${alpha.toFixed(6)}. Skipping remaining alphas.`);
                        // Fill remaining results with zeros
                        for (let i = alphaIdx; i < alphaValues.length; i++) {
                            results.push({
                                alpha: alphaValues[i],
                                detectionCount: 0,
                                eFDR: 0,
                                gradient: 0,
                                permutationDetections: 0
                            });
                        }
                        break; // Exit the alpha loop
                    }
                    
                    totalProgress++;
                    if (onProgress) {
                        onProgress(totalProgress, totalRuns, `Alpha ${alphaIdx + 1}/${Nalpha}: Original`);
                    }

                // Permutation tests with batching
                let totalPermDetections = 0;
                
                // Detect optimal batch size based on hardware
                const batchSize = Math.min(navigator.hardwareConcurrency || 4, 8);
                console.log(`Processing ${Nperm} permutations in batches of ${batchSize}`);
                
                // Process permutations in batches
                for (let batchStart = 0; batchStart < Nperm; batchStart += batchSize) {
                    // Check for cancellation before each batch
                    if (isCancelled()) {
                        console.log('FDR analysis cancelled during permutations');
                        break;
                    }
                    
                    const batchEnd = Math.min(batchStart + batchSize, Nperm);
                    const currentBatchSize = batchEnd - batchStart;
                    const batchNumber = Math.floor(batchStart / batchSize) + 1;
                    const totalBatches = Math.ceil(Nperm / batchSize);
                    
                    console.log(`Starting batch ${batchNumber}/${totalBatches} (perms ${batchStart + 1}-${batchEnd}) for alpha ${alphaIdx + 1}/${Nalpha}`);
                    
                    // Create promises for all permutations in this batch
                    const batchPromises = [];
                    for (let perm = batchStart; perm < batchEnd; perm++) {
                        batchPromises.push(
                            (async () => {
                                try {
                                    const permutedMatrix = useFixedPermutations && fixedPatterns ? 
                                        permuteMatrixRows(matrix, fixedPatterns[perm]) :
                                        permuteMatrixRows(matrix);
                                    // Data-driven adaptive parameters based on alphaMax ratio (OPTIMIZED for permutations)
                                    const alphaRatio = alpha / alphaMax;
                                    
                                    // For PERMUTATIONS: Prioritize speed, invert iteration logic
                                    const adaptiveMaxIter = 
                                        alphaRatio < 0.05 ? 400 :      // Very small: cap iterations (was 1000!)
                                        alphaRatio < 0.2 ? 350 :        // Small: less time
                                        alphaRatio < 0.5 ? 250 :        // Medium: faster
                                        alphaRatio < 0.75 ? 150 :       // Large: very fast
                                        50;                             // Near alphaMax: minimal
                                    
                                    const adaptiveTolerance = 
                                        alphaRatio < 0.2 ? 0.01 :       // Loose for small alphas (was 0.0001!)
                                        alphaRatio < 0.5 ? 0.005 :      
                                        0.001;                          // Tighter only for large alphas
                                    
                                    // Use reduced parameters for permutations (only need approximate null distribution)
                                    const permResult = await SSVDR1Algorithm({
                                        matrix: permutedMatrix,
                                        alpha,
                                        maxIter: adaptiveMaxIter,  // Adaptive based on alpha
                                        tolerance: adaptiveTolerance  // Adaptive based on alpha
                                    });
                                    const permDetections = permResult.u.filter(val => Math.abs(val) > 1e-10).length;
                                    return permDetections;
                                } catch (error) {
                                    console.error(`Permutation ${perm + 1} in batch ${batchNumber} failed:`, error);
                                    return 0; // Return 0 detections on error
                                }
                            })()
                        );
                    }
                    
                    // Wait for all permutations in batch to complete
                    const batchResults = await Promise.all(batchPromises);
                    
                    // Sum up detections from this batch
                    const batchDetections = batchResults.reduce((sum, val) => sum + val, 0);
                    totalPermDetections += batchDetections;
                    
                    console.log(`Batch ${batchNumber}/${totalBatches} completed: ${batchDetections} total detections from ${currentBatchSize} permutations`);
                    
                    // Update progress for the batch
                    totalProgress += currentBatchSize;
                    if (onProgress) {
                        onProgress(totalProgress, totalRuns, 
                            `Alpha ${alphaIdx + 1}/${Nalpha}: Batch ${batchNumber}/${totalBatches} complete`);
                    }
                }

                    const avgPermDetections = totalPermDetections / Nperm;
                    const expectedFalsePos = pi0 * avgPermDetections;
                    const fdr = originalDetections > 0 ? expectedFalsePos / originalDetections : 0;
                    const eFDR = Math.min(fdr * 100, 100);
                    
                    // Calculate gradient (change in detections)
                    let gradient = 0;
                    if (alphaIdx > 0) {
                        gradient = results[alphaIdx - 1].detectionCount - originalDetections;
                    }

                    results.push({
                        alpha,
                        detectionCount: originalDetections,
                        avgPermDetections,
                        eFDR,
                        gradient
                    });
                    
                    console.log(`Alpha ${alphaIdx + 1}/${Nalpha} complete: eFDR = ${eFDR.toFixed(2)}%`);
                    
                } catch (error) {
                    console.error(`Alpha ${alphaIdx + 1} failed:`, error);
                    // Add a failed result to keep indexing consistent
                    results.push({
                        alpha,
                        detectionCount: 0,
                        avgPermDetections: 0,
                        eFDR: 100,  // Assume worst case
                        gradient: 0
                    });
                }
            }

            return {
                alphaValues,
                fdrValues: results.map(r => r.eFDR),
                detectionCounts: results.map(r => r.detectionCount),
                gradients: results.map(r => r.gradient),
                results,
                pi0,
                totalRuns
            };
        };

        // ===================================================================
        // PHASE 3: DATA REVIEW - STATISTICS AND VISUALIZATIONS
        // ===================================================================

        // Calculate comprehensive matrix statistics
        const calculateMatrixStatistics = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Memory-efficient overall statistics
            let min = Infinity, max = -Infinity, sum = 0, count = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    if (val < min) min = val;
                    if (val > max) max = val;
                    sum += val;
                    count++;
                }
            }
            const mean = sum / count;
            
            // Calculate variance in second pass
            let sumSquaredDiff = 0;
            for (let i = 0; i < P; i++) {
                for (let j = 0; j < N; j++) {
                    const val = matrix[i][j];
                    sumSquaredDiff += Math.pow(val - mean, 2);
                }
            }
            const variance = sumSquaredDiff / count;
            const stdDev = Math.sqrt(variance);
            
            // Row statistics (across samples for each feature)
            const rowMeans = matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N);
            const rowStdDevs = matrix.map((row, i) => {
                const rowMean = rowMeans[i];
                const variance = row.reduce((sum, val) => sum + Math.pow(val - rowMean, 2), 0) / N;
                return Math.sqrt(variance);
            });
            
            // Column statistics (across features for each sample)
            const columnMeans = Array(N).fill(0).map((_, j) => 
                matrix.reduce((sum, row) => sum + row[j], 0) / P
            );
            const columnStdDevs = columnMeans.map((colMean, j) => {
                const variance = matrix.reduce((sum, row) => sum + Math.pow(row[j] - colMean, 2), 0) / P;
                return Math.sqrt(variance);
            });
            
            return {
                P, N, min, max, mean, stdDev,
                rowMeans, rowStdDevs,
                columnMeans, columnStdDevs
            };
        };

        // Calculate eigenvalue spectrum (σ²) from SVD
        const calculateEigenvalueSpectrum = function(matrix) {
            console.log('🔥 COMPUTING EIGENVALUE SPECTRUM (σ²) v3.0 🔥');
            console.log('Matrix dimensions for SVD:', matrix.length, 'x', matrix[0].length);
            // Use fullSVD to get eigenvalues (σ²)
            const eigenvalues = fullSVD(matrix);
            console.log('🔥 EIGENVALUES COMPUTED:', eigenvalues.length, 'values, range:', 
                        eigenvalues.length > 0 ? `${eigenvalues[0].toFixed(2)} to ${eigenvalues[eigenvalues.length-1].toFixed(2)}` : 'empty');
            return eigenvalues; // Return array of eigenvalues (σ²)
        };

        // ===================================================================
        // DATA PREPROCESSING FUNCTIONS
        // ===================================================================

        // Calculate Frobenius norm of a matrix
        const calculateFrobeniusNorm = function(matrix) {
            let sumSquares = 0;
            for (let i = 0; i < matrix.length; i++) {
                for (let j = 0; j < matrix[i].length; j++) {
                    sumSquares += matrix[i][j] * matrix[i][j];
                }
            }
            return Math.sqrt(sumSquares);
        };

        // Apply preprocessing: Frobenius normalization followed by row centering
        const preprocessMatrix = function(matrix) {
            const P = matrix.length;
            const N = matrix[0].length;
            
            // Step 1: Calculate Frobenius norm
            const frobeniusNorm = calculateFrobeniusNorm(matrix);
            console.log(`Frobenius norm of original matrix: ${frobeniusNorm.toFixed(6)}`);
            
            // Step 2: Normalize by Frobenius norm
            const normalizedMatrix = matrix.map(row => 
                row.map(val => val / frobeniusNorm)
            );
            
            // Step 3: Calculate row means of normalized matrix
            const rowMeans = normalizedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            
            // Step 4: Center each row by subtracting row mean
            const preprocessedMatrix = normalizedMatrix.map((row, i) => 
                row.map(val => val - rowMeans[i])
            );
            
            // Verify preprocessing
            const newFrobeniusNorm = calculateFrobeniusNorm(preprocessedMatrix);
            const newRowMeans = preprocessedMatrix.map(row => 
                row.reduce((sum, val) => sum + val, 0) / N
            );
            const maxRowMean = Math.max(...newRowMeans.map(Math.abs));
            
            console.log(`Frobenius norm after preprocessing: ${newFrobeniusNorm.toFixed(6)}`);
            console.log(`Max absolute row mean after centering: ${maxRowMean.toExponential(3)}`);
            
            return {
                preprocessedMatrix,
                frobeniusNormOriginal: frobeniusNorm,
                frobeniusNormProcessed: newFrobeniusNorm,
                rowMeansOriginal: matrix.map(row => row.reduce((sum, val) => sum + val, 0) / N),
                rowMeansProcessed: newRowMeans
            };
        };

        // ===================================================================
        // REACT COMPONENTS (PHASE 2: ENHANCED CSV UPLOAD)
        // ===================================================================

        // CSV Upload Component with drag-and-drop and preview
        const CSVUploader = ({ onDataLoaded }) => {
            const [isDragging, setIsDragging] = useState(false);
            const [preview, setPreview] = useState(null);
            const [isProcessing, setIsProcessing] = useState(false);
            const [processingMessage, setProcessingMessage] = useState('');

            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragging(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragging(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragging(false);
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            };

            const handleFileChange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    handleFile(file);
                }
            };

            const handleFile = (file) => {
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    alert('Please select a CSV file');
                    return;
                }

                setIsProcessing(true);
                setProcessingMessage('Starting CSV parsing...');
                
                // Use streaming for large files
                const rawData = [];
                let rowCount = 0;
                let hasHeaders = null;
                let firstRowProcessed = false;
                const fileSize = file.size;
                let bytesProcessed = 0;
                
                Papa.parse(file, {
                    worker: false, // Could enable for better performance
                    step: (row, parser) => {
                        // Process each row as it's parsed
                        if (row.data && row.data.length > 0) {
                            rawData.push(row.data);
                            rowCount++;
                            
                            // Update progress periodically
                            if (rowCount % 1000 === 0) {
                                const progress = Math.round((row.meta.cursor / fileSize) * 100);
                                setProcessingMessage(`Processing row ${rowCount.toLocaleString()} (${progress}% complete)...`);
                            }
                            
                            // For very large files, could add a row limit
                            // if (rowCount > 50000) {
                            //     parser.abort();
                            //     console.warn('Row limit reached, processing first 50,000 rows only');
                            // }
                        }
                    },
                    complete: (results) => {
                        try {
                            setProcessingMessage('Validating matrix data...');
                            
                            // Filter out empty rows
                            const filteredData = rawData.filter(row => 
                                row.some(cell => cell && cell.toString().trim() !== '')
                            );

                            if (filteredData.length === 0) {
                                throw new Error('File appears to be empty');
                            }

                            console.log(`Parsed ${filteredData.length} rows from CSV file`);

                            // Store metadata for display
                            let rowHeaders = [];
                            let columnHeaders = [];
                            let dataStartRow = 0;
                            let dataStartCol = 0;

                            // Check for column headers (first row contains non-numeric values)
                            const firstRow = filteredData[0];
                            const hasColumnHeaders = firstRow.slice(1).some(cell => {
                                const num = parseFloat(cell);
                                return isNaN(num) && cell.toString().trim() !== '';
                            });

                            // Check for row headers (first column contains non-numeric values)
                            const hasRowHeaders = filteredData.slice(1).some(row => {
                                if (row.length > 0) {
                                    const num = parseFloat(row[0]);
                                    return isNaN(num) && row[0].toString().trim() !== '';
                                }
                                return false;
                            });

                            // Detect if corner cell exists (typical for datasets with both row and column headers)
                            const hasCornerLabel = hasColumnHeaders && hasRowHeaders;

                            if (hasColumnHeaders) {
                                columnHeaders = firstRow.slice(hasRowHeaders ? 1 : 0);
                                dataStartRow = 1;
                                console.log(`Column headers detected: ${columnHeaders.slice(0, 5).join(', ')}${columnHeaders.length > 5 ? '...' : ''}`);
                            }

                            if (hasRowHeaders) {
                                rowHeaders = filteredData.slice(dataStartRow).map(row => row[0]);
                                dataStartCol = 1;
                                console.log(`Row headers detected: ${rowHeaders.slice(0, 5).join(', ')}${rowHeaders.length > 5 ? '...' : ''}`);
                            }

                            // Extract numeric data matrix
                            const dataRows = filteredData.slice(dataStartRow);
                            
                            if (dataRows.length === 0) {
                                throw new Error('No data rows found after removing headers');
                            }

                            // Convert to numeric matrix, collecting errors instead of throwing
                            const parseErrors = [];
                            const MAX_ERRORS_TO_COLLECT = 10; // Limit error collection
                            
                            const matrix = dataRows.map((row, rowIndex) => {
                                const dataRow = row.slice(dataStartCol);
                                return dataRow.map((cell, colIndex) => {
                                    const num = parseFloat(cell);
                                    if (isNaN(num)) {
                                        if (parseErrors.length < MAX_ERRORS_TO_COLLECT) {
                                            const actualRow = rowIndex + dataStartRow + 1;
                                            const actualCol = colIndex + dataStartCol + 1;
                                            let location = `row ${actualRow}, column ${actualCol}`;
                                            if (rowHeaders.length > rowIndex) {
                                                location = `gene/feature "${rowHeaders[rowIndex]}"`;
                                            }
                                            if (columnHeaders.length > colIndex) {
                                                location += `, sample "${columnHeaders[colIndex]}"`;
                                            }
                                            parseErrors.push(`${location}: "${cell}"`);
                                        }
                                        return 0; // Replace non-numeric with 0 or could use NaN
                                    }
                                    return num;
                                });
                            });
                            
                            // Report errors once if any were found
                            if (parseErrors.length > 0) {
                                const errorMessage = `Found ${parseErrors.length} non-numeric values. First few:\n${parseErrors.slice(0, 5).join('\n')}`;
                                console.warn('Parse warnings:', errorMessage);
                                // Only show alert for critical issues, not warnings
                                if (parseErrors.length > 100) {
                                    alert(`Warning: ${parseErrors.length} non-numeric values found and replaced with 0. Check console for details.`);
                                }
                            }

                            // Display format detection message
                            let formatMessage = 'Processing data';
                            if (hasColumnHeaders && hasRowHeaders) {
                                formatMessage = `Gene expression format detected: ${rowHeaders.length} genes × ${columnHeaders.length} samples`;
                            } else if (hasColumnHeaders) {
                                formatMessage = `Column headers detected: ${columnHeaders.length} columns`;
                            } else if (hasRowHeaders) {
                                formatMessage = `Row headers detected: ${rowHeaders.length} rows`;
                            } else {
                                formatMessage = 'Pure numeric matrix detected';
                            }
                            setProcessingMessage(formatMessage);

                            if (matrix.length === 0 || matrix[0].length === 0) {
                                throw new Error('No valid data found in CSV');
                            }

                            // Validate rectangular matrix
                            const N = matrix[0].length;
                            const isRectangular = matrix.every((row, index) => {
                                if (row.length !== N) {
                                    throw new Error(`Row ${index + 1} has ${row.length} columns, expected ${N}`);
                                }
                                return true;
                            });

                            const P = matrix.length;

                            // Validate matrix size
                            if (P < 2 || N < 2) {
                                throw new Error(`Matrix too small: ${P}×${N}. Minimum size is 2×2`);
                            }

                            // Removed large matrix warning - process all sizes without confirmation

                            // Create preview (first 5×5)
                            const previewSize = Math.min(5, Math.min(P, N));
                            const matrixPreview = matrix.slice(0, previewSize).map(row => row.slice(0, previewSize));

                            setPreview({
                                data: matrixPreview,
                                totalDimensions: { P, N },
                                showMore: P > previewSize || N > previewSize
                            });

                            const matrixInfo = {
                                P, N,
                                filename: file.name,
                                fileSize: file.size,
                                rowHeaders: rowHeaders.length > 0 ? rowHeaders : null,
                                columnHeaders: columnHeaders.length > 0 ? columnHeaders : null,
                                hasHeaders: hasColumnHeaders || hasRowHeaders
                            };

                            setIsProcessing(false);
                            onDataLoaded(matrix, matrixInfo);

                        } catch (error) {
                            console.error('CSV processing error:', error);
                            alert(`Error processing CSV: ${error.message}`);
                            setIsProcessing(false);
                        }
                    },
                    error: (error) => {
                        alert(`CSV parsing failed: ${error.message}`);
                        setIsProcessing(false);
                    },
                    header: false,
                    skipEmptyLines: true,
                    delimiter: ',',
                    dynamicTyping: false
                });
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">Upload CSV Matrix</h2>
                    
                    <div
                        className={`border-2 border-dashed rounded-lg p-8 text-center transition-colors ${
                            isDragging ? 'border-indigo-500 bg-indigo-50' : 'border-gray-300'
                        }`}
                        onDragOver={handleDragOver}
                        onDragLeave={handleDragLeave}
                        onDrop={handleDrop}
                    >
                        {isProcessing ? (
                            <div className="flex flex-col items-center space-y-3">
                                <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600"></div>
                                <span className="text-gray-700">{processingMessage}</span>
                            </div>
                        ) : (
                            <>
                                <input
                                    type="file"
                                    accept=".csv"
                                    onChange={handleFileChange}
                                    className="hidden"
                                    id="csvUpload"
                                />
                                <div className="space-y-3">
                                    <div className="text-4xl text-gray-400 mb-4">📊</div>
                                    <label
                                        htmlFor="csvUpload"
                                        className="cursor-pointer inline-flex items-center px-6 py-3 border border-transparent text-base font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 transition-colors"
                                    >
                                        Choose CSV File
                                    </label>
                                    <p className="text-gray-600">
                                        or drag and drop your CSV file here
                                    </p>
                                    <div className="text-sm text-gray-500 mt-2">
                                        <div className="font-medium">Supported formats:</div>
                                        <ul className="mt-1 text-xs space-y-1">
                                            <li>• Numeric CSV matrix (P×N)</li>
                                            <li>• Gene expression format (row & column headers)</li>
                                            <li>• Headers automatically detected and extracted</li>
                                            <li>• Comma-separated values</li>
                                            <li>• Minimum size: 2×2 data matrix</li>
                                        </ul>
                                    </div>
                                </div>
                            </>
                        )}
                    </div>

                    {/* Matrix Preview */}
                    {preview && (
                        <div className="mt-6 p-4 bg-gray-50 rounded-lg">
                            <h3 className="font-medium mb-3">Matrix Preview ({preview.totalDimensions.P} × {preview.totalDimensions.N})</h3>
                            <div className="overflow-x-auto">
                                <table className="min-w-full text-sm">
                                    <tbody>
                                        {preview.data.map((row, i) => (
                                            <tr key={i}>
                                                {row.map((cell, j) => (
                                                    <td key={j} className="px-2 py-1 border border-gray-300 text-right font-mono">
                                                        {cell.toFixed(3)}
                                                    </td>
                                                ))}
                                                {preview.showMore && <td className="px-2 py-1 text-gray-400">...</td>}
                                            </tr>
                                        ))}
                                        {preview.showMore && (
                                            <tr>
                                                <td colSpan={preview.data[0].length + 1} className="px-2 py-1 text-center text-gray-400">⋮</td>
                                            </tr>
                                        )}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // FDR Analysis Panel Component
        const FDRAnalysisPanel = ({ matrix, matrixInfo, onResultsReady }) => {
            // Guard against null matrixInfo
            if (!matrixInfo || !matrixInfo.P) {
                return <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="text-center text-gray-500">Loading matrix information...</div>
                </div>;
            }
            
            const [parameters, setParameters] = useState({
                Nalpha: 20,
                nsupp: Math.min(50, Math.floor(matrixInfo.P / 2)),
                Nperm: 100
            });
            const [isRunning, setIsRunning] = useState(false);
            const [progress, setProgress] = useState({ current: 0, total: 0, message: '' });
            const [isCancelled, setIsCancelled] = useState(false);

            const handleParameterChange = (param, value) => {
                setParameters(prev => ({
                    ...prev,
                    [param]: parseInt(value)
                }));
            };

            const runAnalysis = async () => {
                setIsRunning(true);
                setProgress({ current: 0, total: 0, message: 'Initializing FDR analysis...' });

                try {
                    const results = await runFDRAnalysis({
                        matrix,
                        alpha0: 0,
                        alphaMax: matrixInfo.alphaMax,
                        Nalpha: parameters.Nalpha,
                        Nperm: parameters.Nperm,
                        nsupp: parameters.nsupp,
                        initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                        isCancelled: () => isCancelled,  // Pass cancellation check
                        onProgress: (current, total, message) => {
                            setProgress({ current, total, message });
                        }
                    });

                    if (results.cancelled) {
                        setProgress({ current: 0, total: 0, message: 'Analysis cancelled by user' });
                        console.log('FDR analysis was cancelled');
                    } else {
                        onResultsReady(results);
                    }
                } catch (error) {
                    console.error('FDR Analysis failed:', error);
                    alert(`FDR Analysis failed: ${error.message}`);
                } finally {
                    setIsRunning(false);
                    setIsCancelled(false);
                }
            };

            const cancelAnalysis = () => {
                setIsCancelled(true);
                setProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            const estimatedTime = Math.ceil((parameters.Nalpha * (1 + parameters.Nperm)) / 10); // rough estimate in seconds

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <h2 className="text-xl font-semibold mb-4">FDR Analysis Parameters</h2>
                    
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6">
                        {/* Nalpha Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Number of Alpha Values (Nalpha)
                            </label>
                            <input
                                type="range"
                                min="10"
                                max="100"
                                value={parameters.Nalpha}
                                onChange={(e) => handleParameterChange('Nalpha', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>10</span>
                                <span className="font-medium">{parameters.Nalpha}</span>
                                <span>100</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of alpha values to test between 0 and {matrixInfo.alphaMax.toFixed(4)}
                            </p>
                        </div>

                        {/* nsupp Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Expected Signal Features (nsupp)
                            </label>
                            <input
                                type="range"
                                min="1"
                                max={matrixInfo.P}
                                value={parameters.nsupp}
                                onChange={(e) => handleParameterChange('nsupp', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>1</span>
                                <span className="font-medium">{parameters.nsupp}</span>
                                <span>{matrixInfo.P}</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Expected number of true signal features (π₀ = {((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}% null)
                            </p>
                        </div>

                        {/* Nperm Parameter */}
                        <div className="space-y-2">
                            <label className="block text-sm font-medium text-gray-700">
                                Permutation Tests (Nperm)
                            </label>
                            <input
                                type="range"
                                min="50"
                                max="1000"
                                value={parameters.Nperm}
                                onChange={(e) => handleParameterChange('Nperm', e.target.value)}
                                className="w-full"
                                disabled={isRunning}
                            />
                            <div className="flex justify-between text-xs text-gray-500">
                                <span>50</span>
                                <span className="font-medium">{parameters.Nperm}</span>
                                <span>1000</span>
                            </div>
                            <p className="text-xs text-gray-600">
                                Number of permutation tests per alpha value
                            </p>
                        </div>
                    </div>

                    {/* Analysis Summary */}
                    <div className="bg-gray-50 p-4 rounded-lg mb-4">
                        <h3 className="font-medium mb-2">Analysis Summary</h3>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Total runs:</span>
                                <span className="font-medium ml-2">{parameters.Nalpha * (1 + parameters.Nperm)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Est. time:</span>
                                <span className="font-medium ml-2">{Math.floor(estimatedTime / 60)}:{(estimatedTime % 60).toString().padStart(2, '0')}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">Alpha range:</span>
                                <span className="font-medium ml-2">0 → {matrixInfo.alphaMax.toFixed(4)}</span>
                            </div>
                            <div>
                                <span className="text-gray-600">π₀:</span>
                                <span className="font-medium ml-2">{((matrixInfo.P - parameters.nsupp) / matrixInfo.P * 100).toFixed(1)}%</span>
                            </div>
                        </div>
                    </div>

                    {/* Progress Display */}
                    {isRunning && (
                        <div className="bg-blue-50 p-4 rounded-lg mb-4">
                            <div className="flex items-center justify-between mb-2">
                                <span className="text-sm font-medium text-blue-800">
                                    {progress.message}
                                </span>
                                <span className="text-sm text-blue-600">
                                    {progress.current} / {progress.total}
                                </span>
                            </div>
                            <div className="w-full bg-blue-200 rounded-full h-2">
                                <div 
                                    className="bg-blue-600 h-2 rounded-full transition-all duration-300"
                                    style={{ width: `${progress.total > 0 ? (progress.current / progress.total) * 100 : 0}%` }}
                                ></div>
                            </div>
                            <div className="text-xs text-blue-600 mt-1">
                                {progress.total > 0 ? `${((progress.current / progress.total) * 100).toFixed(1)}% complete` : 'Initializing...'}
                            </div>
                        </div>
                    )}

                    {/* Run/Cancel Analysis Buttons */}
                    <div className="flex justify-end space-x-4">
                        {!isRunning ? (
                            <button
                                onClick={runAnalysis}
                                className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                            >
                                Run FDR Analysis
                            </button>
                        ) : (
                            <div className="flex items-center space-x-4">
                                <div className="flex items-center space-x-2 text-indigo-600">
                                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-indigo-600"></div>
                                    <span>Running Analysis...</span>
                                </div>
                                <button
                                    onClick={cancelAnalysis}
                                    className="px-4 py-2 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                >
                                    Cancel
                                </button>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // FDR Results Display Component
        // Interactive FDR Chart Component
        const FDRChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const [zoomState, setZoomState] = useState({
                alphaMin: null, alphaMax: null, valueMin: null, valueMax: null,
                isZoomed: false, zoomLevel: 1
            });

            // Chart dimensions and margins
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Data ranges
            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const fdrRange = [Math.min(...data.fdrValues), Math.max(...data.fdrValues)];
            
            // Current view ranges (with zoom)
            const currentAlphaMin = zoomState.alphaMin ?? alphaRange[0];
            const currentAlphaMax = zoomState.alphaMax ?? alphaRange[1];
            const currentValueMin = zoomState.valueMin ?? 0;
            const currentValueMax = zoomState.valueMax ?? Math.max(100, Math.ceil(fdrRange[1] * 1.1));

            // Scale functions
            const xScale = (alpha) => margin.left + ((alpha - currentAlphaMin) / (currentAlphaMax - currentAlphaMin)) * chartWidth;
            const yScale = (fdr) => margin.top + ((currentValueMax - fdr) / (currentValueMax - currentValueMin)) * chartHeight;

            const handlePointClick = (index) => {
                console.log('🎯 FDR Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                // Always select and run SSVD on first click
                onRowSelect(index);
            };

            const resetZoom = () => {
                setZoomState({
                    alphaMin: null, alphaMax: null, valueMin: null, valueMax: null,
                    isZoomed: false, zoomLevel: 1
                });
            };

            // Generate axis ticks
            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(currentAlphaMin, currentAlphaMax);
            const yTicks = generateTicks(currentValueMin, currentValueMax);

            return (
                <div className="relative flex items-center justify-center">
                    <div className="absolute top-2 right-2 z-10 bg-white border border-gray-300 rounded-md p-2 shadow-sm">
                        <div className="flex items-center space-x-2 text-xs">
                            <span className="text-gray-600">Zoom: {zoomState.zoomLevel.toFixed(1)}x</span>
                            <button 
                                className={`px-2 py-1 ${zoomState.isZoomed ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-300 cursor-not-allowed'} text-white rounded text-xs`}
                                onClick={resetZoom}
                                disabled={!zoomState.isZoomed}
                            >
                                Reset
                            </button>
                        </div>
                        <div className="text-xs text-gray-500 mt-1">
                            {zoomState.isZoomed ? 'Click point to select' : 'Click point to zoom'}
                        </div>
                    </div>
                    
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        {/* Grid and Clipping */}
                        <defs>
                            <pattern id="fdrGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="fdrChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#fdrGrid)"/>
                        
                        {/* Axes */}
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {/* Y-axis ticks and labels */}
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(1)}
                                </text>
                            </g>
                        ))}
                        
                        {/* X-axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#fdrChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.fdrValues[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#EF4444" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.fdrValues[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#EF4444"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}
eFDR: ${data.fdrValues[index].toFixed(2)}%
Detections: ${data.detectionCounts[index]}
${zoomState.isZoomed ? 'Click to select' : 'Click to zoom, then click to select'}`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        {/* Axis labels */}
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            FDR (%)
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Detections Chart Component  
        const DetectionsChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const [zoomState, setZoomState] = useState({
                alphaMin: null, alphaMax: null, valueMin: null, valueMax: null,
                isZoomed: false, zoomLevel: 1
            });

            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const detectionRange = [0, Math.max(...data.detectionCounts)];
            
            const currentAlphaMin = zoomState.alphaMin ?? alphaRange[0];
            const currentAlphaMax = zoomState.alphaMax ?? alphaRange[1];
            const currentValueMin = zoomState.valueMin ?? detectionRange[0];
            const currentValueMax = zoomState.valueMax ?? detectionRange[1];

            const xScale = (alpha) => margin.left + ((alpha - currentAlphaMin) / (currentAlphaMax - currentAlphaMin)) * chartWidth;
            const yScale = (detections) => margin.top + ((currentValueMax - detections) / (currentValueMax - currentValueMin)) * chartHeight;

            const handlePointClick = (index) => {
                console.log('📊 Detections Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                // Always select and run SSVD on first click
                onRowSelect(index);
            };

            const resetZoom = () => {
                setZoomState({
                    alphaMin: null, alphaMax: null, valueMin: null, valueMax: null,
                    isZoomed: false, zoomLevel: 1
                });
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(currentAlphaMin, currentAlphaMax);
            const yTicks = generateTicks(currentValueMin, currentValueMax).map(t => Math.round(t));

            return (
                <div className="relative flex items-center justify-center">
                    <div className="absolute top-2 right-2 z-10 bg-white border border-gray-300 rounded-md p-2 shadow-sm">
                        <div className="flex items-center space-x-2 text-xs">
                            <span className="text-gray-600">Zoom: {zoomState.zoomLevel.toFixed(1)}x</span>
                            <button 
                                className={`px-2 py-1 ${zoomState.isZoomed ? 'bg-blue-500 hover:bg-blue-600' : 'bg-gray-300 cursor-not-allowed'} text-white rounded text-xs`}
                                onClick={resetZoom}
                                disabled={!zoomState.isZoomed}
                            >
                                Reset
                            </button>
                        </div>
                        <div className="text-xs text-gray-500 mt-1">
                            {zoomState.isZoomed ? 'Click point to select' : 'Click point to zoom'}
                        </div>
                    </div>
                    
                    <svg width={width} height={height} viewBox={`0 0 ${width} ${height}`} style={{maxWidth: '100%', height: 'auto'}} preserveAspectRatio="xMidYMid meet">
                        <defs>
                            <pattern id="detectGrid" width="40" height="32" patternUnits="userSpaceOnUse">
                                <path d="M 40 0 L 0 0 0 32" fill="none" stroke="#e5e7eb" strokeWidth="1"/>
                            </pattern>
                            <clipPath id="detectChartClip">
                                <rect x={margin.left - 10} y={margin.top - 10} width={chartWidth + 20} height={chartHeight + 20} />
                            </clipPath>
                        </defs>
                        <rect width="100%" height="100%" fill="url(#detectGrid)"/>
                        
                        <line x1={margin.left} y1={margin.top} x2={margin.left} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        <line x1={margin.left} y1={height - margin.bottom} x2={width - margin.right} y2={height - margin.bottom} stroke="#374151" strokeWidth="2"/>
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick}
                                </text>
                            </g>
                        ))}
                        
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {/* Data content - separately clipped */}
                        <g clipPath="url(#detectChartClip)">
                            {/* Data line - strictly clipped */}
                            <g>
                                <path 
                                    d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.detectionCounts[i])}`).join(' L ')}`}
                                    fill="none" 
                                    stroke="#3B82F6" 
                                    strokeWidth="3"
                                />
                            </g>
                            
                            {/* Data points - with padding for visibility */}
                            {data.alphaValues.map((alpha, index) => {
                                const isSelected = selectedRowIndex === index;
                                const cx = xScale(alpha);
                                const cy = yScale(data.detectionCounts[index]);
                                // Only render points that are reasonably within view
                                if (cx < margin.left - 20 || cx > width - margin.right + 20 || 
                                    cy < margin.top - 20 || cy > height - margin.bottom + 20) {
                                    return null;
                                }
                                return (
                                    <circle
                                        key={index}
                                        cx={cx}
                                        cy={cy}
                                    r={isSelected ? "8" : "5"}
                                    fill={isSelected ? "#FFA500" : "#3B82F6"}
                                    stroke={isSelected ? "#FF8C00" : "#FFFFFF"}
                                    strokeWidth={isSelected ? "3" : "2"}
                                    className="hover:opacity-80 transition-all cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}
eFDR: ${data.fdrValues[index].toFixed(2)}%
Detections: ${data.detectionCounts[index]}
${zoomState.isZoomed ? 'Click to select' : 'Click to zoom, then click to select'}`}
                                    </title>
                                </circle>
                                );
                            })}
                        </g>
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Number of Detections
                        </text>
                    </svg>
                </div>
            );
        };

        // Interactive Gradient Chart Component
        const GradientChart = ({ data, selectedRowIndex, onRowSelect }) => {
            const width = 700, height = 320;
            const margin = { top: 20, right: 30, bottom: 50, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const alphaRange = [Math.min(...data.alphaValues), Math.max(...data.alphaValues)];
            const gradientRange = [Math.min(...data.gradients), Math.max(...data.gradients)];
            
            const xScale = (alpha) => margin.left + ((alpha - alphaRange[0]) / (alphaRange[1] - alphaRange[0])) * chartWidth;
            const yScale = (gradient) => margin.top + ((gradientRange[1] - gradient) / (gradientRange[1] - gradientRange[0])) * chartHeight;

            const handlePointClick = (index) => {
                console.log('📈 Gradient Chart point clicked! Index:', index, 'Alpha:', data.alphaValues[index]);
                console.log('Event fired successfully - calling onRowSelect');
                onRowSelect(index);
            };

            const generateTicks = (min, max, count = 5) => {
                const step = (max - min) / (count - 1);
                return Array.from({ length: count }, (_, i) => min + i * step);
            };

            const xTicks = generateTicks(alphaRange[0], alphaRange[1]);
            const yTicks = generateTicks(gradientRange[0], gradientRange[1]);

            return (
                <div className="w-full h-full flex items-center justify-center">
                    <svg width={width} height={height} className="border border-gray-300 bg-white">
                        {/* Grid lines */}
                        {xTicks.map((tick, i) => (
                            <line key={`v-${i}`} x1={xScale(tick)} y1={margin.top} x2={xScale(tick)} y2={height - margin.bottom} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        {yTicks.map((tick, i) => (
                            <line key={`h-${i}`} x1={margin.left} y1={yScale(tick)} x2={width - margin.right} y2={yScale(tick)} stroke="#f0f0f0" strokeWidth="1"/>
                        ))}
                        
                        {/* Zero line */}
                        <line x1={margin.left} y1={yScale(0)} x2={width - margin.right} y2={yScale(0)} stroke="#666" strokeWidth="2" strokeDasharray="5,5"/>
                        
                        {/* Data line */}
                        <path 
                            d={`M ${data.alphaValues.map((alpha, i) => `${xScale(alpha)},${yScale(data.gradients[i])}`).join(' L ')}`}
                            fill="none" 
                            stroke="#2563eb" 
                            strokeWidth="2"
                        />
                        
                        {/* Data points */}
                        {data.alphaValues.map((alpha, index) => {
                            const isSelected = selectedRowIndex === index;
                            return (
                                <circle
                                    key={index}
                                    cx={xScale(alpha)}
                                    cy={yScale(data.gradients[index])}
                                    r={isSelected ? "6" : "4"}
                                    fill={isSelected ? "#FFA500" : "#2563eb"}
                                    stroke={isSelected ? "#FF8C00" : "#1d4ed8"}
                                    strokeWidth="2"
                                    className="cursor-pointer"
                                    style={{pointerEvents: 'all'}}
                                    onClick={() => handlePointClick(index)}
                                >
                                    <title>
                                        {`Index: ${index + 1}
Alpha: ${alpha.toFixed(4)}
eFDR: ${data.fdrValues[index].toFixed(2)}%
Detections: ${data.detectionCounts[index]}
Gradient: ${data.gradients[index].toFixed(1)}
Click to select`}
                                    </title>
                                </circle>
                            );
                        })}
                        
                        {/* Axis ticks and labels */}
                        {xTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={xScale(tick)} y1={height - margin.bottom} x2={xScale(tick)} y2={height - margin.bottom + 5} stroke="#374151"/>
                                <text x={xScale(tick)} y={height - margin.bottom + 15} textAnchor="middle" fontSize="10" fill="#374151">
                                    {tick.toFixed(3)}
                                </text>
                            </g>
                        ))}
                        
                        {yTicks.map((tick, i) => (
                            <g key={i}>
                                <line x1={margin.left - 5} y1={yScale(tick)} x2={margin.left} y2={yScale(tick)} stroke="#374151"/>
                                <text x={margin.left - 10} y={yScale(tick) + 3} textAnchor="end" fontSize="10" fill="#374151">
                                    {tick.toFixed(0)}
                                </text>
                            </g>
                        ))}
                        
                        <text x={(width) / 2} y={height - 5} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500">
                            Alpha
                        </text>
                        <text x={15} y={height / 2} textAnchor="middle" fontSize="12" fill="#374151" fontWeight="500" transform={`rotate(-90, 15, ${height / 2})`}>
                            Detection Gradient
                        </text>
                    </svg>
                </div>
            );
        };

        const FDRResultsDisplay = ({ results, onAlphaSelected, selectedAlpha, onRunSingleAlpha }) => {
            const [selectedIndex, setSelectedIndex] = useState(null);
            const tableRef = useRef(null);
            const rowRefs = useRef([]);

            const handleRowClick = (index) => {
                console.log('🎯 handleRowClick called with index:', index);
                console.log('Alpha value:', results.alphaValues[index]);
                console.log('onRunSingleAlpha exists?', !!onRunSingleAlpha);
                
                setSelectedIndex(index);
                onAlphaSelected(results.alphaValues[index]);
                
                // Run SSVD algorithm for selected alpha
                if (onRunSingleAlpha) {
                    console.log('✅ Calling onRunSingleAlpha with alpha:', results.alphaValues[index]);
                    onRunSingleAlpha(results.alphaValues[index]);
                } else {
                    console.log('❌ onRunSingleAlpha is not defined!');
                }
                
                // Scroll to selected row if needed
                if (rowRefs.current[index]) {
                    rowRefs.current[index].scrollIntoView({
                        behavior: 'smooth',
                        block: 'nearest'
                    });
                }
            };

            // Find optimal alpha (minimum eFDR with reasonable detections)
            const optimalIndex = results.fdrValues.reduce((minIndex, fdr, index) => {
                if (results.detectionCounts[index] > 0 && fdr < results.fdrValues[minIndex]) {
                    return index;
                }
                return minIndex;
            }, 0);

            const formatNumber = (num, decimals = 2) => {
                if (typeof num !== 'number' || isNaN(num)) return 'N/A';
                return num.toFixed(decimals);
            };

            return (
                <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                    <div className="flex items-center justify-between mb-4">
                        <h2 className="text-xl font-semibold">FDR Analysis Results</h2>
                        <div className="text-sm text-gray-500">
                            Click a row to select alpha value
                        </div>
                    </div>

                    {/* Summary Statistics */}
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                        <div className="bg-blue-50 p-3 rounded-lg">
                            <div className="text-sm text-blue-600 font-medium">Alpha Values</div>
                            <div className="text-lg font-bold text-blue-900">{results.alphaValues.length}</div>
                        </div>
                        <div className="bg-purple-50 p-3 rounded-lg">
                            <div className="text-sm text-purple-600 font-medium">Max Detections</div>
                            <div className="text-lg font-bold text-purple-900">{Math.max(...results.detectionCounts)}</div>
                        </div>
                        <div className="bg-orange-50 p-3 rounded-lg">
                            <div className="text-sm text-orange-600 font-medium">Optimal Alpha</div>
                            <div className="text-lg font-bold text-orange-900">{results.alphaValues[optimalIndex].toFixed(4)}</div>
                        </div>
                    </div>

                    {/* Results Table */}
                    <div className="overflow-x-auto" ref={tableRef}>
                        <table className="min-w-full divide-y divide-gray-200">
                            <thead className="bg-gray-50">
                                <tr>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Index
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Alpha
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        eFDR (%)
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Detections
                                    </th>
                                    <th className="px-4 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">
                                        Gradient
                                    </th>
                                </tr>
                            </thead>
                            <tbody className="bg-white divide-y divide-gray-200">
                                {results.alphaValues.map((alpha, index) => {
                                    const isSelected = selectedIndex === index;
                                    const isOptimal = index === optimalIndex;
                                    
                                    return (
                                        <tr 
                                            key={index}
                                            ref={el => rowRefs.current[index] = el}
                                            className={`cursor-pointer transition-all duration-200 ${
                                                isSelected 
                                                    ? 'bg-indigo-100 hover:bg-indigo-200 shadow-md border-l-4 border-indigo-500' 
                                                    : isOptimal 
                                                        ? 'bg-yellow-50 hover:bg-yellow-100' 
                                                        : 'hover:bg-gray-50'
                                            }`}
                                            onClick={() => handleRowClick(index)}
                                        >
                                            <td className="px-4 py-3 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {index + 1}
                                                {isOptimal && <span className="ml-1 text-xs text-yellow-600">★</span>}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900 font-mono">
                                                {alpha.toFixed(4)}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`inline-flex px-2 py-1 rounded-full text-xs font-medium ${
                                                    results.fdrValues[index] <= 5 ? 'bg-green-100 text-green-800' :
                                                    results.fdrValues[index] <= 10 ? 'bg-yellow-100 text-yellow-800' :
                                                    'bg-red-100 text-red-800'
                                                }`}>
                                                    {formatNumber(results.fdrValues[index], 1)}%
                                                </span>
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                {results.detectionCounts[index]}
                                            </td>
                                            <td className="px-4 py-3 whitespace-nowrap text-sm text-gray-900">
                                                <span className={`${
                                                    results.gradients[index] > 0 ? 'text-green-600' : 
                                                    results.gradients[index] < 0 ? 'text-red-600' : 'text-gray-500'
                                                }`}>
                                                    {formatNumber(results.gradients[index], 0)}
                                                </span>
                                            </td>
                                        </tr>
                                    );
                                })}
                            </tbody>
                        </table>
                    </div>

                    {/* Selection Status */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 p-4 bg-indigo-50 rounded-lg">
                            <h3 className="font-medium text-indigo-800 mb-2">Selected Alpha for SSVD-R1 Analysis</h3>
                            <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                                <div>
                                    <span className="text-indigo-600">Alpha:</span>
                                    <span className="font-medium ml-2">{selectedAlpha.toFixed(4)}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">eFDR:</span>
                                    <span className="font-medium ml-2">{formatNumber(results.fdrValues[selectedIndex], 1)}%</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Expected Detections:</span>
                                    <span className="font-medium ml-2">{results.detectionCounts[selectedIndex]}</span>
                                </div>
                                <div>
                                    <span className="text-indigo-600">Index:</span>
                                    <span className="font-medium ml-2">{selectedIndex + 1} / {results.alphaValues.length}</span>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Interactive Analysis Plots */}
                    <div className="mt-6 space-y-6">
                        {/* eFDR vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <FDRChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detections vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <DetectionsChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>

                        {/* Detection Gradient vs Alpha Plot */}
                        <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                            <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                            <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                <GradientChart data={results} selectedRowIndex={selectedIndex} onRowSelect={handleRowClick} />
                            </div>
                        </div>
                    </div>

                    {/* Next Steps */}
                    {selectedAlpha !== null && (
                        <div className="mt-4 bg-green-50 p-4 rounded-lg">
                            <h3 className="font-medium text-green-800 mb-2">Next: Run SSVD-R1 Algorithm</h3>
                            <p className="text-sm text-green-700">
                                Ready to run SSVD-R1 algorithm with selected alpha = {selectedAlpha.toFixed(4)}. 
                                This will perform sparse SVD decomposition and generate visualization results.
                            </p>
                        </div>
                    )}
                </div>
            );
        };

        // Reusable Histogram Component (Line Plot)
        const HistogramChart = ({ data, title, xLabel, yLabel, bins = 64 }) => {
            const createHistogramData = (values, numBins) => {
                if (!values.length) return { labels: [], data: [] };
                
                const min = Math.min(...values);
                const max = Math.max(...values);
                const binWidth = (max - min) / numBins;
                
                const binLabels = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin labels
                for (let i = 0; i < numBins; i++) {
                    const binStart = min + i * binWidth;
                    const binEnd = min + (i + 1) * binWidth;
                    binLabels.push(`${binStart.toFixed(2)}-${binEnd.toFixed(2)}`);
                }
                
                // Count values in each bin
                values.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binLabels, data: binCounts };
            };

            const histogramData = createHistogramData(data, bins);
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: title,
                    data: histogramData.data,
                    borderColor: 'rgba(59, 130, 246, 1)',
                    backgroundColor: 'rgba(59, 130, 246, 0.1)',
                    pointBackgroundColor: 'rgba(59, 130, 246, 1)',
                    pointBorderColor: 'rgba(59, 130, 246, 1)',
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false
                }]
            };

            const options = {
                responsive: true,
                plugins: {
                    title: {
                        display: true,
                        text: title,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: false }
                },
                scales: {
                    x: {
                        title: { display: true, text: xLabel },
                        ticks: { maxRotation: 45 }
                    },
                    y: {
                        title: { display: true, text: yLabel },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm">
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        };

        // Matrix Values Histogram Component (Line Plot with Circle Markers)
        const MatrixHistogram = ({ matrixData, title, color = 'rgba(59, 130, 246, 1)', bins = 64 }) => {
            const createMatrixHistogram = (matrix, numBins) => {
                if (!matrix || !matrix.length) return { labels: [], data: [] };
                
                // Memory-efficient approach for large matrices
                const P = matrix.length;
                const N = matrix[0].length;
                const totalElements = P * N;
                
                // Use sampling for large matrices to avoid memory issues
                const sampleSize = Math.min(10000, totalElements);
                let samples = [];
                let min = Infinity, max = -Infinity;
                
                if (totalElements <= 10000) {
                    // Small matrix: use all values
                    for (let i = 0; i < P; i++) {
                        for (let j = 0; j < N; j++) {
                            const val = matrix[i][j];
                            samples.push(val);
                            if (val < min) min = val;
                            if (val > max) max = val;
                        }
                    }
                } else {
                    // Large matrix: random sampling
                    for (let s = 0; s < sampleSize; s++) {
                        const i = Math.floor(Math.random() * P);
                        const j = Math.floor(Math.random() * N);
                        const val = matrix[i][j];
                        samples.push(val);
                        if (val < min) min = val;
                        if (val > max) max = val;
                    }
                }
                
                if (!samples.length) return { labels: [], data: [] };
                const binWidth = (max - min) / numBins;
                
                const binCenters = [];
                const binCounts = new Array(numBins).fill(0);
                
                // Create bin center labels for better line plot visualization
                for (let i = 0; i < numBins; i++) {
                    const binCenter = min + (i + 0.5) * binWidth;
                    binCenters.push(binCenter.toFixed(4));
                }
                
                // Count values in each bin
                samples.forEach(value => {
                    let binIndex = Math.floor((value - min) / binWidth);
                    if (binIndex >= numBins) binIndex = numBins - 1; // Handle edge case
                    binCounts[binIndex]++;
                });
                
                return { labels: binCenters, data: binCounts };
            };

            const histogramData = createMatrixHistogram(matrixData, bins);
            const totalValues = matrixData ? matrixData.length * matrixData[0].length : 0;
            
            const chartData = {
                labels: histogramData.labels,
                datasets: [{
                    label: `${title} (${totalValues.toLocaleString()} values)`,
                    data: histogramData.data,
                    borderColor: color,
                    backgroundColor: color.replace('1)', '0.2)'),
                    pointBackgroundColor: color,
                    pointBorderColor: color,
                    pointRadius: 3,
                    pointHoverRadius: 5,
                    borderWidth: 2,
                    fill: false,
                    tension: 0.1
                }]
            };

            const options = {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    title: {
                        display: true,
                        text: `${title} Distribution (${bins} bins)`,
                        font: { size: 14, weight: 'bold' }
                    },
                    legend: { display: true },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const binValue = parseFloat(context.label);
                                const count = context.parsed.y;
                                const percentage = ((count / totalValues) * 100).toFixed(2);
                                return [
                                    `Bin center: ${binValue.toFixed(4)}`,
                                    `Count: ${count.toLocaleString()}`,
                                    `Percentage: ${percentage}%`
                                ];
                            }
                        }
                    }
                },
                scales: {
                    x: {
                        title: { display: true, text: 'Matrix Value' },
                        ticks: {
                            maxTicksLimit: 8,
                            callback: function(value, index) {
                                return parseFloat(this.getLabelForValue(value)).toFixed(3);
                            }
                        }
                    },
                    y: {
                        title: { display: true, text: 'Frequency' },
                        beginAtZero: true
                    }
                }
            };

            return (
                <div className="bg-white p-4 rounded-lg shadow-sm" style={{ height: '400px' }}>
                    <canvas ref={canvasRef => {
                        if (canvasRef) {
                            const existingChart = Chart.getChart(canvasRef);
                            if (existingChart) existingChart.destroy();
                            new Chart(canvasRef, { type: 'line', data: chartData, options });
                        }
                    }} />
                </div>
            );
        };

        // Signal/Noise Analysis Component with Interactive Charts
        const SignalNoiseAnalysis = ({ eigenvalues }) => {
            const [selectedBoundary, setSelectedBoundary] = useState(null);
            const [spectralSNR, setSpectralSNR] = useState(null);
            const chartRefs = useRef({ eigenvalue: null, gradient: null, ratio: null });
            
            // Guard against non-array eigenvalues
            if (!Array.isArray(eigenvalues) || eigenvalues.length === 0) {
                return (
                    <div className="bg-white p-4 rounded-lg shadow-sm border-2 border-dashed border-yellow-300">
                        <div className="text-center text-gray-600 py-8">
                            <div className="text-4xl mb-4">⚠️</div>
                            <h3 className="font-medium text-lg mb-2 text-yellow-800">Eigenvalue Analysis Unavailable</h3>
                            <p className="text-sm mb-4">
                                No eigenvalue data available for analysis.
                            </p>
                        </div>
                    </div>
                );
            }

            // Filter and prepare eigenvalues
            const positiveEigenvalues = eigenvalues.filter(val => val > 1e-10);
            
            // Calculate gradients and ratios
            const gradients = [];
            const ratios = [];
            for (let i = 0; i < positiveEigenvalues.length - 1; i++) {
                gradients.push(positiveEigenvalues[i] - positiveEigenvalues[i + 1]);
                ratios.push(positiveEigenvalues[i] / positiveEigenvalues[i + 1]);
            }
            
            // Calculate spectral SNR when boundary is selected
            const calculateSpectralSNR = (boundaryIndex) => {
                if (boundaryIndex === null || boundaryIndex === 0 || boundaryIndex >= positiveEigenvalues.length) {
                    return null;
                }
                const signalEvals = positiveEigenvalues.slice(0, boundaryIndex);
                const noiseEvals = positiveEigenvalues.slice(boundaryIndex);
                const signalSum = signalEvals.reduce((a, b) => a + b, 0);
                const noiseSum = noiseEvals.reduce((a, b) => a + b, 0);
                
                if (noiseSum === 0) return Infinity;
                return 10 * Math.log10(signalSum / noiseSum);
            };

            // Update charts when boundary changes
            useEffect(() => {
                const charts = [];
                
                // Eigenvalue Chart
                if (chartRefs.current.eigenvalue) {
                    const ctx = chartRefs.current.eigenvalue.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: positiveEigenvalues.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Eigenvalue',
                            data: positiveEigenvalues,
                            borderColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            backgroundColor: positiveEigenvalues.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 0.2)' : 'rgba(59, 130, 246, 0.2)'
                            ),
                            pointBackgroundColor: positiveEigenvalues.map((_, i) => 
                                i === selectedBoundary ? 'rgba(239, 68, 68, 1)' : 
                                selectedBoundary !== null && i >= selectedBoundary ? 'rgba(156, 163, 175, 1)' : 'rgba(59, 130, 246, 1)'
                            ),
                            pointRadius: positiveEigenvalues.map((_, i) => i === selectedBoundary ? 6 : 3),
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Spectrum (Click to set boundary)',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Index: ${context.dataIndex + 1}, Eigenvalue: ${context.parsed.y.toFixed(4)}`;
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary,
                                        xMax: selectedBoundary,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Eigenvalue Index' }
                            },
                            y: {
                                title: { display: true, text: 'Eigenvalue Magnitude' },
                                type: 'linear',
                                min: 0
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                setSelectedBoundary(index);
                                const snr = calculateSpectralSNR(index);
                                setSpectralSNR(snr);
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Gradient Chart
                if (chartRefs.current.gradient && gradients.length > 0) {
                    const ctx = chartRefs.current.gradient.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: gradients.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Gradient',
                            data: gradients,
                            borderColor: 'rgba(34, 197, 94, 1)',
                            backgroundColor: 'rgba(34, 197, 94, 0.2)',
                            pointBackgroundColor: gradients.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(34, 197, 94, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Gradient',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const gradient = context.parsed.y;
                                        const eigenval1 = positiveEigenvalues[idx];
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Gradient: ${gradient.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Drop: ${((gradient / eigenval1) * 100).toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Gradient Value' },
                                type: 'linear',
                                min: 0
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Ratio Chart
                if (chartRefs.current.ratio && ratios.length > 0) {
                    const ctx = chartRefs.current.ratio.getContext('2d');
                    const existingChart = Chart.getChart(ctx);
                    if (existingChart) existingChart.destroy();
                    
                    const chartData = {
                        labels: ratios.map((_, i) => i + 1),
                        datasets: [{
                            label: 'Ratio',
                            data: ratios,
                            borderColor: 'rgba(168, 85, 247, 1)',
                            backgroundColor: 'rgba(168, 85, 247, 0.2)',
                            pointBackgroundColor: ratios.map((_, i) => 
                                selectedBoundary !== null && i >= selectedBoundary - 1 ? 'rgba(156, 163, 175, 1)' : 'rgba(168, 85, 247, 1)'
                            ),
                            pointRadius: 3,
                            pointHoverRadius: 7,
                            borderWidth: 1,
                            fill: false
                        }]
                    };
                    
                    const options = {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'point',
                            intersect: true
                        },
                        plugins: {
                            title: {
                                display: true,
                                text: 'Eigenvalue Ratio',
                                font: { size: 14, weight: 'bold' }
                            },
                            legend: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const idx = context.dataIndex;
                                        const ratio = context.parsed.y;
                                        const percentChange = ((1 - (1/ratio)) * 100);
                                        return [
                                            `Index: ${idx + 1}`,
                                            `Ratio: ${ratio.toFixed(4)}`,
                                            `Eigenvalue pair: (${idx + 1}, ${idx + 2})`,
                                            `Change: -${percentChange.toFixed(1)}%`
                                        ];
                                    }
                                }
                            },
                            annotation: selectedBoundary !== null && selectedBoundary > 0 ? {
                                annotations: {
                                    line1: {
                                        type: 'line',
                                        xMin: selectedBoundary - 1,
                                        xMax: selectedBoundary - 1,
                                        borderColor: 'rgba(239, 68, 68, 0.5)',
                                        borderWidth: 2,
                                        borderDash: [5, 5]
                                    }
                                }
                            } : {}
                        },
                        scales: {
                            x: {
                                title: { display: true, text: 'Index' }
                            },
                            y: {
                                title: { display: true, text: 'Ratio Value' },
                                type: 'linear',
                                min: 1
                            }
                        }
                    };
                    
                    const chart = new Chart(ctx, { type: 'line', data: chartData, options });
                    charts.push(chart);
                }
                
                // Cleanup function to destroy charts when component unmounts or updates
                return () => {
                    charts.forEach(chart => {
                        if (chart) chart.destroy();
                    });
                };
            }, [selectedBoundary, positiveEigenvalues.length]); // Simplified dependencies

            return (
                <div className="bg-white p-6 rounded-lg shadow-sm">
                    <h3 className="text-lg font-semibold mb-4">Signal/Noise Subspace Analysis</h3>
                    
                    {/* Charts Stack - Vertical Layout with Increased Size */}
                    <div className="space-y-6 mb-6">
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.eigenvalue = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.gradient = el} style={{height: '300px'}} />
                        </div>
                        <div className="border rounded-lg p-4">
                            <canvas ref={el => chartRefs.current.ratio = el} style={{height: '300px'}} />
                        </div>
                    </div>
                    
                    {/* SNR Results */}
                    {selectedBoundary !== null && (
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4">
                            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Selected Boundary</p>
                                    <p className="text-lg font-bold text-blue-700">Index {selectedBoundary + 1}</p>
                                    <p className="text-xs text-blue-600">First noise eigenvalue</p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Signal Subspace</p>
                                    <p className="text-lg font-bold text-blue-700">Eigenvalues 1-{selectedBoundary}</p>
                                    <p className="text-xs text-blue-600">
                                        Sum: {positiveEigenvalues.slice(0, selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                                <div>
                                    <p className="text-sm font-medium text-blue-900">Spectral SNR</p>
                                    <p className="text-lg font-bold text-blue-700">
                                        {spectralSNR !== null ? 
                                            (isFinite(spectralSNR) ? `${spectralSNR.toFixed(2)} dB` : '∞ dB') : 
                                            'N/A'}
                                    </p>
                                    <p className="text-xs text-blue-600">
                                        Noise sum: {positiveEigenvalues.slice(selectedBoundary).reduce((a, b) => a + b, 0).toFixed(2)}
                                    </p>
                                </div>
                            </div>
                        </div>
                    )}
                    
                    {/* Instructions */}
                    {selectedBoundary === null && (
                        <div className="text-center text-gray-500 text-sm mt-4">
                            <p>Click on any point in the eigenvalue plot to set the signal/noise boundary</p>
                            <p>Hover over points to see detailed values</p>
                        </div>
                    )}
                </div>
            );
        };

        // Keep backward compatibility - alias the old component name
        const EigenvalueSpectrumChart = SignalNoiseAnalysis;

        // Analysis Parameters Display Component
        const AnalysisParametersDisplay = ({ parameters, title = "Analysis Configuration" }) => {
            if (!parameters) return null;
            
            return (
                <div className="bg-gray-50 border border-gray-200 rounded-lg p-4 mb-4">
                    <h3 className="text-sm font-semibold text-gray-700 mb-3">{title}</h3>
                    <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
                        {parameters.analysisType && (
                            <div>
                                <span className="text-gray-500">Analysis Type:</span>
                                <div className="font-medium text-gray-900 capitalize">
                                    {parameters.analysisType === 'efdr' ? 'eFDR Analysis' : 
                                     parameters.analysisType === 'alpha' ? 'Alpha Analysis' : 
                                     'Single Alpha'}
                                </div>
                            </div>
                        )}
                        {parameters.alpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.alpha0 !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Min:</span>
                                <div className="font-medium text-gray-900">{parameters.alpha0.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.alphaMax !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Max:</span>
                                <div className="font-medium text-gray-900">{parameters.alphaMax.toFixed(4)}</div>
                            </div>
                        )}
                        {parameters.Nalpha !== undefined && (
                            <div>
                                <span className="text-gray-500">Alpha Count:</span>
                                <div className="font-medium text-gray-900">{parameters.Nalpha}</div>
                            </div>
                        )}
                        {parameters.Nperm !== undefined && (
                            <div>
                                <span className="text-gray-500">Permutations:</span>
                                <div className="font-medium text-gray-900">{parameters.Nperm}</div>
                            </div>
                        )}
                        {parameters.nsupp !== undefined && (
                            <div>
                                <span className="text-gray-500">Support Size:</span>
                                <div className="font-medium text-gray-900">{parameters.nsupp}</div>
                            </div>
                        )}
                        {parameters.matrixSize && (
                            <div>
                                <span className="text-gray-500">Matrix Size:</span>
                                <div className="font-medium text-gray-900">{parameters.matrixSize}</div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Alpha Sequence Results Display Component
        const AlphaSequenceResultsDisplay = ({ results, selectedIndex, onSelectAlpha, onNewAnalysis, onResetToOriginal, onRunSingleAlpha }) => {
            const [sortConfig, setSortConfig] = useState({ key: null, direction: 'asc' });
            
            // Debug logging
            console.log('AlphaSequenceResultsDisplay rendering with results:', results);
            console.log('Has FDR?', results.hasFDR);
            console.log('First result eFDR:', results.results?.[0]?.eFDR);
            
            // Calculate detection gradients
            const resultsWithGradients = useMemo(() => {
                if (!results.results) {
                    console.error('No results.results array found!');
                    return [];
                }
                const data = results.results.map((r, i) => {
                    let gradient = 0;
                    if (i > 0) {
                        gradient = r.detections - results.results[i-1].detections;
                    }
                    return { ...r, gradient, index: i };
                });
                return data;
            }, [results]);
            
            // Sort function
            const sortedResults = useMemo(() => {
                if (!sortConfig.key) return resultsWithGradients;
                
                return [...resultsWithGradients].sort((a, b) => {
                    let aValue = a[sortConfig.key];
                    let bValue = b[sortConfig.key];
                    
                    if (aValue < bValue) {
                        return sortConfig.direction === 'asc' ? -1 : 1;
                    }
                    if (aValue > bValue) {
                        return sortConfig.direction === 'asc' ? 1 : -1;
                    }
                    return 0;
                });
            }, [resultsWithGradients, sortConfig]);
            
            const handleSort = (key) => {
                setSortConfig(prev => ({
                    key,
                    direction: prev.key === key && prev.direction === 'asc' ? 'desc' : 'asc'
                }));
            };
            
            return (
                <div className="space-y-6">
                    {/* Analysis Parameters */}
                    <AnalysisParametersDisplay 
                        parameters={results.parameters}
                        title="Analysis Configuration"
                    />
                    
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <div>
                                <h2 className="text-2xl font-semibold text-gray-800">
                                    {results.analysisType === 'efdr' ? 'eFDR Analysis Results' : 'Alpha Path Analysis Results'}
                                </h2>
                                <p className="text-sm text-gray-600 mt-1">
                                    Analyzed {results.alphaValues.length} alpha values from {results.alphaValues[0].toFixed(4)} to {results.alphaValues[results.alphaValues.length - 1].toFixed(4)}
                                </p>
                            </div>
                            <div className="flex space-x-3">
                                <button
                                    onClick={onNewAnalysis}
                                    className="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors"
                                >
                                    New Analysis
                                </button>
                                <button
                                    onClick={onResetToOriginal}
                                    className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50 transition-colors"
                                >
                                    Reset Data
                                </button>
                            </div>
                        </div>
                        
                        {/* Summary Statistics */}
                        {results.hasFDR && (
                            <div className="grid grid-cols-3 gap-4 mb-6">
                                <div className="bg-green-50 p-4 rounded-lg">
                                    <div className="text-sm text-green-600 font-medium">Max Detections</div>
                                    <div className="text-2xl font-bold text-green-900">
                                        {Math.max(...results.results.map(r => r.detections))}
                                    </div>
                                </div>
                                <div className="bg-purple-50 p-4 rounded-lg">
                                    <div className="text-sm text-purple-600 font-medium">Total Runs</div>
                                    <div className="text-2xl font-bold text-purple-900">
                                        {results.fdrResults?.totalRuns || results.results.length}
                                    </div>
                                </div>
                                <div className="bg-orange-50 p-4 rounded-lg">
                                    <div className="text-sm text-orange-600 font-medium">Permutations</div>
                                    <div className="text-2xl font-bold text-orange-900">
                                        {results.Nperm || 'N/A'}
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Results Table */}
                        <div className="overflow-x-auto">
                            <table className="min-w-full divide-y divide-gray-200">
                                <thead className="bg-gray-50">
                                    <tr>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('index')}
                                        >
                                            Index {sortConfig.key === 'index' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('alpha')}
                                        >
                                            Alpha {sortConfig.key === 'alpha' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('detections')}
                                        >
                                            Detections {sortConfig.key === 'detections' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        <th 
                                            className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                            onClick={() => handleSort('gradient')}
                                        >
                                            Detection Gradient {sortConfig.key === 'gradient' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                        </th>
                                        {results.hasFDR && (
                                            <th 
                                                className="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider cursor-pointer hover:bg-gray-100"
                                                onClick={() => handleSort('eFDR')}
                                            >
                                                eFDR (%) {sortConfig.key === 'eFDR' && (sortConfig.direction === 'asc' ? '↑' : '↓')}
                                            </th>
                                        )}
                                    </tr>
                                </thead>
                                <tbody className="bg-white divide-y divide-gray-200">
                                    {sortedResults.map((result) => (
                                        <tr 
                                            key={result.index}
                                            className={`hover:bg-gray-50 cursor-pointer ${selectedIndex === result.index ? 'bg-blue-50 border-l-4 border-blue-500' : ''}`}
                                            onClick={() => {
                                                console.log('Row clicked, index:', result.index, 'alpha:', result.alpha);
                                                onSelectAlpha(result.index);
                                                
                                                // Automatically trigger single alpha analysis like SSVD1 app
                                                if (onRunSingleAlpha) {
                                                    console.log('Auto-triggering single alpha analysis for α =', result.alpha);
                                                    onRunSingleAlpha(result.alpha);
                                                }
                                            }}
                                        >
                                            <td className="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900">
                                                {result.index + 1}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.alpha.toFixed(6)}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-700">
                                                {result.detections}
                                            </td>
                                            <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                <span className={`inline-flex items-center ${
                                                    result.gradient > 0 ? 'text-green-600' : 
                                                    result.gradient < 0 ? 'text-red-600' : 
                                                    'text-gray-600'
                                                }`}>
                                                    {result.gradient > 0 && '+'}{result.gradient}
                                                    {result.gradient > 0 && ' ↑'}
                                                    {result.gradient < 0 && ' ↓'}
                                                </span>
                                            </td>
                                            {results.hasFDR && (
                                                <td className="px-6 py-4 whitespace-nowrap text-sm">
                                                    <span className={`font-medium ${
                                                        result.eFDR < 5 ? 'text-green-600' :
                                                        result.eFDR < 10 ? 'text-yellow-600' :
                                                        'text-red-600'
                                                    }`}>
                                                        {typeof result.eFDR === 'number' ? result.eFDR.toFixed(2) : 'N/A'}
                                                    </span>
                                                </td>
                                            )}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                        
                        {/* Selected Alpha Details */}
                        {selectedIndex !== null && resultsWithGradients[selectedIndex] && (
                            <div className="mt-6 p-4 bg-blue-50 rounded-lg">
                                <h3 className="font-medium text-gray-700 mb-2">Selected Alpha Details (Index: {selectedIndex})</h3>
                                <div className="grid grid-cols-3 gap-4 text-sm">
                                    <div>
                                        <span className="text-gray-600">Alpha:</span>
                                        <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].alpha.toFixed(6)}</span>
                                    </div>
                                    <div>
                                        <span className="text-gray-600">Detections:</span>
                                        <span className="ml-2 font-medium">{resultsWithGradients[selectedIndex].detections}</span>
                                    </div>
                                    {results.hasFDR && (
                                        <div>
                                            <span className="text-gray-600">eFDR:</span>
                                            <span className="ml-2 font-medium">{typeof resultsWithGradients[selectedIndex].eFDR === 'number' ? resultsWithGradients[selectedIndex].eFDR.toFixed(2) + '%' : 'N/A'}</span>
                                        </div>
                                    )}
                                </div>
                                <div className="mt-3 text-sm text-gray-600">
                                    <p><strong>💡 Tip:</strong> Click any row to run full SSVD analysis with that alpha value</p>
                                </div>
                            </div>
                        )}

                        {/* Interactive Analysis Plots for Alpha Sequence Results */}
                        {results && results.results && results.results.length > 0 && (
                            <div className="mt-6 space-y-6">
                                {/* eFDR vs Alpha Plot */}
                                {results.hasFDR && (
                                    <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                        <h5 className="font-semibold text-gray-700 mb-3">eFDR vs Alpha</h5>
                                        <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                            <FDRChart 
                                                data={{
                                                    alphaValues: results.results.map(r => r.alpha),
                                                    fdrValues: results.results.map(r => r.eFDR || 0),
                                                    detectionCounts: results.results.map(r => r.detections),
                                                    gradients: results.results.map(r => r.gradient || 0)
                                                }} 
                                                selectedRowIndex={selectedIndex} 
                                                onRowSelect={(index) => {
                                                    onSelectAlpha(index);
                                                    if (onRunSingleAlpha && results.results[index]) {
                                                        onRunSingleAlpha(results.results[index].alpha);
                                                    }
                                                }} 
                                            />
                                        </div>
                                    </div>
                                )}

                                {/* Detections vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detections vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <DetectionsChart 
                                            data={{
                                                alphaValues: results.results.map(r => r.alpha),
                                                fdrValues: results.results.map(r => r.eFDR || 0),
                                                detectionCounts: results.results.map(r => r.detections),
                                                gradients: results.results.map(r => r.gradient || 0)
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>

                                {/* Detection Gradient vs Alpha Plot */}
                                <div className="bg-white border border-gray-200 rounded-lg p-4 mb-6" style={{maxWidth: '800px', margin: '0 auto'}}>
                                    <h5 className="font-semibold text-gray-700 mb-3">Detection Gradient vs Alpha</h5>
                                    <div className="h-80 w-full flex items-center justify-center" style={{overflow: 'hidden', border: '2px solid #e5e7eb', backgroundColor: '#f9fafb'}}>
                                        <GradientChart 
                                            data={{
                                                alphaValues: results.results.map(r => r.alpha),
                                                fdrValues: results.results.map(r => r.eFDR || 0),
                                                detectionCounts: results.results.map(r => r.detections),
                                                gradients: results.results.map(r => r.gradient || 0)
                                            }} 
                                            selectedRowIndex={selectedIndex} 
                                            onRowSelect={(index) => {
                                                onSelectAlpha(index);
                                                if (onRunSingleAlpha && results.results[index]) {
                                                    onRunSingleAlpha(results.results[index].alpha);
                                                }
                                            }} 
                                        />
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        };

        // Analysis Selection Steps Component
        const AnalysisSelectionSteps = ({ analysisStep, onStepSelect, onBackToReview }) => {
            if (!analysisStep) {
                // Step 1: Single vs Multi Alpha
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Analysis Type</h2>
                            <button
                                onClick={onBackToReview}
                                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                            >
                                ← Back to Data Review
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('single')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-blue-500 hover:bg-blue-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Single Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Run SSVD with one specific alpha value to get detailed results and visualizations
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('multi')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-purple-500 hover:bg-purple-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Multi-Alpha Analysis</div>
                                <div className="text-sm text-gray-600">
                                    Test multiple alpha values systematically to find optimal sparsity parameters
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            if (analysisStep === 'multi') {
                // Step 2: Alpha Analysis vs eFDR Analysis
                return (
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-semibold">Choose Multi-Alpha Analysis Type</h2>
                            <button
                                onClick={() => onStepSelect(null)}
                                className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                            >
                                ← Back to Analysis Type
                            </button>
                        </div>
                        
                        <div className="grid grid-cols-2 gap-6">
                            <button
                                onClick={() => onStepSelect('alpha')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-indigo-500 hover:bg-indigo-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">Without Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(Alpha Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Test alpha sequence without permutations - faster analysis for alpha path exploration
                                </div>
                            </button>
                            <button
                                onClick={() => onStepSelect('efdr')}
                                className="p-6 border-2 border-gray-300 rounded-lg hover:border-yellow-500 hover:bg-yellow-50 transition-all"
                            >
                                <div className="font-semibold text-lg mb-2">With Permutations</div>
                                <div className="text-xs text-gray-500 mb-2">(eFDR Analysis)</div>
                                <div className="text-sm text-gray-600">
                                    Include permutation testing for empirical False Discovery Rate analysis
                                </div>
                            </button>
                        </div>
                    </div>
                );
            }
            
            return null; // This will be replaced by parameter collection UIs
        };

        // Matrix Data Review Component
        const MatrixDataReview = ({ matrix, matrixInfo, statistics, onProceedToAnalysis }) => {
            return (
                <div className="space-y-6">
                    {/* Basic Matrix Overview */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Matrix Overview</h2>
                        <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                <div className="text-2xl font-bold text-blue-900">{statistics.P} × {statistics.N}</div>
                                <div className="text-xs text-blue-600 mt-1">Features × Samples</div>
                            </div>
                            <div className="bg-green-50 p-4 rounded-lg">
                                <div className="text-sm text-green-600 font-medium">Range</div>
                                <div className="text-lg font-bold text-green-900">[{statistics.min.toFixed(2)}, {statistics.max.toFixed(2)}]</div>
                                <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg">
                                <div className="text-sm text-purple-600 font-medium">Overall Mean</div>
                                <div className="text-lg font-bold text-purple-900">{statistics.mean.toFixed(3)}</div>
                                <div className="text-xs text-purple-600 mt-1">All elements</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg">
                                <div className="text-sm text-orange-600 font-medium">Overall Std Dev</div>
                                <div className="text-lg font-bold text-orange-900">{statistics.stdDev.toFixed(3)}</div>
                                <div className="text-xs text-orange-600 mt-1">All elements</div>
                            </div>
                        </div>
                    </div>

                    {/* Row Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Row Statistics (across samples)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.rowMeans} 
                                title="Row Means Distribution"
                                xLabel="Mean Value"
                                yLabel="Frequency"
                                bins={15}
                            />
                            <HistogramChart 
                                data={statistics.rowStdDevs}
                                title="Row Std Devs Distribution" 
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={15}
                            />
                        </div>
                    </div>

                    {/* Column Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Column Statistics (across features)</h2>
                        <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                            <HistogramChart 
                                data={statistics.columnMeans}
                                title="Column Means Distribution"
                                xLabel="Mean Value" 
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                            <HistogramChart 
                                data={statistics.columnStdDevs}
                                title="Column Std Devs Distribution"
                                xLabel="Standard Deviation"
                                yLabel="Frequency"
                                bins={Math.min(15, Math.floor(statistics.N / 2))}
                            />
                        </div>
                    </div>

                    {/* Matrix Values Histogram */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Matrix Values Distribution</h2>
                        <MatrixHistogram 
                            matrixData={matrix}
                            title="Original Matrix Values"
                            color="rgba(59, 130, 246, 1)"
                            bins={64}
                        />
                    </div>


                    {/* Proceed to Analysis Button */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <p className="text-gray-600 mb-4">
                            Review the histograms of the data matrix to verify that a properly preprocessed data set has been uploaded to the SSVD application. When ready, click on "Proceed to Analysis" to select analysis type.
                        </p>
                        <button
                            className="px-6 py-3 bg-indigo-600 text-white rounded-md font-medium hover:bg-indigo-700 transition-colors"
                            onClick={() => onProceedToAnalysis()}
                        >
                            Proceed to Analysis
                        </button>
                    </div>
                </div>
            );
        };

        // Data Preprocessing Section Component
        const DataPreprocessingSection = ({ 
            originalMatrix, 
            originalStatistics, 
            onPreprocessingComplete,
            onSkipPreprocessing,
            onProceedToAnalysis
        }) => {
            const [isProcessing, setIsProcessing] = useState(false);
            const [preprocessingResults, setPreprocessingResults] = useState(null);
            const [showPreprocessedStats, setShowPreprocessedStats] = useState(false);

            const handleApplyPreprocessing = async () => {
                setIsProcessing(true);
                
                // Small delay for UI responsiveness
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    // Apply preprocessing
                    const results = preprocessMatrix(originalMatrix);
                    
                    // Calculate statistics for preprocessed matrix
                    const preprocessedStats = calculateMatrixStatistics(results.preprocessedMatrix);
                    
                    // Calculate eigenvalues for preprocessed matrix
                    const preprocessedEigenvalues = calculateEigenvalueSpectrum(results.preprocessedMatrix);
                    
                    setPreprocessingResults({
                        ...results,
                        statistics: preprocessedStats,
                        eigenvalues: preprocessedEigenvalues
                    });
                    
                    setShowPreprocessedStats(true);
                    
                    // Notify parent component
                    onPreprocessingComplete(
                        results.preprocessedMatrix,
                        preprocessedStats,
                        preprocessedEigenvalues,
                        results
                    );
                } catch (error) {
                    console.error('Preprocessing failed:', error);
                    alert(`Preprocessing failed: ${error.message}`);
                } finally {
                    setIsProcessing(false);
                }
            };

            return (
                <div className="space-y-6">
                    {/* Preprocessing Control Panel */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <h2 className="text-xl font-semibold mb-4">Data Pre-Processing</h2>
                        
                        <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-6">
                            <h3 className="font-semibold text-blue-900 mb-2">Pre-Processing Operations</h3>
                            <div className="space-y-2 text-sm text-blue-800">
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">1.</span>
                                    <div>
                                        <span className="font-semibold">Frobenius Normalization:</span>
                                        <span className="ml-2">Divide each matrix element by the Frobenius norm (||X||<sub>F</sub>)</span>
                                    </div>
                                </div>
                                <div className="flex items-start">
                                    <span className="font-mono bg-blue-100 px-2 py-1 rounded mr-2">2.</span>
                                    <div>
                                        <span className="font-semibold">Row Centering:</span>
                                        <span className="ml-2">Subtract row mean from each element to achieve zero-mean rows</span>
                                    </div>
                                </div>
                                <div className="mt-3 p-2 bg-white rounded border border-blue-300">
                                    <span className="font-mono text-xs">
                                        X<sub>processed</sub>[i,j] = (X[i,j] / ||X||<sub>F</sub>) - mean(row<sub>i</sub>)
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div className="flex gap-4">
                            <button
                                onClick={handleApplyPreprocessing}
                                disabled={isProcessing || preprocessingResults !== null}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isProcessing || preprocessingResults !== null
                                        ? 'bg-gray-300 text-gray-500 cursor-not-allowed'
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isProcessing ? (
                                    <span className="flex items-center">
                                        <span className="animate-spin rounded-full h-4 w-4 border-b-2 border-white mr-2"></span>
                                        Processing...
                                    </span>
                                ) : preprocessingResults ? (
                                    '✓ Pre-Processing Applied'
                                ) : (
                                    'Apply Pre-Processing'
                                )}
                            </button>
                            
                            <button
                                onClick={onSkipPreprocessing}
                                disabled={isProcessing}
                                className="px-6 py-3 border border-gray-300 text-gray-700 rounded-md font-medium hover:bg-gray-50 transition-colors"
                            >
                                Skip Pre-Processing
                            </button>
                        </div>

                        {preprocessingResults && (
                            <div className="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg">
                                <h4 className="font-semibold text-green-900 mb-2">Pre-Processing Complete</h4>
                                <div className="grid grid-cols-2 gap-4 text-sm text-green-800">
                                    <div>
                                        <span className="font-medium">Original Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormOriginal.toFixed(4)}</span>
                                    </div>
                                    <div>
                                        <span className="font-medium">Processed Frobenius Norm:</span>
                                        <span className="ml-2">{preprocessingResults.frobeniusNormProcessed.toFixed(4)}</span>
                                    </div>
                                </div>
                            </div>
                        )}
                    </div>

                    {/* Preprocessed Data Statistics */}
                    {showPreprocessedStats && preprocessingResults && (
                        <>
                            {/* Basic Matrix Overview */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Matrix Overview</h2>
                                <div className="grid grid-cols-2 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">
                                            {preprocessingResults.statistics.P} × {preprocessingResults.statistics.N}
                                        </div>
                                        <div className="text-xs text-blue-600 mt-1">Features × Samples</div>
                                    </div>
                                    <div className="bg-green-50 p-4 rounded-lg">
                                        <div className="text-sm text-green-600 font-medium">Range</div>
                                        <div className="text-lg font-bold text-green-900">
                                            [{preprocessingResults.statistics.min.toFixed(3)}, {preprocessingResults.statistics.max.toFixed(3)}]
                                        </div>
                                        <div className="text-xs text-green-600 mt-1">Min, Max values</div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">Overall Mean</div>
                                        <div className="text-lg font-bold text-purple-900">
                                            {preprocessingResults.statistics.mean.toExponential(2)}
                                        </div>
                                        <div className="text-xs text-purple-600 mt-1">Should be ≈0</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Overall Std Dev</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {preprocessingResults.statistics.stdDev.toFixed(4)}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">Normalized scale</div>
                                    </div>
                                </div>
                            </div>

                            {/* Row Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Row Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowMeans} 
                                        title="Row Means Distribution (should be ~0)"
                                        xLabel="Mean Value"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.rowStdDevs}
                                        title="Row Std Devs Distribution" 
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={15}
                                    />
                                </div>
                            </div>

                            {/* Column Statistics */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Column Statistics</h2>
                                <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnMeans}
                                        title="Column Means Distribution"
                                        xLabel="Mean Value" 
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                    <HistogramChart 
                                        data={preprocessingResults.statistics.columnStdDevs}
                                        title="Column Std Devs Distribution"
                                        xLabel="Standard Deviation"
                                        yLabel="Frequency"
                                        bins={Math.min(15, Math.floor(preprocessingResults.statistics.N / 2))}
                                    />
                                </div>
                            </div>

                            {/* Preprocessed Matrix Values Histogram */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Matrix Values Distribution</h2>
                                <MatrixHistogram 
                                    matrixData={preprocessingResults.preprocessedMatrix}
                                    title="Preprocessed Matrix Values"
                                    color="rgba(34, 197, 94, 1)"
                                    bins={64}
                                />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> After Frobenius normalization and row centering, the matrix values 
                                    should show a more centered distribution with normalized scale.</p>
                                </div>
                            </div>

                            {/* Eigenvalue Spectrum */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessed Eigenvalue Analysis</h2>
                                <SignalNoiseAnalysis eigenvalues={preprocessingResults.eigenvalues} />
                                <div className="mt-4 text-sm text-gray-600">
                                    <p><strong>Note:</strong> Preprocessing typically changes the eigenvalue spectrum. 
                                    The signal/noise boundary may be clearer after normalization and centering.</p>
                                </div>
                            </div>

                            {/* Continue Button */}
                            <div className="bg-white rounded-lg shadow-md p-6">
                                <h2 className="text-xl font-semibold mb-4">Preprocessing Complete</h2>
                                <p className="text-gray-600 mb-4">
                                    Data has been successfully preprocessed. The Frobenius-normalized and row-centered matrix 
                                    will be used for all subsequent analyses.
                                </p>
                                <button
                                    className="px-6 py-3 bg-green-600 text-white rounded-md font-medium hover:bg-green-700 transition-colors"
                                    onClick={onProceedToAnalysis}
                                >
                                    ✓ Continue with Preprocessed Data
                                </button>
                            </div>
                        </>
                    )}
                </div>
            );
        };

        // Analysis Configuration Panel Component
        const AnalysisConfigurationPanel = ({ matrix, matrixInfo, analysisStep, onStartAnalysis, onCancel }) => {
            const [analysisMode, setAnalysisMode] = useState('single'); // 'single' or 'multi'
            const [analysisType, setAnalysisType] = useState('alpha'); // 'alpha' or 'efdr'
            const [singleAlpha, setSingleAlpha] = useState(null);
            const [singleAlphaText, setSingleAlphaText] = useState(''); // Separate text state - start blank
            const [Nalpha, setNalpha] = useState(35);
            const [minAlpha, setMinAlpha] = useState(0);
            const [alphaMaxMultiplier, setAlphaMaxMultiplier] = useState(0.75);
            const [Nperm, setNperm] = useState(25);
            const [sprcnt, setSprcnt] = useState(5); // Support percentage (default 5%)
            const [alphaMax, setAlphaMax] = useState(null);
            const [isCalculating, setIsCalculating] = useState(false);
            
            // Use pre-calculated alphaMax from matrixInfo and apply multiplier
            useEffect(() => {
                if (matrixInfo && matrixInfo.alphaMax) {
                    const adjustedAlphaMax = matrixInfo.alphaMax * (alphaMaxMultiplier / 0.75);
                    setAlphaMax(adjustedAlphaMax);
                    
                    // Don't auto-populate alpha - user requested blank initialization
                    console.log(`AlphaMax adjusted: base=${matrixInfo.alphaMax.toFixed(6)}, multiplier=${alphaMaxMultiplier}, result=${adjustedAlphaMax.toFixed(6)}`);
                }
            }, [matrixInfo, alphaMaxMultiplier]);
            
            const nsupp = useMemo(() => {
                // nsupp = 0.01 * sprcnt * P
                return Math.round(0.01 * sprcnt * (matrixInfo?.P || 1000));
            }, [sprcnt, matrixInfo]);
            
            const handleStartAnalysis = () => {
                if (analysisStep === 'single') {
                    // Single alpha analysis
                    const config = {
                        analysisMode: 'single',
                        alpha: singleAlpha,
                        alphaMax
                    };
                    console.log('Starting single alpha analysis with config:', config);
                    console.log('singleAlpha value:', singleAlpha);
                    onStartAnalysis(config);
                } else if (analysisStep === 'alpha' || analysisStep === 'efdr') {
                    // Multi-alpha analysis
                    if (!alphaMax) {
                        alert('AlphaMax calculation is still in progress. Please wait.');
                        return;
                    }
                    
                    const config = {
                        analysisMode: 'multi',
                        analysisType: analysisStep, // Use analysisStep directly
                        Nalpha,
                        alphaMax,
                        alphaMaxMultiplier,
                        alpha0: minAlpha,
                        nsupp,
                        sprcnt,
                        ...(analysisStep === 'efdr' && { Nperm })
                    };
                    
                    onStartAnalysis(config);
                }
            };
            
            return (
                <div className="space-y-6">
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="border-b pb-4 mb-6">
                            <div className="flex justify-between items-center mb-2">
                                <h1 className="text-2xl font-bold text-gray-800">Single-Alpha SSVD Analysis</h1>
                                <div className="flex space-x-2">
                                    <button
                                        onClick={onCancel}
                                        className="px-4 py-2 border border-gray-300 text-gray-700 rounded-md hover:bg-gray-50"
                                    >
                                        ← Back to Analysis Type
                                    </button>
                                    <button
                                        onClick={() => window.location.reload()}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md hover:bg-red-700"
                                    >
                                        Reset
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        
                        {/* Single Alpha Configuration */}
                        {analysisStep === 'single' && (
                            <div className="mb-6 p-4 bg-blue-50 rounded-lg">
                                <h3 className="font-medium text-gray-700 mb-3">Single Alpha Parameters</h3>
                                <div className="grid grid-cols-2 gap-6">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Alpha Value (Sparsity Parameter)
                                        </label>
                                        <div className="space-y-2">
                                            <input
                                                type="text"
                                                value={singleAlphaText}
                                                onChange={(e) => {
                                                    const inputValue = e.target.value;
                                                    console.log('Alpha input raw value:', inputValue);
                                                    setSingleAlphaText(inputValue);
                                                    
                                                    // Try to parse as number
                                                    const numValue = parseFloat(inputValue);
                                                    if (!isNaN(numValue) && numValue >= 0) {
                                                        setSingleAlpha(numValue);
                                                    }
                                                }}
                                                onBlur={() => {
                                                    // On blur, ensure text matches the numeric value
                                                    if (singleAlpha !== null) {
                                                        setSingleAlphaText(singleAlpha.toString());
                                                    } else if (singleAlphaText === '') {
                                                        // Keep it blank if no value entered
                                                        setSingleAlphaText('');
                                                    }
                                                }}
                                                className="w-full px-3 py-2 border-2 border-blue-300 rounded-md text-lg font-semibold focus:border-blue-500 focus:ring-2 focus:ring-blue-200"
                                                placeholder="Enter alpha value"
                                            />
                                            <p className="text-xs text-gray-600 mt-2">
                                                Higher alpha ⟹ Greater sparsity (fewer detections)
                                            </p>
                                        </div>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Maximum Alpha (Zero Detection Threshold)
                                        </label>
                                        <div className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
                                            {isCalculating ? (
                                                <span className="text-gray-500">Calculating...</span>
                                            ) : (
                                                <span className="text-lg font-semibold text-gray-900">
                                                    {alphaMax ? alphaMax.toFixed(6) : 'N/A'}
                                                </span>
                                            )}
                                        </div>
                                        <p className="text-xs text-gray-600 mt-2">
                                            Alpha values above this threshold are likely to result in zero detections
                                        </p>
                                    </div>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Configuration */}
                        {(analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <>
                                {/* Alpha Sequence Configuration */}
                                <div className="grid grid-cols-2 gap-6 mb-6">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Number of Alphas (nAlpha)
                                        </label>
                                        <input
                                            type="number"
                                            min="5"
                                            max="75"
                                            value={Nalpha}
                                            onChange={(e) => setNalpha(parseInt(e.target.value) || 35)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Number of alpha values to test (5-75)
                                        </p>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Minimum Alpha
                                        </label>
                                        <input
                                            type="number"
                                            min="0"
                                            max="1"
                                            step="0.01"
                                            value={minAlpha}
                                            onChange={(e) => setMinAlpha(parseFloat(e.target.value) || 0)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Starting alpha value (typically 0)
                                        </p>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            AlphaMax Multiplier
                                        </label>
                                        <input
                                            type="number"
                                            min="0.1"
                                            max="3.0"
                                            step="0.05"
                                            value={alphaMaxMultiplier}
                                            onChange={(e) => setAlphaMaxMultiplier(parseFloat(e.target.value) || 0.75)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Scaling factor for maximum alpha
                                        </p>
                                    </div>
                                    
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 mb-2">
                                            Support Percentage (sprcnt)
                                        </label>
                                        <input
                                            type="number"
                                            min="1"
                                            max="50"
                                            step="1"
                                            value={sprcnt}
                                            onChange={(e) => setSprcnt(parseFloat(e.target.value) || 5)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                        />
                                        <p className="text-xs text-gray-500 mt-1">
                                            Expected signal percentage (default 5%)
                                        </p>
                                    </div>
                                </div>
                                
                                {/* eFDR Specific Parameters */}
                                {analysisStep === 'efdr' && (
                                    <div className="p-4 bg-yellow-50 rounded-lg mb-6">
                                        <h4 className="font-medium text-gray-700 mb-3">eFDR Analysis Parameters</h4>
                                        <div className="grid grid-cols-2 gap-6">
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                                    Number of Permutations (Nperm)
                                                </label>
                                                <input
                                                    type="number"
                                                    min="10"
                                                    max="100"
                                                    value={Nperm}
                                                    onChange={(e) => setNperm(parseInt(e.target.value) || 25)}
                                                    className="w-full px-3 py-2 border border-gray-300 rounded-md"
                                                />
                                                <p className="text-xs text-gray-500 mt-1">
                                                    Default: 25 permutations
                                                </p>
                                            </div>
                                            
                                            <div>
                                                <label className="block text-sm font-medium text-gray-700 mb-2">
                                                    Estimated Support Size (nsupp)
                                                </label>
                                                <div className="w-full px-3 py-2 bg-white border border-gray-300 rounded-md">
                                                    <span className="font-medium">{nsupp}</span>
                                                </div>
                                                <p className="text-xs text-gray-500 mt-1">
                                                    0.01 × sprcnt × P = 0.01 × {sprcnt} × {matrixInfo?.P || '?'}
                                                </p>
                                            </div>
                                        </div>
                                        
                                        <div className="mt-3">
                                            <div className="flex items-center text-yellow-700">
                                                <span className="text-xl mr-2">⚠️</span>
                                                <span className="text-sm">
                                                    eFDR analysis will run {Nalpha * (1 + Nperm)} SSVD iterations.
                                                    This may take several minutes.
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                )}
                            </>
                        )}
                        
                        {/* Action Buttons */}
                        <div className="flex justify-end">
                            <button
                                onClick={handleStartAnalysis}
                                disabled={isCalculating || (analysisMode === 'multi' && !alphaMax) || (analysisMode === 'single' && (singleAlpha === null || singleAlpha === undefined))}
                                className={`px-6 py-3 rounded-md font-medium transition-colors ${
                                    isCalculating || (analysisMode === 'multi' && !alphaMax) || (analysisMode === 'single' && (singleAlpha === null || singleAlpha === undefined))
                                        ? 'bg-gray-400 text-gray-200 cursor-not-allowed' 
                                        : 'bg-indigo-600 text-white hover:bg-indigo-700'
                                }`}
                            >
                                {isCalculating ? 'Calculating AlphaMax...' : 
                                 analysisMode === 'single' ? 'Run Analysis' : 
                                 'Start Alpha Sequence Analysis'}
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        // SSVD Results Display Components
        const SSVDResultsDisplay = ({ results, matrixInfo, onNewAnalysis, onResetToOriginal, onRerunWithAlpha }) => {
            if (!results) return null;
            
            return (
                <div className="space-y-6 mt-6">
                    {/* Summary Statistics */}
                    <div className="bg-white rounded-lg shadow-md p-6">
                        <div className="mb-4">
                            <h2 className="text-xl font-semibold">Summary of Results</h2>
                        </div>
                        <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
                            <div className="bg-blue-50 p-4 rounded-lg">
                                <div className="text-sm text-blue-600 font-medium">Alpha Value</div>
                                <div className="text-2xl font-bold text-blue-900">{results.alpha.toFixed(4)}</div>
                                <div className="text-xs text-blue-600">sparsity parameter</div>
                            </div>
                            <div className="bg-green-50 p-4 rounded-lg">
                                <div className="text-sm text-green-600 font-medium">Detections</div>
                                <div className="text-2xl font-bold text-green-900">{results.detections}</div>
                                <div className="text-xs text-green-600">out of {results.u.length}</div>
                            </div>
                            <div className="bg-purple-50 p-4 rounded-lg">
                                <div className="text-sm text-purple-600 font-medium">Sparsity</div>
                                <div className="text-2xl font-bold text-purple-900">{results.sparsity}%</div>
                                <div className="text-xs text-purple-600">of elements zeroed</div>
                            </div>
                            <div className="bg-orange-50 p-4 rounded-lg">
                                <div className="text-sm text-orange-600 font-medium">Iterations</div>
                                <div className="text-2xl font-bold text-orange-900">{results.iterations || 'N/A'}</div>
                                <div className="text-xs text-orange-600">{results.converged ? 'Converged' : 'Max iterations reached'}</div>
                            </div>
                        </div>
                    </div>
                    
                    {/* U1 Vector Visualization */}
                    <U1VectorPlot u={results.u} alpha={results.alpha} />
                    
                    {/* V1 Vector Visualization */}
                    <V1VectorPlot v={results.v} s={results.s} />
                </div>
            );
        };
        
        // U1 Vector Scatter Plot Component
        const U1VectorPlot = ({ u, alpha }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || !u) return;
                
                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                
                // Prepare data for scatter plot
                const data = u.map((val, idx) => ({
                    x: idx + 1,
                    y: val
                }));
                
                // Separate detected and undetected points
                const detectedPoints = data.filter(p => Math.abs(p.y) > 1e-10);
                const undetectedPoints = data.filter(p => Math.abs(p.y) <= 1e-10);
                
                chartRef.current = new Chart(canvasRef.current, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: `Detected (${detectedPoints.length})`,
                                data: detectedPoints,
                                backgroundColor: 'rgba(34, 197, 94, 0.6)',
                                borderColor: 'rgba(34, 197, 94, 1)',
                                pointRadius: 4
                            },
                            {
                                label: `Undetected (${undetectedPoints.length})`,
                                data: undetectedPoints,
                                backgroundColor: 'rgba(156, 163, 175, 0.3)',
                                borderColor: 'rgba(156, 163, 175, 0.5)',
                                pointRadius: 2
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: `U1 Vector - Sparse Biomarker Detection (α = ${alpha.toFixed(4)})`
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Row Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'U1 Value'
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [u, alpha]);
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Sparse Left-Singular Vector U1</h3>
                    <div className="h-80">
                        <canvas ref={canvasRef}></canvas>
                    </div>
                </div>
            );
        };
        
        // V1 Vector Line Plot Component
        const V1VectorPlot = ({ v, s }) => {
            const canvasRef = useRef(null);
            const chartRef = useRef(null);
            
            useEffect(() => {
                if (!canvasRef.current || !v) return;
                
                // Destroy existing chart
                if (chartRef.current) {
                    chartRef.current.destroy();
                }
                
                chartRef.current = new Chart(canvasRef.current, {
                    type: 'line',
                    data: {
                        labels: v.map((_, idx) => idx + 1),
                        datasets: [{
                            label: `V1 Vector (σ = ${s.toFixed(4)})`,
                            data: v,
                            borderColor: 'rgba(59, 130, 246, 1)',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            borderWidth: 2,
                            pointRadius: 2,
                            pointHoverRadius: 4,
                            tension: 0.2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: {
                                display: true,
                                text: 'Dense Right-Singular Vector V1 Supported by U1'
                            },
                            legend: {
                                display: true
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'Sample Index'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'V1 Value'
                                }
                            }
                        }
                    }
                });
                
                return () => {
                    if (chartRef.current) {
                        chartRef.current.destroy();
                    }
                };
            }, [v, s]);
            
            return (
                <div className="bg-white rounded-lg shadow-md p-6">
                    <h3 className="text-lg font-semibold mb-4">Dense Right-Singular Vector V1 Supported by U1</h3>
                    <div className="h-80">
                        <canvas ref={canvasRef}></canvas>
                    </div>
                </div>
            );
        };
        
        const App = () => {
            // Original data state
            const [originalMatrix, setOriginalMatrix] = useState(null);
            const [originalMatrixInfo, setOriginalMatrixInfo] = useState(null);
            const [originalStatistics, setOriginalStatistics] = useState(null);
            const [originalEigenvalues, setOriginalEigenvalues] = useState(null);
            
            // Working data state (can be original or preprocessed)
            const [matrix, setMatrix] = useState(null);
            const [matrixInfo, setMatrixInfo] = useState(null);
            const [statistics, setStatistics] = useState(null);
            const [eigenvalues, setEigenvalues] = useState(null);
            
            // Processing state
            // Preprocessing state removed
            
            // Analysis state
            const [fdrResults, setFDRResults] = useState(null);
            const [selectedAlpha, setSelectedAlpha] = useState(null);
            const [ssvdResults, setSSVDResults] = useState(null);
            const [showAnalysisPanel, setShowAnalysisPanel] = useState(false);
            const [analysisStep, setAnalysisStep] = useState(null); // null, 'single', 'multi', 'alpha', 'efdr'

            const handleDataLoaded = (newMatrix, newMatrixInfo) => {
                // Calculate SVD once for this matrix
                console.log('Calculating initial SVD for matrix...');
                const svdResult = svd1Sync(newMatrix);
                
                // Calculate alphaMax using the SVD result
                console.log('Calculating alphaMax from SVD...');
                const maxAbsU1 = Math.max(...svdResult.u.map(val => Math.abs(val)));
                const calculatedAlphaMax = 0.75 * maxAbsU1 * svdResult.s;
                
                // Add SVD results and alphaMax to matrixInfo
                const enrichedMatrixInfo = {
                    ...newMatrixInfo,
                    alphaMax: calculatedAlphaMax,
                    initialSVD: svdResult  // Cache the SVD for reuse
                };
                
                // Store both as original and working data
                setOriginalMatrix(newMatrix);
                setOriginalMatrixInfo(enrichedMatrixInfo);
                setMatrix(newMatrix);
                setMatrixInfo(enrichedMatrixInfo);
                
                // Calculate statistics for data review
                console.log('Calculating matrix statistics...');
                const stats = calculateMatrixStatistics(newMatrix);
                setOriginalStatistics(stats);
                setStatistics(stats);
                
                // Eigenvalue computation moved to external preprocessing
                console.log('Skipping eigenvalue computation for large matrix performance');
                setOriginalEigenvalues([]);
                setEigenvalues([]);
                
                console.log(`Data loaded: ${enrichedMatrixInfo.P}×${enrichedMatrixInfo.N} matrix, alphaMax: ${calculatedAlphaMax.toFixed(6)}`);
            };

            const resetData = () => {
                console.log('Reset button clicked - clearing all data and results');
                
                // Reset original data
                setOriginalMatrix(null);
                setOriginalMatrixInfo(null);
                setOriginalStatistics(null);
                setOriginalEigenvalues(null);
                
                // Reset working data
                setMatrix(null);
                setMatrixInfo(null);
                setStatistics(null);
                setEigenvalues(null);
                
                // Reset ALL analysis state and results
                setFDRResults(null);
                setSelectedAlpha(null);
                setSSVDResults(null);
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                // Scroll to top to show upload page
                window.scrollTo({ top: 0, behavior: 'smooth' });
                
                console.log('All data and results cleared - returning to upload page');
            };
            
            const handleProceedToAnalysis = () => {
                // Clear any analysis results and start stepped selection
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setAnalysisStep(null); // Start at step 1: Single vs Multi
                setShowAnalysisPanel(true);
                
                // Smooth scroll to analysis section
                setTimeout(() => {
                    window.scrollTo({
                        top: document.documentElement.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 100);
            };
            
            const handleAnalysisStepSelect = (step) => {
                setAnalysisStep(step);
            };
            
            const handleBackToDataReview = () => {
                setShowAnalysisPanel(false);
                setAnalysisStep(null);
            };
            
            
            const handleResetToOriginalData = () => {
                // Reset to original data
                setMatrix(originalMatrix);
                setMatrixInfo(originalMatrixInfo);
                setStatistics(originalStatistics);
                setEigenvalues(originalEigenvalues);
                
                // Clear ALL analysis results and go back to data review
                setAnalysisResults(null);
                setAlphaSequenceResults(null);
                setFDRResults(null);
                setSelectedAlpha(null);
                setSelectedAlphaIndex(null);
                setAnalysisStep(null);
                setShowAnalysisPanel(false);
                
                console.log('Reset to original data for analysis');
            };
            
            const handleRerunWithAlpha = async (newAlpha) => {
                try {
                    console.log(`Re-running SSVD with alpha=${newAlpha}`);
                    const results = await runSingleAlphaAnalysis(newAlpha);
                    setAnalysisResults(results);
                    console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity`);
                } catch (error) {
                    console.error('Re-run failed:', error);
                    alert(`Failed to re-run analysis: ${error.message}`);
                }
            };
            
            const handleCancelAnalysis = () => {
                setShowAnalysisPanel(false);
            };
            
            const [isRunningAnalysis, setIsRunningAnalysis] = useState(false);
            const [analysisProgress, setAnalysisProgress] = useState({ current: 0, total: 0, message: '' });
            const [isAnalysisCancelled, setIsAnalysisCancelled] = useState(false);
            const [analysisResults, setAnalysisResults] = useState(null);
            const [alphaSequenceResults, setAlphaSequenceResults] = useState(null);
            const [selectedAlphaIndex, setSelectedAlphaIndex] = useState(null);
            
            const runSingleAlphaAnalysis = async (alpha) => {
                console.log(`Running SSVD with alpha=${alpha}, using cached SVD: ${matrixInfo?.initialSVD ? 'yes' : 'no'}`);
                const results = await SSVDR1Algorithm({
                    matrix: matrix,
                    alpha: alpha,
                    maxIter: 5000,
                    tolerance: 0.0001,
                    initialSVD: matrixInfo?.initialSVD  // Pass cached SVD
                });
                
                // Calculate summary statistics
                const detections = results.u.filter(val => Math.abs(val) > 1e-10).length;
                const sparsity = ((matrix.length - detections) / matrix.length * 100).toFixed(1);
                
                return {
                    mode: 'single',
                    alpha: alpha,
                    u: results.u,
                    v: results.v,
                    s: results.s,
                    detections: detections,
                    sparsity: sparsity,
                    iterations: results.iterations,
                    converged: results.converged,
                    convergenceInfo: results.convergenceInfo,
                    parameters: {
                        analysisType: 'single',
                        alpha: alpha,
                        matrixSize: `${matrix.length} × ${matrix[0].length}`
                    }
                };
            };
            
            const handleStartAnalysis = async (config) => {
                console.log('Starting analysis with config:', config);
                console.log('🔄 Setting isRunningAnalysis to TRUE');
                setIsRunningAnalysis(true);
                setIsAnalysisCancelled(false);
                setAnalysisProgress({ current: 0, total: 0, message: 'Initializing analysis...' });
                // Keep panel visible for single alpha (combined view), hide for multi-alpha
                if (config.analysisMode !== 'single') {
                    setShowAnalysisPanel(false);
                }
                
                // Small delay to ensure UI renders before starting intensive computation
                await new Promise(resolve => setTimeout(resolve, 100));
                
                try {
                    if (config.analysisMode === 'single') {
                        // Single alpha analysis
                        const results = await runSingleAlphaAnalysis(config.alpha);
                        setAnalysisResults(results);
                        console.log(`SSVD complete: ${results.detections} detections, ${results.sparsity}% sparsity, ${results.iterations} iterations`);
                    } else if (config.analysisMode === 'multi') {
                        // Multi-alpha analysis
                        const alphaValues = [];
                        const results = [];
                        
                        // Generate alpha sequence
                        for (let i = 0; i < config.Nalpha; i++) {
                            const alpha = config.alpha0 + (config.alphaMax - config.alpha0) * i / (config.Nalpha - 1);
                            alphaValues.push(alpha);
                        }
                        
                        // Set progress tracking
                        const totalSteps = config.analysisType === 'efdr' ? config.Nalpha + (config.Nalpha * config.Nperm) : config.Nalpha;
                        setAnalysisProgress({ current: 0, total: totalSteps, message: 'Starting alpha sequence analysis...' });
                        
                        // Run SSVD for each alpha
                        for (let i = 0; i < alphaValues.length; i++) {
                            // Check for cancellation
                            if (isAnalysisCancelled) {
                                console.log('Analysis cancelled by user');
                                return;
                            }
                            
                            const alpha = alphaValues[i];
                            console.log(`Running SSVD ${i+1}/${alphaValues.length}: alpha=${alpha.toFixed(4)}`);
                            
                            setAnalysisProgress({ 
                                current: i + 1, 
                                total: totalSteps, 
                                message: `Alpha ${i + 1}/${alphaValues.length}: α=${alpha.toFixed(4)}` 
                            });
                            
                            // Small delay to make progress visible
                            await new Promise(resolve => setTimeout(resolve, 50));
                            
                            const result = await SSVDR1Algorithm({
                                matrix: matrix,
                                alpha: alpha,
                                maxIter: 1000,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                tolerance: 0.001
                            });
                            
                            const detections = result.u.filter(val => Math.abs(val) > 1e-10).length;
                            
                            results.push({
                                index: i,  // Use 0-based indexing for consistency
                                alpha: alpha,
                                detections: detections,
                                iterations: result.iterations,
                                converged: result.converged,
                                u: result.u,
                                v: result.v,
                                s: result.s
                            });
                        }
                        
                        // Calculate detection gradients
                        for (let i = 0; i < results.length; i++) {
                            if (i === 0) {
                                results[i].gradient = 0;
                            } else {
                                const deltaDetections = results[i].detections - results[i-1].detections;
                                const deltaAlpha = results[i].alpha - results[i-1].alpha;
                                results[i].gradient = deltaAlpha > 0 ? deltaDetections / deltaAlpha : 0;
                            }
                        }
                        
                        // Don't set results yet if we're doing eFDR analysis
                        if (config.analysisType === 'alpha') {
                            // Alpha-only analysis - set results immediately
                            setAlphaSequenceResults({
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    matrixSize: `${matrix.length} × ${matrix[0].length}`
                                }
                            });
                        }
                        
                        // Run eFDR if requested
                        if (config.analysisType === 'efdr') {
                            console.log('Running eFDR analysis...');
                            const fdrResults = await runFDRAnalysis({
                                matrix: matrix,
                                alpha0: config.alpha0,
                                alphaMax: config.alphaMax,
                                Nalpha: config.Nalpha,
                                Nperm: config.Nperm,
                                nsupp: config.nsupp,
                                initialSVD: matrixInfo?.initialSVD,  // Pass cached SVD
                                isCancelled: () => isAnalysisCancelled,  // Pass cancellation check
                                onProgress: (current, total, message) => {
                                    const adjustedCurrent = config.Nalpha + current - 1; // Offset for alpha sequence completion
                                    setAnalysisProgress({ 
                                        current: adjustedCurrent, 
                                        total: totalSteps, 
                                        message: `eFDR: ${message}` 
                                    });
                                    console.log(`FDR Progress: ${current}/${total} - ${message}`);
                                }
                            });
                            
                            console.log('FDR Results received:', fdrResults);
                            console.log('FDR Values:', fdrResults.fdrValues);
                            console.log('FDR Results structure:', Object.keys(fdrResults));
                            
                            if (!fdrResults.fdrValues) {
                                console.error('ERROR: fdrResults.fdrValues is undefined!');
                                console.error('Available keys:', Object.keys(fdrResults));
                                alert('eFDR analysis failed: No FDR values returned');
                                return;
                            }
                            
                            // Merge FDR results with alpha results
                            for (let i = 0; i < results.length; i++) {
                                results[i].eFDR = fdrResults.fdrValues[i] ?? 100;  // Default to 100% if undefined
                                console.log(`Result ${i}: alpha=${results[i].alpha}, eFDR=${results[i].eFDR}`);
                            }
                            
                            console.log('Updating state with eFDR results...');
                            console.log('Final results array length:', results.length);
                            console.log('Sample result with eFDR:', results[0]);
                            
                            const finalResultsObject = {
                                mode: 'multi',
                                analysisType: config.analysisType,
                                alphaValues: alphaValues,
                                results: results,  // This now includes eFDR values
                                hasFDR: true,
                                fdrResults: fdrResults,
                                Nperm: config.Nperm,  // Add Nperm for display
                                totalRuns: fdrResults.totalRuns,
                                pi0: fdrResults.pi0,
                                parameters: {
                                    analysisType: config.analysisType,
                                    alpha0: config.alpha0,
                                    alphaMax: config.alphaMax,
                                    Nalpha: config.Nalpha,
                                    Nperm: config.Nperm,
                                    nsupp: config.nsupp,
                                    matrixSize: `${matrix.length} × ${matrix[0].length}`
                                }
                            };
                            
                            console.log('Setting final results object:', finalResultsObject);
                            setAlphaSequenceResults(finalResultsObject);
                            console.log('✅ eFDR state update complete');
                        }
                        
                        console.log(`🎉 Alpha sequence complete: ${config.Nalpha} values tested`);
                    }
                } catch (error) {
                    console.error('Analysis error:', error);
                    alert(`Analysis failed: ${error.message}`);
                } finally {
                    console.log('✅ Setting isRunningAnalysis to FALSE');
                    setIsRunningAnalysis(false);
                    setIsAnalysisCancelled(false);
                    setAnalysisProgress({ current: 0, total: 0, message: '' });
                }
            };

            const cancelAnalysis = () => {
                console.log('🛑 User requested analysis cancellation');
                setIsAnalysisCancelled(true);
                setAnalysisProgress(prev => ({ ...prev, message: 'Cancelling analysis...' }));
            };

            // Debug logging
            useEffect(() => {
                console.log('App State:', {
                    hasOriginalMatrix: !!originalMatrix,
                    hasOriginalStats: !!originalStatistics,
                    hasOriginalEigenvalues: !!originalEigenvalues,
                    showAnalysisPanel,
                    isRunningAnalysis
                });
            }, [originalMatrix, originalStatistics, originalStatistics, showAnalysisPanel, isRunningAnalysis]);
            
            return (
                <div className="min-h-screen bg-gray-50">
                    {/* Main Content */}
                    <div className="max-w-7xl mx-auto px-6 py-8">
                        {/* CSV Upload Component */}
                        {!originalMatrix && <CSVUploader onDataLoaded={handleDataLoaded} />}

                        {/* Matrix Data Review - Show only when no analysis results exist */}
                        {originalMatrix && originalStatistics && !showAnalysisPanel && !analysisResults && !alphaSequenceResults && (
                            <MatrixDataReview 
                                matrix={originalMatrix} 
                                matrixInfo={originalMatrixInfo}
                                statistics={originalStatistics}
                                onProceedToAnalysis={handleProceedToAnalysis}
                            />
                        )}
                        
                        
                        {/* Analysis Selection Steps */}
                        {matrix && matrixInfo && showAnalysisPanel && !isRunningAnalysis && !analysisResults && !alphaSequenceResults && (
                            <AnalysisSelectionSteps
                                analysisStep={analysisStep}
                                onStepSelect={handleAnalysisStepSelect}
                                onBackToReview={handleBackToDataReview}
                            />
                        )}
                        
                        {/* Parameter Configuration for Selected Analysis Type */}
                        {matrix && matrixInfo && showAnalysisPanel && analysisStep === 'single' && (
                            <>
                                <AnalysisConfigurationPanel
                                    matrix={matrix}
                                    matrixInfo={matrixInfo}
                                    analysisStep={analysisStep}
                                    onStartAnalysis={handleStartAnalysis}
                                    onCancel={() => {
                                        setAnalysisStep(null);
                                        setAnalysisResults(null);
                                        setAlphaSequenceResults(null);
                                    }}
                                />
                                {analysisResults && analysisResults.mode === 'single' && (
                                    <SSVDResultsDisplay 
                                        results={analysisResults}
                                        matrixInfo={matrixInfo}
                                        onNewAnalysis={() => {
                                            setAnalysisResults(null);
                                        }}
                                        onResetToOriginal={resetData}
                                        onRerunWithAlpha={handleRerunWithAlpha}
                                    />
                                )}
                            </>
                        )}
                        
                        {/* Multi-alpha configuration - keep separate */}
                        {matrix && matrixInfo && showAnalysisPanel && !isRunningAnalysis && !analysisResults && !alphaSequenceResults && (analysisStep === 'alpha' || analysisStep === 'efdr') && (
                            <AnalysisConfigurationPanel
                                matrix={matrix}
                                matrixInfo={matrixInfo}
                                analysisStep={analysisStep}
                                onStartAnalysis={handleStartAnalysis}
                                onCancel={() => setAnalysisStep(null)}
                            />
                        )}
                        
                        {/* Analysis Running Indicator */}
                        {isRunningAnalysis && (
                            <div className="bg-white rounded-lg shadow-md p-8">
                                <div className="flex flex-col items-center justify-center">
                                    <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mb-4"></div>
                                    <h3 className="text-lg font-semibold text-gray-700 mb-4">Running SSVD Analysis</h3>
                                    {console.log('🎯 PROGRESS BAR RENDERING:', { isRunningAnalysis, analysisProgress })}
                                    
                                    {/* Progress Bar */}
                                    {analysisProgress.total > 0 && (
                                        <div className="w-full max-w-md mb-4">
                                            <div className="flex justify-between text-sm text-gray-600 mb-2">
                                                <span>Progress: {analysisProgress.current}/{analysisProgress.total}</span>
                                                <span>{Math.round((analysisProgress.current / analysisProgress.total) * 100)}%</span>
                                            </div>
                                            <div className="w-full bg-gray-200 rounded-full h-3">
                                                <div 
                                                    className="bg-indigo-600 h-3 rounded-full transition-all duration-300 ease-out"
                                                    style={{ width: `${Math.min((analysisProgress.current / analysisProgress.total) * 100, 100)}%` }}
                                                ></div>
                                            </div>
                                        </div>
                                    )}
                                    
                                    <p className="text-sm text-gray-600 text-center mb-4">
                                        {analysisProgress.message || 'This may take a few moments...'}
                                    </p>
                                    
                                    {/* Cancel Button */}
                                    <button
                                        onClick={cancelAnalysis}
                                        className="px-4 py-2 bg-red-600 text-white rounded-md font-medium hover:bg-red-700 transition-colors"
                                    >
                                        Cancel Analysis
                                    </button>
                                </div>
                            </div>
                        )}
                        
                        {/* Multi-Alpha Results Table */}
                        {originalMatrix && alphaSequenceResults && (
                            <AlphaSequenceResultsDisplay 
                                results={alphaSequenceResults}
                                selectedIndex={selectedAlphaIndex}
                                onSelectAlpha={(index) => {
                                    console.log('Alpha row selected, index:', index);
                                    setSelectedAlphaIndex(index);
                                    console.log('Selected alpha index state updated to:', index);
                                }}
                                onRunSingleAlpha={async (alpha) => {
                                    console.log('Running single alpha analysis from table selection, α =', alpha);
                                    try {
                                        setIsRunningAnalysis(true);
                                        const singleResults = await runSingleAlphaAnalysis(alpha);
                                        setAnalysisResults(singleResults);
                                        // Keep multi-alpha results visible so user can select another row
                                        // setAlphaSequenceResults(null); // REMOVED - keep table visible
                                        // setSelectedAlphaIndex(null); // REMOVED - keep selection visible
                                        console.log('Single alpha analysis complete:', singleResults);
                                    } catch (error) {
                                        console.error('Single alpha analysis failed:', error);
                                        alert(`Analysis failed: ${error.message}`);
                                    } finally {
                                        setIsRunningAnalysis(false);
                                    }
                                }}
                                onNewAnalysis={() => {
                                    // Clear ALL analysis results to go back to parameter selection
                                    setAlphaSequenceResults(null);
                                    setSelectedAlphaIndex(null);
                                    setAnalysisResults(null);
                                    setFDRResults(null);
                                    setSelectedAlpha(null);
                                    setShowAnalysisPanel(true);
                                }}
                                onResetToOriginal={resetData}
                            />
                        )}

                        {/* Old Matrix Information (temporary during transition) */}
                        {matrixInfo && !statistics && (
                            <div className="bg-white rounded-lg shadow-md p-6 mb-6">
                                <h2 className="text-xl font-semibold mb-4">Matrix Information</h2>
                                <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
                                    <div className="bg-blue-50 p-4 rounded-lg">
                                        <div className="text-sm text-blue-600 font-medium">Dimensions</div>
                                        <div className="text-2xl font-bold text-blue-900">{matrixInfo.P} × {matrixInfo.N}</div>
                                        <div className="text-xs text-blue-600 mt-1">
                                            {matrixInfo.rowHeaders ? `${matrixInfo.P} features` : `P=${matrixInfo.P}`} × {matrixInfo.columnHeaders ? `${matrixInfo.N} samples` : `N=${matrixInfo.N}`}
                                        </div>
                                    </div>
                                    <div className="bg-purple-50 p-4 rounded-lg">
                                        <div className="text-sm text-purple-600 font-medium">File</div>
                                        <div className="text-lg font-bold text-purple-900 truncate">{matrixInfo.filename}</div>
                                        <div className="text-xs text-purple-600 mt-1">{(matrixInfo.fileSize / 1024).toFixed(1)} KB</div>
                                    </div>
                                    <div className="bg-orange-50 p-4 rounded-lg">
                                        <div className="text-sm text-orange-600 font-medium">Format</div>
                                        <div className="text-lg font-bold text-orange-900">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Gene Expression' : 
                                             matrixInfo.hasHeaders ? 'With Headers' : 'Pure Numeric'}
                                        </div>
                                        <div className="text-xs text-orange-600 mt-1">
                                            {matrixInfo.rowHeaders && matrixInfo.columnHeaders ? 'Row & column headers' :
                                             matrixInfo.rowHeaders ? 'Row headers detected' :
                                             matrixInfo.columnHeaders ? 'Column headers detected' :
                                             'No headers detected'}
                                        </div>
                                    </div>
                                </div>
                                
                                {/* Show sample headers if available */}
                                {(matrixInfo.rowHeaders || matrixInfo.columnHeaders) && (
                                    <div className="mt-4 p-3 bg-gray-50 rounded-lg">
                                        <div className="text-sm text-gray-600">
                                            {matrixInfo.rowHeaders && (
                                                <div className="mb-2">
                                                    <span className="font-medium">Sample features: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.rowHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.rowHeaders.length > 5 && ` ... (${matrixInfo.rowHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                            {matrixInfo.columnHeaders && (
                                                <div>
                                                    <span className="font-medium">Sample names: </span>
                                                    <span className="font-mono text-xs">
                                                        {matrixInfo.columnHeaders.slice(0, 5).join(', ')}
                                                        {matrixInfo.columnHeaders.length > 5 && ` ... (${matrixInfo.columnHeaders.length} total)`}
                                                    </span>
                                                </div>
                                            )}
                                        </div>
                                    </div>
                                )}
                            </div>
                        )}

                        {/* FDR Analysis Panel - Only shown when user proceeds to analysis */}
                        {/* This will be implemented in Phase 4 */}

                        {/* Phase 3: FDR Results Display */}
                        {originalMatrix && fdrResults && <FDRResultsDisplay 
                            results={fdrResults} 
                            onAlphaSelected={setSelectedAlpha} 
                            selectedAlpha={selectedAlpha}
                            onRunSingleAlpha={async (alpha) => {
                                console.log('🚀 Running SSVD from FDR display, α =', alpha);
                                try {
                                    setIsRunningAnalysis(true);
                                    const singleResults = await runSingleAlphaAnalysis(alpha);
                                    setAnalysisResults(singleResults);
                                    console.log('✅ SSVD analysis complete:', singleResults);
                                } catch (error) {
                                    console.error('❌ SSVD analysis failed:', error);
                                    alert(`Analysis failed: ${error.message}`);
                                } finally {
                                    setIsRunningAnalysis(false);
                                }
                            }}
                        />}
                    </div>
                </div>
            );
        };

        // Render the application
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>